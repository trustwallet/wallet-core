// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings to `gen/headers/**.h
class TrustWalletCore {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  TrustWalletCore(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  TrustWalletCore.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> signal(
    int arg0,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> arg1,
  ) {
    return _signal(
      arg0,
      arg1,
    );
  }

  late final _signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
              ffi.Int,
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>>('signal');
  late final _signal = _signalPtr.asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
          int, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>();

  int getpriority(
    int arg0,
    int arg1,
  ) {
    return _getpriority(
      arg0,
      arg1,
    );
  }

  late final _getpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t)>>(
          'getpriority');
  late final _getpriority =
      _getpriorityPtr.asFunction<int Function(int, int)>();

  int getiopolicy_np(
    int arg0,
    int arg1,
  ) {
    return _getiopolicy_np(
      arg0,
      arg1,
    );
  }

  late final _getiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'getiopolicy_np');
  late final _getiopolicy_np =
      _getiopolicy_npPtr.asFunction<int Function(int, int)>();

  int getrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _getrlimit(
      arg0,
      arg1,
    );
  }

  late final _getrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'getrlimit');
  late final _getrlimit =
      _getrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int getrusage(
    int arg0,
    ffi.Pointer<rusage> arg1,
  ) {
    return _getrusage(
      arg0,
      arg1,
    );
  }

  late final _getrusagePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rusage>)>>(
      'getrusage');
  late final _getrusage =
      _getrusagePtr.asFunction<int Function(int, ffi.Pointer<rusage>)>();

  int setpriority(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setpriority(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t, ffi.Int)>>(
          'setpriority');
  late final _setpriority =
      _setpriorityPtr.asFunction<int Function(int, int, int)>();

  int setiopolicy_np(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setiopolicy_np(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'setiopolicy_np');
  late final _setiopolicy_np =
      _setiopolicy_npPtr.asFunction<int Function(int, int, int)>();

  int setrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _setrlimit(
      arg0,
      arg1,
    );
  }

  late final _setrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'setrlimit');
  late final _setrlimit =
      _setrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int wait1(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _wait1(
      arg0,
    );
  }

  late final _wait1Ptr =
      _lookup<ffi.NativeFunction<pid_t Function(ffi.Pointer<ffi.Int>)>>('wait');
  late final _wait1 =
      _wait1Ptr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int waitpid(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
  ) {
    return _waitpid(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _waitpidPtr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int)>>('waitpid');
  late final _waitpid =
      _waitpidPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int>, int)>();

  int waitid(
    idtype_t arg0,
    Dart__uint32_t arg1,
    ffi.Pointer<siginfo_t> arg2,
    int arg3,
  ) {
    return _waitid(
      arg0.value,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _waitidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, id_t, ffi.Pointer<siginfo_t>,
              ffi.Int)>>('waitid');
  late final _waitid = _waitidPtr
      .asFunction<int Function(int, int, ffi.Pointer<siginfo_t>, int)>();

  int wait3(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
    ffi.Pointer<rusage> arg2,
  ) {
    return _wait3(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wait3Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(
              ffi.Pointer<ffi.Int>, ffi.Int, ffi.Pointer<rusage>)>>('wait3');
  late final _wait3 = _wait3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  int wait4(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
    ffi.Pointer<rusage> arg3,
  ) {
    return _wait4(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _wait4Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int,
              ffi.Pointer<rusage>)>>('wait4');
  late final _wait4 = _wait4Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  ffi.Pointer<ffi.Void> alloca(
    int arg0,
  ) {
    return _alloca(
      arg0,
    );
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'alloca');
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  late final ffi.Pointer<ffi.Int> ___mb_cur_max =
      _lookup<ffi.Int>('__mb_cur_max');

  int get __mb_cur_max => ___mb_cur_max.value;

  set __mb_cur_max(int value) => ___mb_cur_max.value = value;

  ffi.Pointer<ffi.Void> malloc_type_malloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_malloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_malloc');
  late final _malloc_type_malloc = _malloc_type_mallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_calloc(
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_calloc(
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, ffi.Size, malloc_type_id_t)>>('malloc_type_calloc');
  late final _malloc_type_calloc = _malloc_type_callocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  void malloc_type_free(
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_free(
      ptr,
      type_id,
    );
  }

  late final _malloc_type_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, malloc_type_id_t)>>('malloc_type_free');
  late final _malloc_type_free = _malloc_type_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_realloc(
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_realloc(
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_realloc');
  late final _malloc_type_realloc = _malloc_type_reallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_valloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_valloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_valloc');
  late final _malloc_type_valloc = _malloc_type_vallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_aligned_alloc(
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_aligned_alloc(
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size,
              malloc_type_id_t)>>('malloc_type_aligned_alloc');
  late final _malloc_type_aligned_alloc = _malloc_type_aligned_allocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  int malloc_type_posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> memptr,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_posix_memalign(
      memptr,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_posix_memalign');
  late final _malloc_type_posix_memalign =
      _malloc_type_posix_memalignPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_malloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_malloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_malloc');
  late final _malloc_type_zone_malloc = _malloc_type_zone_mallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_calloc(
    ffi.Pointer<malloc_zone_t> zone,
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_calloc(
      zone,
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_calloc');
  late final _malloc_type_zone_calloc = _malloc_type_zone_callocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<malloc_zone_t>, int, int, int)>();

  void malloc_type_zone_free(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_zone_free(
      zone,
      ptr,
      type_id,
    );
  }

  late final _malloc_type_zone_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>,
              malloc_type_id_t)>>('malloc_type_zone_free');
  late final _malloc_type_zone_free = _malloc_type_zone_freePtr.asFunction<
      void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_realloc(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_realloc(
      zone,
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_realloc');
  late final _malloc_type_zone_realloc =
      _malloc_type_zone_reallocPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_valloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_valloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_valloc');
  late final _malloc_type_zone_valloc = _malloc_type_zone_vallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_memalign(
    ffi.Pointer<malloc_zone_t> zone,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_memalign(
      zone,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_memalign');
  late final _malloc_type_zone_memalign =
      _malloc_type_zone_memalignPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __count,
    int __size,
  ) {
    return _calloc(
      __count,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void free(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _free(
      arg0,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> reallocf(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _reallocf(
      __ptr,
      __size,
    );
  }

  late final _reallocfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('reallocf');
  late final _reallocf = _reallocfPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> valloc(
    int arg0,
  ) {
    return _valloc(
      arg0,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int abs(
    int arg0,
  ) {
    return _abs(
      arg0,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _atexit(
      arg0,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  double atof(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atof(
      arg0,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoi(
      arg0,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atol(
      arg0,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoll(
      arg0,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  div_t div(
    int arg0,
    int arg1,
  ) {
    return _div(
      arg0,
      arg1,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  void exit(
    int arg0,
  ) {
    return _exit(
      arg0,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getenv(
      arg0,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int labs(
    int arg0,
  ) {
    return _labs(
      arg0,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  ldiv_t ldiv(
    int arg0,
    int arg1,
  ) {
    return _ldiv(
      arg0,
      arg1,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  int llabs(
    int arg0,
  ) {
    return _llabs(
      arg0,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  lldiv_t lldiv(
    int arg0,
    int arg1,
  ) {
    return _lldiv(
      arg0,
      arg1,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mbstowcs(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mbtowc(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  void srand(
    int arg0,
  ) {
    return _srand(
      arg0,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  double strtod(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtod(
      arg0,
      arg1,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtof(
      arg0,
      arg1,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int system(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _system(
      arg0,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.WChar> arg1,
    int arg2,
  ) {
    return _wcstombs(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _wctomb(
      arg0,
      arg1,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  void _Exit(
    int arg0,
  ) {
    return __Exit(
      arg0,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _a64l(
      arg0,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  ffi.Pointer<ffi.Char> ecvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _ecvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _erand48(
      arg0,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _fcvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _gcvt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _getsubopt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int grantpt(
    int arg0,
  ) {
    return _grantpt(
      arg0,
    );
  }

  late final _grantptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('grantpt');
  late final _grantpt = _grantptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _initstate(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _jrand48(
      arg0,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> l64a(
    int arg0,
  ) {
    return _l64a(
      arg0,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _lcong48(
      arg0,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mktemp(
      arg0,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mkstemp(
      arg0,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _nrand48(
      arg0,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int posix_openpt(
    int arg0,
  ) {
    return _posix_openpt(
      arg0,
    );
  }

  late final _posix_openptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('posix_openpt');
  late final _posix_openpt = _posix_openptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> ptsname(
    int arg0,
  ) {
    return _ptsname(
      arg0,
    );
  }

  late final _ptsnamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'ptsname');
  late final _ptsname =
      _ptsnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int ptsname_r(
    int fildes,
    ffi.Pointer<ffi.Char> buffer,
    int buflen,
  ) {
    return _ptsname_r(
      fildes,
      buffer,
      buflen,
    );
  }

  late final _ptsname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('ptsname_r');
  late final _ptsname_r =
      _ptsname_rPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int putenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _putenv(
      arg0,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> arg0,
  ) {
    return _rand_r(
      arg0,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _realpath(
      arg0,
      arg1,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _seed48(
      arg0,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __overwrite,
  ) {
    return _setenv(
      __name,
      __value,
      __overwrite,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void setkey(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setkey(
      arg0,
    );
  }

  late final _setkeyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setkey');
  late final _setkey =
      _setkeyPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setstate(
      arg0,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void srand48(
    int arg0,
  ) {
    return _srand48(
      arg0,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  void srandom(
    int arg0,
  ) {
    return _srandom(
      arg0,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  int unlockpt(
    int arg0,
  ) {
    return _unlockpt(
      arg0,
    );
  }

  late final _unlockptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('unlockpt');
  late final _unlockpt = _unlockptPtr.asFunction<int Function(int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _unsetenv(
      arg0,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int arc4random() {
    return _arc4random();
  }

  late final _arc4randomPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('arc4random');
  late final _arc4random = _arc4randomPtr.asFunction<int Function()>();

  void arc4random_addrandom(
    ffi.Pointer<ffi.UnsignedChar> arg0,
    int arg1,
  ) {
    return _arc4random_addrandom(
      arg0,
      arg1,
    );
  }

  late final _arc4random_addrandomPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>>('arc4random_addrandom');
  late final _arc4random_addrandom = _arc4random_addrandomPtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  void arc4random_buf(
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
  ) {
    return _arc4random_buf(
      __buf,
      __nbytes,
    );
  }

  late final _arc4random_bufPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>(
      'arc4random_buf');
  late final _arc4random_buf = _arc4random_bufPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  void arc4random_stir() {
    return _arc4random_stir();
  }

  late final _arc4random_stirPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('arc4random_stir');
  late final _arc4random_stir =
      _arc4random_stirPtr.asFunction<void Function()>();

  int arc4random_uniform(
    int __upper_bound,
  ) {
    return _arc4random_uniform(
      __upper_bound,
    );
  }

  late final _arc4random_uniformPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Uint32)>>(
          'arc4random_uniform');
  late final _arc4random_uniform =
      _arc4random_uniformPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> cgetcap(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _cgetcap(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetcapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('cgetcap');
  late final _cgetcap = _cgetcapPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int cgetclose() {
    return _cgetclose();
  }

  late final _cgetclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('cgetclose');
  late final _cgetclose = _cgetclosePtr.asFunction<int Function()>();

  int cgetent(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _cgetent(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('cgetent');
  late final _cgetent = _cgetentPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int cgetfirst(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetfirst(
      arg0,
      arg1,
    );
  }

  late final _cgetfirstPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetfirst');
  late final _cgetfirst = _cgetfirstPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetmatch(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _cgetmatch(
      arg0,
      arg1,
    );
  }

  late final _cgetmatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('cgetmatch');
  late final _cgetmatch = _cgetmatchPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int cgetnext(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetnext(
      arg0,
      arg1,
    );
  }

  late final _cgetnextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetnext');
  late final _cgetnext = _cgetnextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetnum(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Long> arg2,
  ) {
    return _cgetnum(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetnumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Long>)>>('cgetnum');
  late final _cgetnum = _cgetnumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Long>)>();

  int cgetset(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _cgetset(
      arg0,
    );
  }

  late final _cgetsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'cgetset');
  late final _cgetset =
      _cgetsetPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int cgetstr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetstr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetstr');
  late final _cgetstr = _cgetstrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetustr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetustr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetustrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetustr');
  late final _cgetustr = _cgetustrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int daemon(
    int arg0,
    int arg1,
  ) {
    return _daemon(
      arg0,
      arg1,
    );
  }

  late final _daemonPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('daemon');
  late final _daemon = _daemonPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> devname(
    int arg0,
    int arg1,
  ) {
    return _devname(
      arg0,
      arg1,
    );
  }

  late final _devnamePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(dev_t, mode_t)>>(
      'devname');
  late final _devname =
      _devnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  ffi.Pointer<ffi.Char> devname_r(
    int arg0,
    int arg1,
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _devname_r(
      arg0,
      arg1,
      buf,
      len,
    );
  }

  late final _devname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              dev_t, mode_t, ffi.Pointer<ffi.Char>, ffi.Int)>>('devname_r');
  late final _devname_r = _devname_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> getbsize(
    ffi.Pointer<ffi.Int> arg0,
    ffi.Pointer<ffi.Long> arg1,
  ) {
    return _getbsize(
      arg0,
      arg1,
    );
  }

  late final _getbsizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>>('getbsize');
  late final _getbsize = _getbsizePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>();

  int getloadavg(
    ffi.Pointer<ffi.Double> arg0,
    int arg1,
  ) {
    return _getloadavg(
      arg0,
      arg1,
    );
  }

  late final _getloadavgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>>('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  ffi.Pointer<ffi.Char> getprogname() {
    return _getprogname();
  }

  late final _getprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'getprogname');
  late final _getprogname =
      _getprognamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void setprogname(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setprogname(
      arg0,
    );
  }

  late final _setprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setprogname');
  late final _setprogname =
      _setprognamePtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int heapsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _heapsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _heapsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('heapsort');
  late final _heapsort = _heapsortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int mergesort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _mergesort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _mergesortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('mergesort');
  late final _mergesort = _mergesortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _psortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort');
  late final _psort = _psortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _psort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort_r');
  late final _psort_r = _psort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  void qsort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _qsort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort_r');
  late final _qsort_r = _qsort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  int radixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _radixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _radixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('radixsort');
  late final _radixsort = _radixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  int rpmatch(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _rpmatch(
      arg0,
    );
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rpmatch');
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sradixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _sradixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _sradixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('sradixsort');
  late final _sradixsort = _sradixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  void sranddev() {
    return _sranddev();
  }

  late final _sranddevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('sranddev');
  late final _sranddev = _sranddevPtr.asFunction<void Function()>();

  void srandomdev() {
    return _srandomdev();
  }

  late final _srandomdevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('srandomdev');
  late final _srandomdev = _srandomdevPtr.asFunction<void Function()>();

  int strtonum(
    ffi.Pointer<ffi.Char> __numstr,
    int __minval,
    int __maxval,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __errstrp,
  ) {
    return _strtonum(
      __numstr,
      __minval,
      __maxval,
      __errstrp,
    );
  }

  late final _strtonumPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>, ffi.LongLong,
              ffi.LongLong, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtonum');
  late final _strtonum = _strtonumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtoq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoqPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoq');
  late final _strtoq = _strtoqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtouq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtouqPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtouq');
  late final _strtouq = _strtouqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _suboptarg =
      _lookup<ffi.Pointer<ffi.Char>>('suboptarg');

  ffi.Pointer<ffi.Char> get suboptarg => _suboptarg.value;

  set suboptarg(ffi.Pointer<ffi.Char> value) => _suboptarg.value = value;

  /// Creates a block of data from a byte array.
  ///
  /// \param bytes Non-null raw bytes buffer
  /// \param size size of the buffer
  /// \return Non-null filled block of data.
  ffi.Pointer<TWData> TWDataCreateWithBytes(
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _TWDataCreateWithBytes(
      bytes,
      size,
    );
  }

  late final _TWDataCreateWithBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('TWDataCreateWithBytes');
  late final _TWDataCreateWithBytes = _TWDataCreateWithBytesPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Creates an uninitialized block of data with the provided size.
  ///
  /// \param size size for the block of data
  /// \return Non-null uninitialized block of data with the provided size
  ffi.Pointer<TWData> TWDataCreateWithSize(
    int size,
  ) {
    return _TWDataCreateWithSize(
      size,
    );
  }

  late final _TWDataCreateWithSizePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWData> Function(ffi.Size)>>(
          'TWDataCreateWithSize');
  late final _TWDataCreateWithSize =
      _TWDataCreateWithSizePtr.asFunction<ffi.Pointer<TWData> Function(int)>();

  /// Creates a block of data by copying another block of data.
  ///
  /// \param data buffer that need to be copied
  /// \return Non-null filled block of data.
  ffi.Pointer<TWData> TWDataCreateWithData(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataCreateWithData(
      data,
    );
  }

  late final _TWDataCreateWithDataPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWDataCreateWithData');
  late final _TWDataCreateWithData = _TWDataCreateWithDataPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Creates a block of data from a hexadecimal string.  Odd length is invalid (intended grouping to bytes is not obvious).
  ///
  /// \param hex input hex string
  /// \return Non-null filled block of data
  ffi.Pointer<TWData> TWDataCreateWithHexString(
    ffi.Pointer<TWString> hex,
  ) {
    return _TWDataCreateWithHexString(
      hex,
    );
  }

  late final _TWDataCreateWithHexStringPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>>(
      'TWDataCreateWithHexString');
  late final _TWDataCreateWithHexString = _TWDataCreateWithHexStringPtr
      .asFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>();

  /// Returns the size in bytes.
  ///
  /// \param data A non-null valid block of data
  /// \return the size of the given block of data
  int TWDataSize(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataSize(
      data,
    );
  }

  late final _TWDataSizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWData>)>>(
          'TWDataSize');
  late final _TWDataSize =
      _TWDataSizePtr.asFunction<int Function(ffi.Pointer<TWData>)>();

  /// Returns the raw pointer to the contents of data.
  ///
  /// \param data A non-null valid block of data
  /// \return the raw pointer to the contents of data
  ffi.Pointer<ffi.Uint8> TWDataBytes(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataBytes(
      data,
    );
  }

  late final _TWDataBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<TWData>)>>('TWDataBytes');
  late final _TWDataBytes = _TWDataBytesPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<TWData>)>();

  /// Returns the byte at the provided index.
  ///
  /// \param data A non-null valid block of data
  /// \param index index of the byte that we want to fetch - index need to be < TWDataSize(data)
  /// \return the byte at the provided index
  int TWDataGet(
    ffi.Pointer<TWData> data,
    int index,
  ) {
    return _TWDataGet(
      data,
      index,
    );
  }

  late final _TWDataGetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<TWData>, ffi.Size)>>('TWDataGet');
  late final _TWDataGet =
      _TWDataGetPtr.asFunction<int Function(ffi.Pointer<TWData>, int)>();

  /// Sets the byte at the provided index.
  ///
  /// \param data A non-null valid block of data
  /// \param index index of the byte that we want to set - index need to be < TWDataSize(data)
  /// \param byte Given byte to be written in data
  void TWDataSet(
    ffi.Pointer<TWData> data,
    int index,
    int byte,
  ) {
    return _TWDataSet(
      data,
      index,
      byte,
    );
  }

  late final _TWDataSetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<TWData>, ffi.Size, ffi.Uint8)>>('TWDataSet');
  late final _TWDataSet =
      _TWDataSetPtr.asFunction<void Function(ffi.Pointer<TWData>, int, int)>();

  /// Copies a range of bytes into the provided buffer.
  ///
  /// \param data A non-null valid block of data
  /// \param start starting index of the range - index need to be < TWDataSize(data)
  /// \param size size of the range we want to copy - size need to be < TWDataSize(data) - start
  /// \param output The output buffer where we want to copy the data.
  void TWDataCopyBytes(
    ffi.Pointer<TWData> data,
    int start,
    int size,
    ffi.Pointer<ffi.Uint8> output,
  ) {
    return _TWDataCopyBytes(
      data,
      start,
      size,
      output,
    );
  }

  late final _TWDataCopyBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWData>, ffi.Size, ffi.Size,
              ffi.Pointer<ffi.Uint8>)>>('TWDataCopyBytes');
  late final _TWDataCopyBytes = _TWDataCopyBytesPtr.asFunction<
      void Function(ffi.Pointer<TWData>, int, int, ffi.Pointer<ffi.Uint8>)>();

  /// Replaces a range of bytes with the contents of the provided buffer.
  ///
  /// \param data A non-null valid block of data
  /// \param start starting index of the range - index need to be < TWDataSize(data)
  /// \param size size of the range we want to replace - size need to be < TWDataSize(data) - start
  /// \param bytes The buffer that will replace the range of data
  void TWDataReplaceBytes(
    ffi.Pointer<TWData> data,
    int start,
    int size,
    ffi.Pointer<ffi.Uint8> bytes,
  ) {
    return _TWDataReplaceBytes(
      data,
      start,
      size,
      bytes,
    );
  }

  late final _TWDataReplaceBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWData>, ffi.Size, ffi.Size,
              ffi.Pointer<ffi.Uint8>)>>('TWDataReplaceBytes');
  late final _TWDataReplaceBytes = _TWDataReplaceBytesPtr.asFunction<
      void Function(ffi.Pointer<TWData>, int, int, ffi.Pointer<ffi.Uint8>)>();

  /// Appends data from a byte array.
  ///
  /// \param data A non-null valid block of data
  /// \param bytes Non-null byte array
  /// \param size The size of the byte array
  void TWDataAppendBytes(
    ffi.Pointer<TWData> data,
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _TWDataAppendBytes(
      data,
      bytes,
      size,
    );
  }

  late final _TWDataAppendBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWData>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('TWDataAppendBytes');
  late final _TWDataAppendBytes = _TWDataAppendBytesPtr.asFunction<
      void Function(ffi.Pointer<TWData>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Appends a single byte.
  ///
  /// \param data A non-null valid block of data
  /// \param byte A single byte
  void TWDataAppendByte(
    ffi.Pointer<TWData> data,
    int byte,
  ) {
    return _TWDataAppendByte(
      data,
      byte,
    );
  }

  late final _TWDataAppendBytePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<TWData>, ffi.Uint8)>>(
      'TWDataAppendByte');
  late final _TWDataAppendByte = _TWDataAppendBytePtr.asFunction<
      void Function(ffi.Pointer<TWData>, int)>();

  /// Appends a block of data.
  ///
  /// \param data A non-null valid block of data
  /// \param append A non-null valid block of data
  void TWDataAppendData(
    ffi.Pointer<TWData> data,
    ffi.Pointer<TWData> append,
  ) {
    return _TWDataAppendData(
      data,
      append,
    );
  }

  late final _TWDataAppendDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWData>)>>('TWDataAppendData');
  late final _TWDataAppendData = _TWDataAppendDataPtr.asFunction<
      void Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>)>();

  /// Reverse the bytes.
  ///
  /// \param data A non-null valid block of data
  void TWDataReverse(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataReverse(
      data,
    );
  }

  late final _TWDataReversePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWData>)>>(
          'TWDataReverse');
  late final _TWDataReverse =
      _TWDataReversePtr.asFunction<void Function(ffi.Pointer<TWData>)>();

  /// Sets all bytes to the given value.
  ///
  /// \param data A non-null valid block of data
  void TWDataReset(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataReset(
      data,
    );
  }

  late final _TWDataResetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWData>)>>(
          'TWDataReset');
  late final _TWDataReset =
      _TWDataResetPtr.asFunction<void Function(ffi.Pointer<TWData>)>();

  /// Deletes a block of data created with a `TWDataCreate*` method.
  ///
  /// \param data A non-null valid block of data
  void TWDataDelete(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataDelete(
      data,
    );
  }

  late final _TWDataDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWData>)>>(
          'TWDataDelete');
  late final _TWDataDelete =
      _TWDataDeletePtr.asFunction<void Function(ffi.Pointer<TWData>)>();

  /// Determines whether two data blocks are equal.
  ///
  /// \param lhs left non null block of data to be compared
  /// \param rhs right non null block of data to be compared
  /// \return true if both block of data are equal, false otherwise
  bool TWDataEqual(
    ffi.Pointer<TWData> lhs,
    ffi.Pointer<TWData> rhs,
  ) {
    return _TWDataEqual(
      lhs,
      rhs,
    );
  }

  late final _TWDataEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWData>)>>('TWDataEqual');
  late final _TWDataEqual = _TWDataEqualPtr.asFunction<
      bool Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>)>();

  /// Determine if the HD Version is public
  ///
  /// \param version HD version
  /// \return true if the version is public, false otherwise
  bool TWHDVersionIsPublic(
    TWHDVersion version,
  ) {
    return _TWHDVersionIsPublic(
      version.value,
    );
  }

  late final _TWHDVersionIsPublicPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.UnsignedInt)>>(
          'TWHDVersionIsPublic');
  late final _TWHDVersionIsPublic =
      _TWHDVersionIsPublicPtr.asFunction<bool Function(int)>();

  /// Determine if the HD Version is private
  ///
  /// \param version HD version
  /// \return true if the version is private, false otherwise
  bool TWHDVersionIsPrivate(
    TWHDVersion version,
  ) {
    return _TWHDVersionIsPrivate(
      version.value,
    );
  }

  late final _TWHDVersionIsPrivatePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.UnsignedInt)>>(
          'TWHDVersionIsPrivate');
  late final _TWHDVersionIsPrivate =
      _TWHDVersionIsPrivatePtr.asFunction<bool Function(int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BITCOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BITCOIN');

  ffi.Pointer<ffi.Char> get HRP_BITCOIN => _HRP_BITCOIN.value;

  set HRP_BITCOIN(ffi.Pointer<ffi.Char> value) => _HRP_BITCOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_LITECOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_LITECOIN');

  ffi.Pointer<ffi.Char> get HRP_LITECOIN => _HRP_LITECOIN.value;

  set HRP_LITECOIN(ffi.Pointer<ffi.Char> value) => _HRP_LITECOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_VIACOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_VIACOIN');

  ffi.Pointer<ffi.Char> get HRP_VIACOIN => _HRP_VIACOIN.value;

  set HRP_VIACOIN(ffi.Pointer<ffi.Char> value) => _HRP_VIACOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_GROESTLCOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_GROESTLCOIN');

  ffi.Pointer<ffi.Char> get HRP_GROESTLCOIN => _HRP_GROESTLCOIN.value;

  set HRP_GROESTLCOIN(ffi.Pointer<ffi.Char> value) =>
      _HRP_GROESTLCOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_DIGIBYTE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_DIGIBYTE');

  ffi.Pointer<ffi.Char> get HRP_DIGIBYTE => _HRP_DIGIBYTE.value;

  set HRP_DIGIBYTE(ffi.Pointer<ffi.Char> value) => _HRP_DIGIBYTE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_MONACOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_MONACOIN');

  ffi.Pointer<ffi.Char> get HRP_MONACOIN => _HRP_MONACOIN.value;

  set HRP_MONACOIN(ffi.Pointer<ffi.Char> value) => _HRP_MONACOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_SYSCOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_SYSCOIN');

  ffi.Pointer<ffi.Char> get HRP_SYSCOIN => _HRP_SYSCOIN.value;

  set HRP_SYSCOIN(ffi.Pointer<ffi.Char> value) => _HRP_SYSCOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_VERGE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_VERGE');

  ffi.Pointer<ffi.Char> get HRP_VERGE => _HRP_VERGE.value;

  set HRP_VERGE(ffi.Pointer<ffi.Char> value) => _HRP_VERGE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_COSMOS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_COSMOS');

  ffi.Pointer<ffi.Char> get HRP_COSMOS => _HRP_COSMOS.value;

  set HRP_COSMOS(ffi.Pointer<ffi.Char> value) => _HRP_COSMOS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BITCOINCASH =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BITCOINCASH');

  ffi.Pointer<ffi.Char> get HRP_BITCOINCASH => _HRP_BITCOINCASH.value;

  set HRP_BITCOINCASH(ffi.Pointer<ffi.Char> value) =>
      _HRP_BITCOINCASH.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BITCOINGOLD =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BITCOINGOLD');

  ffi.Pointer<ffi.Char> get HRP_BITCOINGOLD => _HRP_BITCOINGOLD.value;

  set HRP_BITCOINGOLD(ffi.Pointer<ffi.Char> value) =>
      _HRP_BITCOINGOLD.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_IOTEX =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_IOTEX');

  ffi.Pointer<ffi.Char> get HRP_IOTEX => _HRP_IOTEX.value;

  set HRP_IOTEX(ffi.Pointer<ffi.Char> value) => _HRP_IOTEX.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NERVOS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NERVOS');

  ffi.Pointer<ffi.Char> get HRP_NERVOS => _HRP_NERVOS.value;

  set HRP_NERVOS(ffi.Pointer<ffi.Char> value) => _HRP_NERVOS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_ZILLIQA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_ZILLIQA');

  ffi.Pointer<ffi.Char> get HRP_ZILLIQA => _HRP_ZILLIQA.value;

  set HRP_ZILLIQA(ffi.Pointer<ffi.Char> value) => _HRP_ZILLIQA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_TERRA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_TERRA');

  ffi.Pointer<ffi.Char> get HRP_TERRA => _HRP_TERRA.value;

  set HRP_TERRA(ffi.Pointer<ffi.Char> value) => _HRP_TERRA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_CRYPTOORG =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_CRYPTOORG');

  ffi.Pointer<ffi.Char> get HRP_CRYPTOORG => _HRP_CRYPTOORG.value;

  set HRP_CRYPTOORG(ffi.Pointer<ffi.Char> value) =>
      _HRP_CRYPTOORG.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_KAVA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_KAVA');

  ffi.Pointer<ffi.Char> get HRP_KAVA => _HRP_KAVA.value;

  set HRP_KAVA(ffi.Pointer<ffi.Char> value) => _HRP_KAVA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_OASIS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_OASIS');

  ffi.Pointer<ffi.Char> get HRP_OASIS => _HRP_OASIS.value;

  set HRP_OASIS(ffi.Pointer<ffi.Char> value) => _HRP_OASIS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BLUZELLE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BLUZELLE');

  ffi.Pointer<ffi.Char> get HRP_BLUZELLE => _HRP_BLUZELLE.value;

  set HRP_BLUZELLE(ffi.Pointer<ffi.Char> value) => _HRP_BLUZELLE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BAND =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BAND');

  ffi.Pointer<ffi.Char> get HRP_BAND => _HRP_BAND.value;

  set HRP_BAND(ffi.Pointer<ffi.Char> value) => _HRP_BAND.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_ELROND =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_ELROND');

  ffi.Pointer<ffi.Char> get HRP_ELROND => _HRP_ELROND.value;

  set HRP_ELROND(ffi.Pointer<ffi.Char> value) => _HRP_ELROND.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_SECRET =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_SECRET');

  ffi.Pointer<ffi.Char> get HRP_SECRET => _HRP_SECRET.value;

  set HRP_SECRET(ffi.Pointer<ffi.Char> value) => _HRP_SECRET.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_AGORIC =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_AGORIC');

  ffi.Pointer<ffi.Char> get HRP_AGORIC => _HRP_AGORIC.value;

  set HRP_AGORIC(ffi.Pointer<ffi.Char> value) => _HRP_AGORIC.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BINANCE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BINANCE');

  ffi.Pointer<ffi.Char> get HRP_BINANCE => _HRP_BINANCE.value;

  set HRP_BINANCE(ffi.Pointer<ffi.Char> value) => _HRP_BINANCE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_ECASH =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_ECASH');

  ffi.Pointer<ffi.Char> get HRP_ECASH => _HRP_ECASH.value;

  set HRP_ECASH(ffi.Pointer<ffi.Char> value) => _HRP_ECASH.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_THORCHAIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_THORCHAIN');

  ffi.Pointer<ffi.Char> get HRP_THORCHAIN => _HRP_THORCHAIN.value;

  set HRP_THORCHAIN(ffi.Pointer<ffi.Char> value) =>
      _HRP_THORCHAIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BITCOINDIAMOND =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BITCOINDIAMOND');

  ffi.Pointer<ffi.Char> get HRP_BITCOINDIAMOND => _HRP_BITCOINDIAMOND.value;

  set HRP_BITCOINDIAMOND(ffi.Pointer<ffi.Char> value) =>
      _HRP_BITCOINDIAMOND.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_HARMONY =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_HARMONY');

  ffi.Pointer<ffi.Char> get HRP_HARMONY => _HRP_HARMONY.value;

  set HRP_HARMONY(ffi.Pointer<ffi.Char> value) => _HRP_HARMONY.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_CARDANO =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_CARDANO');

  ffi.Pointer<ffi.Char> get HRP_CARDANO => _HRP_CARDANO.value;

  set HRP_CARDANO(ffi.Pointer<ffi.Char> value) => _HRP_CARDANO.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_QTUM =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_QTUM');

  ffi.Pointer<ffi.Char> get HRP_QTUM => _HRP_QTUM.value;

  set HRP_QTUM(ffi.Pointer<ffi.Char> value) => _HRP_QTUM.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_STRATIS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_STRATIS');

  ffi.Pointer<ffi.Char> get HRP_STRATIS => _HRP_STRATIS.value;

  set HRP_STRATIS(ffi.Pointer<ffi.Char> value) => _HRP_STRATIS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NATIVEINJECTIVE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NATIVEINJECTIVE');

  ffi.Pointer<ffi.Char> get HRP_NATIVEINJECTIVE => _HRP_NATIVEINJECTIVE.value;

  set HRP_NATIVEINJECTIVE(ffi.Pointer<ffi.Char> value) =>
      _HRP_NATIVEINJECTIVE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_OSMOSIS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_OSMOSIS');

  ffi.Pointer<ffi.Char> get HRP_OSMOSIS => _HRP_OSMOSIS.value;

  set HRP_OSMOSIS(ffi.Pointer<ffi.Char> value) => _HRP_OSMOSIS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_TERRAV2 =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_TERRAV2');

  ffi.Pointer<ffi.Char> get HRP_TERRAV2 => _HRP_TERRAV2.value;

  set HRP_TERRAV2(ffi.Pointer<ffi.Char> value) => _HRP_TERRAV2.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_COREUM =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_COREUM');

  ffi.Pointer<ffi.Char> get HRP_COREUM => _HRP_COREUM.value;

  set HRP_COREUM(ffi.Pointer<ffi.Char> value) => _HRP_COREUM.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_ZETACHAIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_ZETACHAIN');

  ffi.Pointer<ffi.Char> get HRP_ZETACHAIN => _HRP_ZETACHAIN.value;

  set HRP_ZETACHAIN(ffi.Pointer<ffi.Char> value) =>
      _HRP_ZETACHAIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NATIVECANTO =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NATIVECANTO');

  ffi.Pointer<ffi.Char> get HRP_NATIVECANTO => _HRP_NATIVECANTO.value;

  set HRP_NATIVECANTO(ffi.Pointer<ffi.Char> value) =>
      _HRP_NATIVECANTO.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_SOMMELIER =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_SOMMELIER');

  ffi.Pointer<ffi.Char> get HRP_SOMMELIER => _HRP_SOMMELIER.value;

  set HRP_SOMMELIER(ffi.Pointer<ffi.Char> value) =>
      _HRP_SOMMELIER.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_FETCHAI =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_FETCHAI');

  ffi.Pointer<ffi.Char> get HRP_FETCHAI => _HRP_FETCHAI.value;

  set HRP_FETCHAI(ffi.Pointer<ffi.Char> value) => _HRP_FETCHAI.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_MARS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_MARS');

  ffi.Pointer<ffi.Char> get HRP_MARS => _HRP_MARS.value;

  set HRP_MARS(ffi.Pointer<ffi.Char> value) => _HRP_MARS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_UMEE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_UMEE');

  ffi.Pointer<ffi.Char> get HRP_UMEE => _HRP_UMEE.value;

  set HRP_UMEE(ffi.Pointer<ffi.Char> value) => _HRP_UMEE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_QUASAR =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_QUASAR');

  ffi.Pointer<ffi.Char> get HRP_QUASAR => _HRP_QUASAR.value;

  set HRP_QUASAR(ffi.Pointer<ffi.Char> value) => _HRP_QUASAR.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_PERSISTENCE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_PERSISTENCE');

  ffi.Pointer<ffi.Char> get HRP_PERSISTENCE => _HRP_PERSISTENCE.value;

  set HRP_PERSISTENCE(ffi.Pointer<ffi.Char> value) =>
      _HRP_PERSISTENCE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_AKASH =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_AKASH');

  ffi.Pointer<ffi.Char> get HRP_AKASH => _HRP_AKASH.value;

  set HRP_AKASH(ffi.Pointer<ffi.Char> value) => _HRP_AKASH.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NOBLE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NOBLE');

  ffi.Pointer<ffi.Char> get HRP_NOBLE => _HRP_NOBLE.value;

  set HRP_NOBLE(ffi.Pointer<ffi.Char> value) => _HRP_NOBLE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_SEI =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_SEI');

  ffi.Pointer<ffi.Char> get HRP_SEI => _HRP_SEI.value;

  set HRP_SEI(ffi.Pointer<ffi.Char> value) => _HRP_SEI.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_STARGAZE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_STARGAZE');

  ffi.Pointer<ffi.Char> get HRP_STARGAZE => _HRP_STARGAZE.value;

  set HRP_STARGAZE(ffi.Pointer<ffi.Char> value) => _HRP_STARGAZE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NATIVEEVMOS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NATIVEEVMOS');

  ffi.Pointer<ffi.Char> get HRP_NATIVEEVMOS => _HRP_NATIVEEVMOS.value;

  set HRP_NATIVEEVMOS(ffi.Pointer<ffi.Char> value) =>
      _HRP_NATIVEEVMOS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_TIA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_TIA');

  ffi.Pointer<ffi.Char> get HRP_TIA => _HRP_TIA.value;

  set HRP_TIA(ffi.Pointer<ffi.Char> value) => _HRP_TIA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_DYDX =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_DYDX');

  ffi.Pointer<ffi.Char> get HRP_DYDX => _HRP_DYDX.value;

  set HRP_DYDX(ffi.Pointer<ffi.Char> value) => _HRP_DYDX.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_JUNO =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_JUNO');

  ffi.Pointer<ffi.Char> get HRP_JUNO => _HRP_JUNO.value;

  set HRP_JUNO(ffi.Pointer<ffi.Char> value) => _HRP_JUNO.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_TBINANCE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_TBINANCE');

  ffi.Pointer<ffi.Char> get HRP_TBINANCE => _HRP_TBINANCE.value;

  set HRP_TBINANCE(ffi.Pointer<ffi.Char> value) => _HRP_TBINANCE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_STRIDE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_STRIDE');

  ffi.Pointer<ffi.Char> get HRP_STRIDE => _HRP_STRIDE.value;

  set HRP_STRIDE(ffi.Pointer<ffi.Char> value) => _HRP_STRIDE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_AXELAR =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_AXELAR');

  ffi.Pointer<ffi.Char> get HRP_AXELAR => _HRP_AXELAR.value;

  set HRP_AXELAR(ffi.Pointer<ffi.Char> value) => _HRP_AXELAR.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_CRESCENT =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_CRESCENT');

  ffi.Pointer<ffi.Char> get HRP_CRESCENT => _HRP_CRESCENT.value;

  set HRP_CRESCENT(ffi.Pointer<ffi.Char> value) => _HRP_CRESCENT.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_KUJIRA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_KUJIRA');

  ffi.Pointer<ffi.Char> get HRP_KUJIRA => _HRP_KUJIRA.value;

  set HRP_KUJIRA(ffi.Pointer<ffi.Char> value) => _HRP_KUJIRA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_COMDEX =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_COMDEX');

  ffi.Pointer<ffi.Char> get HRP_COMDEX => _HRP_COMDEX.value;

  set HRP_COMDEX(ffi.Pointer<ffi.Char> value) => _HRP_COMDEX.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NEUTRON =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NEUTRON');

  ffi.Pointer<ffi.Char> get HRP_NEUTRON => _HRP_NEUTRON.value;

  set HRP_NEUTRON(ffi.Pointer<ffi.Char> value) => _HRP_NEUTRON.value = value;

  ffi.Pointer<ffi.Char> stringForHRP(
    TWHRP hrp,
  ) {
    return _stringForHRP(
      hrp.value,
    );
  }

  late final _stringForHRPPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'stringForHRP');
  late final _stringForHRP =
      _stringForHRPPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  TWHRP hrpForString(
    ffi.Pointer<ffi.Char> string,
  ) {
    return TWHRP.fromValue(_hrpForString(
      string,
    ));
  }

  late final _hrpForStringPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>)>>(
      'hrpForString');
  late final _hrpForString =
      _hrpForStringPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Creates a TWString from a null-terminated UTF8 byte array. It must be deleted at the end.
  ///
  /// \param bytes a null-terminated UTF8 byte array.
  ffi.Pointer<TWString1> TWStringCreateWithUTF8Bytes(
    ffi.Pointer<ffi.Char> bytes,
  ) {
    return _TWStringCreateWithUTF8Bytes(
      bytes,
    );
  }

  late final _TWStringCreateWithUTF8BytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<ffi.Char>)>>('TWStringCreateWithUTF8Bytes');
  late final _TWStringCreateWithUTF8Bytes = _TWStringCreateWithUTF8BytesPtr
      .asFunction<ffi.Pointer<TWString1> Function(ffi.Pointer<ffi.Char>)>();

  /// Creates a string from a raw byte array and size. It must be deleted at the end.
  ///
  /// \param bytes a raw byte array.
  /// \param size the size of the byte array.
  ffi.Pointer<TWString1> TWStringCreateWithRawBytes(
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _TWStringCreateWithRawBytes(
      bytes,
      size,
    );
  }

  late final _TWStringCreateWithRawBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('TWStringCreateWithRawBytes');
  late final _TWStringCreateWithRawBytes =
      _TWStringCreateWithRawBytesPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Creates a hexadecimal string from a block of data. It must be deleted at the end.
  ///
  /// \param data a block of data.
  ffi.Pointer<TWString1> TWStringCreateWithHexData(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWStringCreateWithHexData(
      data,
    );
  }

  late final _TWStringCreateWithHexDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>)>>('TWStringCreateWithHexData');
  late final _TWStringCreateWithHexData = _TWStringCreateWithHexDataPtr
      .asFunction<ffi.Pointer<TWString1> Function(ffi.Pointer<TWData1>)>();

  /// Returns the string size in bytes.
  ///
  /// \param string a TWString pointer.
  int TWStringSize(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWStringSize(
      string,
    );
  }

  late final _TWStringSizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWString1>)>>(
          'TWStringSize');
  late final _TWStringSize =
      _TWStringSizePtr.asFunction<int Function(ffi.Pointer<TWString1>)>();

  /// Returns the byte at the provided index.
  ///
  /// \param string a TWString pointer.
  /// \param index the index of the byte.
  int TWStringGet(
    ffi.Pointer<TWString1> string,
    int index,
  ) {
    return _TWStringGet(
      string,
      index,
    );
  }

  late final _TWStringGetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Char Function(ffi.Pointer<TWString1>, ffi.Size)>>('TWStringGet');
  late final _TWStringGet =
      _TWStringGetPtr.asFunction<int Function(ffi.Pointer<TWString1>, int)>();

  /// Returns the raw pointer to the string's UTF8 bytes (null-terminated).
  ///
  /// \param string a TWString pointer.
  ffi.Pointer<ffi.Char> TWStringUTF8Bytes(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWStringUTF8Bytes(
      string,
    );
  }

  late final _TWStringUTF8BytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<TWString1>)>>('TWStringUTF8Bytes');
  late final _TWStringUTF8Bytes = _TWStringUTF8BytesPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<TWString1>)>();

  /// Deletes a string created with a `TWStringCreate*` method and frees the memory.
  ///
  /// \param string a TWString pointer.
  void TWStringDelete(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWStringDelete(
      string,
    );
  }

  late final _TWStringDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWString1>)>>(
          'TWStringDelete');
  late final _TWStringDelete =
      _TWStringDeletePtr.asFunction<void Function(ffi.Pointer<TWString1>)>();

  /// Determines whether two string blocks are equal.
  ///
  /// \param lhs a TWString pointer.
  /// \param rhs another TWString pointer.
  bool TWStringEqual(
    ffi.Pointer<TWString1> lhs,
    ffi.Pointer<TWString1> rhs,
  ) {
    return _TWStringEqual(
      lhs,
      rhs,
    );
  }

  late final _TWStringEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWStringEqual');
  late final _TWStringEqual = _TWStringEqualPtr.asFunction<
      bool Function(ffi.Pointer<TWString1>, ffi.Pointer<TWString1>)>();

  /// Returns the blockchain for a coin type.
  ///
  /// \param coin A coin type
  /// \return blockchain associated to the given coin type
  TWBlockchain TWCoinTypeBlockchain(
    TWCoinType coin,
  ) {
    return TWBlockchain.fromValue(_TWCoinTypeBlockchain(
      coin.value,
    ));
  }

  late final _TWCoinTypeBlockchainPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypeBlockchain');
  late final _TWCoinTypeBlockchain =
      _TWCoinTypeBlockchainPtr.asFunction<int Function(int)>();

  /// Returns the purpose for a coin type.
  ///
  /// \param coin A coin type
  /// \return purpose associated to the given coin type
  TWPurpose TWCoinTypePurpose(
    TWCoinType coin,
  ) {
    return TWPurpose.fromValue(_TWCoinTypePurpose(
      coin.value,
    ));
  }

  late final _TWCoinTypePurposePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypePurpose');
  late final _TWCoinTypePurpose =
      _TWCoinTypePurposePtr.asFunction<int Function(int)>();

  /// Returns the curve that should be used for a coin type.
  ///
  /// \param coin A coin type
  /// \return curve that should be used for the given coin type
  TWCurve TWCoinTypeCurve(
    TWCoinType coin,
  ) {
    return TWCurve.fromValue(_TWCoinTypeCurve(
      coin.value,
    ));
  }

  late final _TWCoinTypeCurvePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypeCurve');
  late final _TWCoinTypeCurve =
      _TWCoinTypeCurvePtr.asFunction<int Function(int)>();

  /// Returns the xpub HD version that should be used for a coin type.
  ///
  /// \param coin A coin type
  /// \return xpub HD version that should be used for the given coin type
  TWHDVersion TWCoinTypeXpubVersion(
    TWCoinType coin,
  ) {
    return TWHDVersion.fromValue(_TWCoinTypeXpubVersion(
      coin.value,
    ));
  }

  late final _TWCoinTypeXpubVersionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypeXpubVersion');
  late final _TWCoinTypeXpubVersion =
      _TWCoinTypeXpubVersionPtr.asFunction<int Function(int)>();

  /// Returns the xprv HD version that should be used for a coin type.
  ///
  /// \param coin A coin type
  /// \return the xprv HD version that should be used for the given coin type.
  TWHDVersion TWCoinTypeXprvVersion(
    TWCoinType coin,
  ) {
    return TWHDVersion.fromValue(_TWCoinTypeXprvVersion(
      coin.value,
    ));
  }

  late final _TWCoinTypeXprvVersionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypeXprvVersion');
  late final _TWCoinTypeXprvVersion =
      _TWCoinTypeXprvVersionPtr.asFunction<int Function(int)>();

  /// Validates an address string.
  ///
  /// \param coin A coin type
  /// \param address A public address
  /// \return true if the address is a valid public address of the given coin, false otherwise.
  bool TWCoinTypeValidate(
    TWCoinType coin,
    ffi.Pointer<TWString1> address,
  ) {
    return _TWCoinTypeValidate(
      coin.value,
      address,
    );
  }

  late final _TWCoinTypeValidatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.UnsignedInt, ffi.Pointer<TWString1>)>>('TWCoinTypeValidate');
  late final _TWCoinTypeValidate = _TWCoinTypeValidatePtr.asFunction<
      bool Function(int, ffi.Pointer<TWString1>)>();

  /// Returns the default derivation path for a particular coin.
  ///
  /// \param coin A coin type
  /// \return the default derivation path for the given coin type.
  ffi.Pointer<TWString1> TWCoinTypeDerivationPath(
    TWCoinType coin,
  ) {
    return _TWCoinTypeDerivationPath(
      coin.value,
    );
  }

  late final _TWCoinTypeDerivationPathPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<TWString1> Function(ffi.UnsignedInt)>>(
      'TWCoinTypeDerivationPath');
  late final _TWCoinTypeDerivationPath = _TWCoinTypeDerivationPathPtr
      .asFunction<ffi.Pointer<TWString1> Function(int)>();

  /// Returns the derivation path for a particular coin with the explicit given derivation.
  ///
  /// \param coin A coin type
  /// \param derivation A derivation type
  /// \return the derivation path for the given coin with the explicit given derivation
  ffi.Pointer<TWString1> TWCoinTypeDerivationPathWithDerivation(
    TWCoinType coin,
    TWDerivation derivation,
  ) {
    return _TWCoinTypeDerivationPathWithDerivation(
      coin.value,
      derivation.value,
    );
  }

  late final _TWCoinTypeDerivationPathWithDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWCoinTypeDerivationPathWithDerivation');
  late final _TWCoinTypeDerivationPathWithDerivation =
      _TWCoinTypeDerivationPathWithDerivationPtr.asFunction<
          ffi.Pointer<TWString1> Function(int, int)>();

  /// Derives the address for a particular coin from the private key.
  ///
  /// \param coin A coin type
  /// \param privateKey A valid private key
  /// \return Derived address for the given coin from the private key.
  ffi.Pointer<TWString1> TWCoinTypeDeriveAddress(
    TWCoinType coin,
    ffi.Pointer<TWPrivateKey> privateKey,
  ) {
    return _TWCoinTypeDeriveAddress(
      coin.value,
      privateKey,
    );
  }

  late final _TWCoinTypeDeriveAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.UnsignedInt,
              ffi.Pointer<TWPrivateKey>)>>('TWCoinTypeDeriveAddress');
  late final _TWCoinTypeDeriveAddress = _TWCoinTypeDeriveAddressPtr.asFunction<
      ffi.Pointer<TWString1> Function(int, ffi.Pointer<TWPrivateKey>)>();

  /// Derives the address for a particular coin from the public key.
  ///
  /// \param coin A coin type
  /// \param publicKey A valid public key
  /// \return Derived address for the given coin from the public key.
  ffi.Pointer<TWString1> TWCoinTypeDeriveAddressFromPublicKey(
    TWCoinType coin,
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return _TWCoinTypeDeriveAddressFromPublicKey(
      coin.value,
      publicKey,
    );
  }

  late final _TWCoinTypeDeriveAddressFromPublicKeyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString1> Function(
                  ffi.UnsignedInt, ffi.Pointer<TWPublicKey>)>>(
      'TWCoinTypeDeriveAddressFromPublicKey');
  late final _TWCoinTypeDeriveAddressFromPublicKey =
      _TWCoinTypeDeriveAddressFromPublicKeyPtr.asFunction<
          ffi.Pointer<TWString1> Function(int, ffi.Pointer<TWPublicKey>)>();

  /// Derives the address for a particular coin from the public key with the derivation.
  ffi.Pointer<TWString1> TWCoinTypeDeriveAddressFromPublicKeyAndDerivation(
    TWCoinType coin,
    ffi.Pointer<TWPublicKey> publicKey,
    TWDerivation derivation,
  ) {
    return _TWCoinTypeDeriveAddressFromPublicKeyAndDerivation(
      coin.value,
      publicKey,
      derivation.value,
    );
  }

  late final _TWCoinTypeDeriveAddressFromPublicKeyAndDerivationPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString1> Function(
                  ffi.UnsignedInt, ffi.Pointer<TWPublicKey>, ffi.UnsignedInt)>>(
      'TWCoinTypeDeriveAddressFromPublicKeyAndDerivation');
  late final _TWCoinTypeDeriveAddressFromPublicKeyAndDerivation =
      _TWCoinTypeDeriveAddressFromPublicKeyAndDerivationPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              int, ffi.Pointer<TWPublicKey>, int)>();

  /// HRP for this coin type
  ///
  /// \param coin A coin type
  /// \return HRP of the given coin type.
  TWHRP TWCoinTypeHRP(
    TWCoinType coin,
  ) {
    return TWHRP.fromValue(_TWCoinTypeHRP(
      coin.value,
    ));
  }

  late final _TWCoinTypeHRPPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypeHRP');
  late final _TWCoinTypeHRP = _TWCoinTypeHRPPtr.asFunction<int Function(int)>();

  /// P2PKH prefix for this coin type
  ///
  /// \param coin A coin type
  /// \return P2PKH prefix for the given coin type
  int TWCoinTypeP2pkhPrefix(
    TWCoinType coin,
  ) {
    return _TWCoinTypeP2pkhPrefix(
      coin.value,
    );
  }

  late final _TWCoinTypeP2pkhPrefixPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.UnsignedInt)>>(
          'TWCoinTypeP2pkhPrefix');
  late final _TWCoinTypeP2pkhPrefix =
      _TWCoinTypeP2pkhPrefixPtr.asFunction<int Function(int)>();

  /// P2SH prefix for this coin type
  ///
  /// \param coin A coin type
  /// \return P2SH prefix for the given coin type
  int TWCoinTypeP2shPrefix(
    TWCoinType coin,
  ) {
    return _TWCoinTypeP2shPrefix(
      coin.value,
    );
  }

  late final _TWCoinTypeP2shPrefixPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.UnsignedInt)>>(
          'TWCoinTypeP2shPrefix');
  late final _TWCoinTypeP2shPrefix =
      _TWCoinTypeP2shPrefixPtr.asFunction<int Function(int)>();

  /// Static prefix for this coin type
  ///
  /// \param coin A coin type
  /// \return Static prefix for the given coin type
  int TWCoinTypeStaticPrefix(
    TWCoinType coin,
  ) {
    return _TWCoinTypeStaticPrefix(
      coin.value,
    );
  }

  late final _TWCoinTypeStaticPrefixPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.UnsignedInt)>>(
          'TWCoinTypeStaticPrefix');
  late final _TWCoinTypeStaticPrefix =
      _TWCoinTypeStaticPrefixPtr.asFunction<int Function(int)>();

  /// ChainID for this coin type.
  ///
  /// \param coin A coin type
  /// \return ChainID for the given coin type.
  /// \note Caller must free returned object.
  ffi.Pointer<TWString1> TWCoinTypeChainId(
    TWCoinType coin,
  ) {
    return _TWCoinTypeChainId(
      coin.value,
    );
  }

  late final _TWCoinTypeChainIdPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<TWString1> Function(ffi.UnsignedInt)>>(
      'TWCoinTypeChainId');
  late final _TWCoinTypeChainId =
      _TWCoinTypeChainIdPtr.asFunction<ffi.Pointer<TWString1> Function(int)>();

  /// SLIP-0044 id for this coin type
  ///
  /// \param coin A coin type
  /// \return SLIP-0044 id for the given coin type
  int TWCoinTypeSlip44Id(
    TWCoinType coin,
  ) {
    return _TWCoinTypeSlip44Id(
      coin.value,
    );
  }

  late final _TWCoinTypeSlip44IdPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.UnsignedInt)>>(
          'TWCoinTypeSlip44Id');
  late final _TWCoinTypeSlip44Id =
      _TWCoinTypeSlip44IdPtr.asFunction<int Function(int)>();

  /// SS58Prefix for this coin type
  ///
  /// \param coin A coin type
  /// \return SS58Prefix for the given coin type
  int TWCoinTypeSS58Prefix(
    TWCoinType coin,
  ) {
    return _TWCoinTypeSS58Prefix(
      coin.value,
    );
  }

  late final _TWCoinTypeSS58PrefixPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.UnsignedInt)>>(
          'TWCoinTypeSS58Prefix');
  late final _TWCoinTypeSS58Prefix =
      _TWCoinTypeSS58PrefixPtr.asFunction<int Function(int)>();

  /// public key type for this coin type
  ///
  /// \param coin A coin type
  /// \return public key type for the given coin type
  TWPublicKeyType TWCoinTypePublicKeyType(
    TWCoinType coin,
  ) {
    return TWPublicKeyType.fromValue(_TWCoinTypePublicKeyType(
      coin.value,
    ));
  }

  late final _TWCoinTypePublicKeyTypePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypePublicKeyType');
  late final _TWCoinTypePublicKeyType =
      _TWCoinTypePublicKeyTypePtr.asFunction<int Function(int)>();

  /// Returns stock symbol of coin
  ///
  /// \param type A coin type
  /// \return A non-null TWString stock symbol of coin
  /// \note Caller must free returned object
  ffi.Pointer<TWString1> TWCoinTypeConfigurationGetSymbol(
    TWCoinType type,
  ) {
    return _TWCoinTypeConfigurationGetSymbol(
      type.value,
    );
  }

  late final _TWCoinTypeConfigurationGetSymbolPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<TWString1> Function(ffi.UnsignedInt)>>(
      'TWCoinTypeConfigurationGetSymbol');
  late final _TWCoinTypeConfigurationGetSymbol =
      _TWCoinTypeConfigurationGetSymbolPtr.asFunction<
          ffi.Pointer<TWString1> Function(int)>();

  /// Returns max count decimal places for minimal coin unit
  ///
  /// \param type A coin type
  /// \return Returns max count decimal places for minimal coin unit
  int TWCoinTypeConfigurationGetDecimals(
    TWCoinType type,
  ) {
    return _TWCoinTypeConfigurationGetDecimals(
      type.value,
    );
  }

  late final _TWCoinTypeConfigurationGetDecimalsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'TWCoinTypeConfigurationGetDecimals');
  late final _TWCoinTypeConfigurationGetDecimals =
      _TWCoinTypeConfigurationGetDecimalsPtr.asFunction<int Function(int)>();

  /// Returns transaction url in blockchain explorer
  ///
  /// \param type A coin type
  /// \param transactionID A transaction identifier
  /// \return Returns a non-null TWString transaction url in blockchain explorer
  ffi.Pointer<TWString1> TWCoinTypeConfigurationGetTransactionURL(
    TWCoinType type,
    ffi.Pointer<TWString1> transactionID,
  ) {
    return _TWCoinTypeConfigurationGetTransactionURL(
      type.value,
      transactionID,
    );
  }

  late final _TWCoinTypeConfigurationGetTransactionURLPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString1> Function(
                  ffi.UnsignedInt, ffi.Pointer<TWString1>)>>(
      'TWCoinTypeConfigurationGetTransactionURL');
  late final _TWCoinTypeConfigurationGetTransactionURL =
      _TWCoinTypeConfigurationGetTransactionURLPtr.asFunction<
          ffi.Pointer<TWString1> Function(int, ffi.Pointer<TWString1>)>();

  /// Returns account url in blockchain explorer
  ///
  /// \param type A coin type
  /// \param accountID an Account identifier
  /// \return Returns a non-null TWString account url in blockchain explorer
  ffi.Pointer<TWString1> TWCoinTypeConfigurationGetAccountURL(
    TWCoinType type,
    ffi.Pointer<TWString1> accountID,
  ) {
    return _TWCoinTypeConfigurationGetAccountURL(
      type.value,
      accountID,
    );
  }

  late final _TWCoinTypeConfigurationGetAccountURLPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.UnsignedInt,
              ffi.Pointer<TWString1>)>>('TWCoinTypeConfigurationGetAccountURL');
  late final _TWCoinTypeConfigurationGetAccountURL =
      _TWCoinTypeConfigurationGetAccountURLPtr.asFunction<
          ffi.Pointer<TWString1> Function(int, ffi.Pointer<TWString1>)>();

  /// Returns full name of coin in lower case
  ///
  /// \param type A coin type
  /// \return Returns a non-null TWString, full name of coin in lower case
  ffi.Pointer<TWString1> TWCoinTypeConfigurationGetID(
    TWCoinType type,
  ) {
    return _TWCoinTypeConfigurationGetID(
      type.value,
    );
  }

  late final _TWCoinTypeConfigurationGetIDPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<TWString1> Function(ffi.UnsignedInt)>>(
      'TWCoinTypeConfigurationGetID');
  late final _TWCoinTypeConfigurationGetID = _TWCoinTypeConfigurationGetIDPtr
      .asFunction<ffi.Pointer<TWString1> Function(int)>();

  /// Returns full name of coin
  ///
  /// \param type A coin type
  /// \return Returns a non-null TWString, full name of coin
  ffi.Pointer<TWString1> TWCoinTypeConfigurationGetName(
    TWCoinType type,
  ) {
    return _TWCoinTypeConfigurationGetName(
      type.value,
    );
  }

  late final _TWCoinTypeConfigurationGetNamePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<TWString1> Function(ffi.UnsignedInt)>>(
      'TWCoinTypeConfigurationGetName');
  late final _TWCoinTypeConfigurationGetName =
      _TWCoinTypeConfigurationGetNamePtr.asFunction<
          ffi.Pointer<TWString1> Function(int)>();

  /// Creates a new DerivationPath with a purpose, coin, account, change and address.
  /// Must be deleted with TWDerivationPathDelete after use.
  ///
  /// \param purpose The purpose of the Path.
  /// \param coin The coin type of the Path.
  /// \param account The derivation of the Path.
  /// \param change The derivation path of the Path.
  /// \param address hex encoded public key.
  /// \return A new DerivationPath.
  ffi.Pointer<TWDerivationPath> TWDerivationPathCreate(
    TWPurpose purpose,
    int coin,
    int account,
    int change,
    int address,
  ) {
    return _TWDerivationPathCreate(
      purpose.value,
      coin,
      account,
      change,
      address,
    );
  }

  late final _TWDerivationPathCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDerivationPath> Function(ffi.UnsignedInt, ffi.Uint32,
              ffi.Uint32, ffi.Uint32, ffi.Uint32)>>('TWDerivationPathCreate');
  late final _TWDerivationPathCreate = _TWDerivationPathCreatePtr.asFunction<
      ffi.Pointer<TWDerivationPath> Function(int, int, int, int, int)>();

  /// Creates a new DerivationPath with a string
  ///
  /// \param string The string of the Path.
  /// \return A new DerivationPath or null if string is invalid.
  ffi.Pointer<TWDerivationPath> TWDerivationPathCreateWithString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWDerivationPathCreateWithString(
      string,
    );
  }

  late final _TWDerivationPathCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDerivationPath> Function(
              ffi.Pointer<TWString1>)>>('TWDerivationPathCreateWithString');
  late final _TWDerivationPathCreateWithString =
      _TWDerivationPathCreateWithStringPtr.asFunction<
          ffi.Pointer<TWDerivationPath> Function(ffi.Pointer<TWString1>)>();

  /// Deletes a DerivationPath.
  ///
  /// \param path DerivationPath to delete.
  void TWDerivationPathDelete(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathDelete(
      path,
    );
  }

  late final _TWDerivationPathDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathDelete');
  late final _TWDerivationPathDelete = _TWDerivationPathDeletePtr.asFunction<
      void Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the index component of a DerivationPath.
  ///
  /// \param path DerivationPath to get the index of.
  /// \param index The index component of the DerivationPath.
  /// \return DerivationPathIndex or null if index is invalid.
  ffi.Pointer<TWDerivationPathIndex> TWDerivationPathIndexAt(
    ffi.Pointer<TWDerivationPath> path,
    int index,
  ) {
    return _TWDerivationPathIndexAt(
      path,
      index,
    );
  }

  late final _TWDerivationPathIndexAtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDerivationPathIndex> Function(
              ffi.Pointer<TWDerivationPath>,
              ffi.Uint32)>>('TWDerivationPathIndexAt');
  late final _TWDerivationPathIndexAt = _TWDerivationPathIndexAtPtr.asFunction<
      ffi.Pointer<TWDerivationPathIndex> Function(
          ffi.Pointer<TWDerivationPath>, int)>();

  /// Returns the indices count of a DerivationPath.
  ///
  /// \param path DerivationPath to get the indices count of.
  /// \return The indices count of the DerivationPath.
  int TWDerivationPathIndicesCount(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathIndicesCount(
      path,
    );
  }

  late final _TWDerivationPathIndicesCountPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathIndicesCount');
  late final _TWDerivationPathIndicesCount = _TWDerivationPathIndicesCountPtr
      .asFunction<int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the purpose enum of a DerivationPath.
  ///
  /// \param path DerivationPath to get the purpose of.
  /// \return DerivationPathPurpose.
  TWPurpose TWDerivationPathPurpose(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return TWPurpose.fromValue(_TWDerivationPathPurpose(
      path,
    ));
  }

  late final _TWDerivationPathPurposePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<TWDerivationPath>)>>('TWDerivationPathPurpose');
  late final _TWDerivationPathPurpose = _TWDerivationPathPurposePtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the coin value of a derivation path.
  ///
  /// \param path DerivationPath to get the coin of.
  /// \return The coin part of the DerivationPath.
  int TWDerivationPathCoin(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathCoin(
      path,
    );
  }

  late final _TWDerivationPathCoinPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathCoin');
  late final _TWDerivationPathCoin = _TWDerivationPathCoinPtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the account value of a derivation path.
  ///
  /// \param path DerivationPath to get the account of.
  /// \return the account part of a derivation path.
  int TWDerivationPathAccount(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathAccount(
      path,
    );
  }

  late final _TWDerivationPathAccountPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathAccount');
  late final _TWDerivationPathAccount = _TWDerivationPathAccountPtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the change value of a derivation path.
  ///
  /// \param path DerivationPath to get the change of.
  /// \return The change part of a derivation path.
  int TWDerivationPathChange(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathChange(
      path,
    );
  }

  late final _TWDerivationPathChangePtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathChange');
  late final _TWDerivationPathChange = _TWDerivationPathChangePtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the address value of a derivation path.
  ///
  /// \param path DerivationPath to get the address of.
  /// \return The address part of the derivation path.
  int TWDerivationPathAddress(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathAddress(
      path,
    );
  }

  late final _TWDerivationPathAddressPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathAddress');
  late final _TWDerivationPathAddress = _TWDerivationPathAddressPtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the string description of a derivation path.
  ///
  /// \param path DerivationPath to get the address of.
  /// \return The string description of the derivation path.
  ffi.Pointer<TWString1> TWDerivationPathDescription(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathDescription(
      path,
    );
  }

  late final _TWDerivationPathDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWDerivationPath>)>>('TWDerivationPathDescription');
  late final _TWDerivationPathDescription =
      _TWDerivationPathDescriptionPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWDerivationPath>)>();

  late final ffi.Pointer<ffi.Size> _TWPublicKeyCompressedSize =
      _lookup<ffi.Size>('TWPublicKeyCompressedSize');

  int get TWPublicKeyCompressedSize => _TWPublicKeyCompressedSize.value;

  late final ffi.Pointer<ffi.Size> _TWPublicKeyUncompressedSize =
      _lookup<ffi.Size>('TWPublicKeyUncompressedSize');

  int get TWPublicKeyUncompressedSize => _TWPublicKeyUncompressedSize.value;

  /// Create a public key from a block of data
  ///
  /// \param data Non-null block of data representing the public key
  /// \param type type of the public key
  /// \note Should be deleted with \TWPublicKeyDelete
  /// \return Nullable pointer to the public key
  ffi.Pointer<TWPublicKey> TWPublicKeyCreateWithData(
    ffi.Pointer<TWData1> data,
    TWPublicKeyType type,
  ) {
    return _TWPublicKeyCreateWithData(
      data,
      type.value,
    );
  }

  late final _TWPublicKeyCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWData1>,
              ffi.UnsignedInt)>>('TWPublicKeyCreateWithData');
  late final _TWPublicKeyCreateWithData =
      _TWPublicKeyCreateWithDataPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWData1>, int)>();

  /// Delete the given public key
  ///
  /// \param pk Non-null pointer to a public key
  void TWPublicKeyDelete(
    ffi.Pointer<TWPublicKey> pk,
  ) {
    return _TWPublicKeyDelete(
      pk,
    );
  }

  late final _TWPublicKeyDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWPublicKey>)>>(
          'TWPublicKeyDelete');
  late final _TWPublicKeyDelete = _TWPublicKeyDeletePtr.asFunction<
      void Function(ffi.Pointer<TWPublicKey>)>();

  /// Determines if the given public key is valid or not
  ///
  /// \param data Non-null block of data representing the public key
  /// \param type type of the public key
  /// \return true if the block of data is a valid public key, false otherwise
  bool TWPublicKeyIsValid(
    ffi.Pointer<TWData1> data,
    TWPublicKeyType type,
  ) {
    return _TWPublicKeyIsValid(
      data,
      type.value,
    );
  }

  late final _TWPublicKeyIsValidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<TWData1>, ffi.UnsignedInt)>>('TWPublicKeyIsValid');
  late final _TWPublicKeyIsValid = _TWPublicKeyIsValidPtr.asFunction<
      bool Function(ffi.Pointer<TWData1>, int)>();

  /// Determines if the given public key is compressed or not
  ///
  /// \param pk Non-null pointer to a public key
  /// \return true if the public key is compressed, false otherwise
  bool TWPublicKeyIsCompressed(
    ffi.Pointer<TWPublicKey> pk,
  ) {
    return _TWPublicKeyIsCompressed(
      pk,
    );
  }

  late final _TWPublicKeyIsCompressedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWPublicKey>)>>(
          'TWPublicKeyIsCompressed');
  late final _TWPublicKeyIsCompressed = _TWPublicKeyIsCompressedPtr.asFunction<
      bool Function(ffi.Pointer<TWPublicKey>)>();

  /// Give the compressed public key of the given non-compressed public key
  ///
  /// \param from Non-null pointer to a non-compressed public key
  /// \return Non-null pointer to the corresponding compressed public-key
  ffi.Pointer<TWPublicKey> TWPublicKeyCompressed(
    ffi.Pointer<TWPublicKey> from,
  ) {
    return _TWPublicKeyCompressed(
      from,
    );
  }

  late final _TWPublicKeyCompressedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWPublicKey>)>>('TWPublicKeyCompressed');
  late final _TWPublicKeyCompressed = _TWPublicKeyCompressedPtr.asFunction<
      ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPublicKey>)>();

  /// Give the non-compressed public key of a corresponding compressed public key
  ///
  /// \param from Non-null pointer to the corresponding compressed public key
  /// \return Non-null pointer to the corresponding non-compressed public key
  ffi.Pointer<TWPublicKey> TWPublicKeyUncompressed(
    ffi.Pointer<TWPublicKey> from,
  ) {
    return _TWPublicKeyUncompressed(
      from,
    );
  }

  late final _TWPublicKeyUncompressedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWPublicKey>)>>('TWPublicKeyUncompressed');
  late final _TWPublicKeyUncompressed = _TWPublicKeyUncompressedPtr.asFunction<
      ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPublicKey>)>();

  /// Gives the raw data of a given public-key
  ///
  /// \param pk Non-null pointer to a public key
  /// \return Non-null pointer to the raw block of data of the given public key
  ffi.Pointer<TWData1> TWPublicKeyData(
    ffi.Pointer<TWPublicKey> pk,
  ) {
    return _TWPublicKeyData(
      pk,
    );
  }

  late final _TWPublicKeyDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWPublicKey>)>>('TWPublicKeyData');
  late final _TWPublicKeyData = _TWPublicKeyDataPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWPublicKey>)>();

  /// Verify the validity of a signature and a message using the given public key
  ///
  /// \param pk Non-null pointer to a public key
  /// \param signature Non-null pointer to a block of data corresponding to the signature
  /// \param message Non-null pointer to a block of data corresponding to the message
  /// \return true if the signature and the message belongs to the given public key, false otherwise
  bool TWPublicKeyVerify(
    ffi.Pointer<TWPublicKey> pk,
    ffi.Pointer<TWData1> signature,
    ffi.Pointer<TWData1> message,
  ) {
    return _TWPublicKeyVerify(
      pk,
      signature,
      message,
    );
  }

  late final _TWPublicKeyVerifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>)>>('TWPublicKeyVerify');
  late final _TWPublicKeyVerify = _TWPublicKeyVerifyPtr.asFunction<
      bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>,
          ffi.Pointer<TWData1>)>();

  /// Verify the validity as DER of a signature and a message using the given public key
  ///
  /// \param pk Non-null pointer to a public key
  /// \param signature Non-null pointer to a block of data corresponding to the signature
  /// \param message Non-null pointer to a block of data corresponding to the message
  /// \return true if the signature and the message belongs to the given public key, false otherwise
  bool TWPublicKeyVerifyAsDER(
    ffi.Pointer<TWPublicKey> pk,
    ffi.Pointer<TWData1> signature,
    ffi.Pointer<TWData1> message,
  ) {
    return _TWPublicKeyVerifyAsDER(
      pk,
      signature,
      message,
    );
  }

  late final _TWPublicKeyVerifyAsDERPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>)>>('TWPublicKeyVerifyAsDER');
  late final _TWPublicKeyVerifyAsDER = _TWPublicKeyVerifyAsDERPtr.asFunction<
      bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>,
          ffi.Pointer<TWData1>)>();

  /// Verify a Zilliqa schnorr signature with a signature and message.
  ///
  /// \param pk Non-null pointer to a public key
  /// \param signature Non-null pointer to a block of data corresponding to the signature
  /// \param message Non-null pointer to a block of data corresponding to the message
  /// \return true if the signature and the message belongs to the given public key, false otherwise
  bool TWPublicKeyVerifyZilliqaSchnorr(
    ffi.Pointer<TWPublicKey> pk,
    ffi.Pointer<TWData1> signature,
    ffi.Pointer<TWData1> message,
  ) {
    return _TWPublicKeyVerifyZilliqaSchnorr(
      pk,
      signature,
      message,
    );
  }

  late final _TWPublicKeyVerifyZilliqaSchnorrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>)>>('TWPublicKeyVerifyZilliqaSchnorr');
  late final _TWPublicKeyVerifyZilliqaSchnorr =
      _TWPublicKeyVerifyZilliqaSchnorrPtr.asFunction<
          bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>)>();

  /// Give the public key type (eliptic) of a given public key
  ///
  /// \param publicKey Non-null pointer to a public key
  /// \return The public key type of the given public key (eliptic)
  TWPublicKeyType TWPublicKeyKeyType(
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return TWPublicKeyType.fromValue(_TWPublicKeyKeyType(
      publicKey,
    ));
  }

  late final _TWPublicKeyKeyTypePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<TWPublicKey>)>>(
      'TWPublicKeyKeyType');
  late final _TWPublicKeyKeyType = _TWPublicKeyKeyTypePtr.asFunction<
      int Function(ffi.Pointer<TWPublicKey>)>();

  /// Get the public key description from a given public key
  ///
  /// \param publicKey Non-null pointer to a public key
  /// \return Non-null pointer to a string representing the description of the public key
  ffi.Pointer<TWString1> TWPublicKeyDescription(
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return _TWPublicKeyDescription(
      publicKey,
    );
  }

  late final _TWPublicKeyDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPublicKey>)>>('TWPublicKeyDescription');
  late final _TWPublicKeyDescription = _TWPublicKeyDescriptionPtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWPublicKey>)>();

  /// Try to get a public key from a given signature and a message
  ///
  /// \param signature Non-null pointer to a block of data corresponding to the signature
  /// \param message Non-null pointer to a block of data corresponding to the message
  /// \return Null pointer if the public key can't be recover from the given signature and message,
  /// pointer to the public key otherwise
  ffi.Pointer<TWPublicKey> TWPublicKeyRecover(
    ffi.Pointer<TWData1> signature,
    ffi.Pointer<TWData1> message,
  ) {
    return _TWPublicKeyRecover(
      signature,
      message,
    );
  }

  late final _TWPublicKeyRecoverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>)>>('TWPublicKeyRecover');
  late final _TWPublicKeyRecover = _TWPublicKeyRecoverPtr.asFunction<
      ffi.Pointer<TWPublicKey> Function(
          ffi.Pointer<TWData1>, ffi.Pointer<TWData1>)>();

  late final ffi.Pointer<ffi.Size> _TWPrivateKeySize =
      _lookup<ffi.Size>('TWPrivateKeySize');

  int get TWPrivateKeySize => _TWPrivateKeySize.value;

  /// Create a random private key
  ///
  /// \note Should be deleted with \TWPrivateKeyDelete
  /// \return Non-null Private key
  ffi.Pointer<TWPrivateKey> TWPrivateKeyCreate() {
    return _TWPrivateKeyCreate();
  }

  late final _TWPrivateKeyCreatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWPrivateKey> Function()>>(
          'TWPrivateKeyCreate');
  late final _TWPrivateKeyCreate =
      _TWPrivateKeyCreatePtr.asFunction<ffi.Pointer<TWPrivateKey> Function()>();

  /// Create a private key with the given block of data
  ///
  /// \param data a block of data
  /// \note Should be deleted with \TWPrivateKeyDelete
  /// \return Nullable pointer to Private Key
  ffi.Pointer<TWPrivateKey> TWPrivateKeyCreateWithData(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWPrivateKeyCreateWithData(
      data,
    );
  }

  late final _TWPrivateKeyCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWData1>)>>('TWPrivateKeyCreateWithData');
  late final _TWPrivateKeyCreateWithData = _TWPrivateKeyCreateWithDataPtr
      .asFunction<ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWData1>)>();

  /// Deep copy a given private key
  ///
  /// \param key Non-null private key to be copied
  /// \note Should be deleted with \TWPrivateKeyDelete
  /// \return Deep copy, Nullable pointer to Private key
  ffi.Pointer<TWPrivateKey> TWPrivateKeyCreateCopy(
    ffi.Pointer<TWPrivateKey> key,
  ) {
    return _TWPrivateKeyCreateCopy(
      key,
    );
  }

  late final _TWPrivateKeyCreateCopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWPrivateKey>)>>('TWPrivateKeyCreateCopy');
  late final _TWPrivateKeyCreateCopy = _TWPrivateKeyCreateCopyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Delete the given private key
  ///
  /// \param pk Non-null pointer to private key
  void TWPrivateKeyDelete(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyDelete(
      pk,
    );
  }

  late final _TWPrivateKeyDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWPrivateKey>)>>(
          'TWPrivateKeyDelete');
  late final _TWPrivateKeyDelete = _TWPrivateKeyDeletePtr.asFunction<
      void Function(ffi.Pointer<TWPrivateKey>)>();

  /// Determines if the given private key is valid or not.
  ///
  /// \param data block of data (private key bytes)
  /// \param curve Eliptic curve of the private key
  /// \return true if the private key is valid, false otherwise
  bool TWPrivateKeyIsValid(
    ffi.Pointer<TWData1> data,
    TWCurve curve,
  ) {
    return _TWPrivateKeyIsValid(
      data,
      curve.value,
    );
  }

  late final _TWPrivateKeyIsValidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<TWData1>, ffi.UnsignedInt)>>('TWPrivateKeyIsValid');
  late final _TWPrivateKeyIsValid = _TWPrivateKeyIsValidPtr.asFunction<
      bool Function(ffi.Pointer<TWData1>, int)>();

  /// Convert the given private key to raw-bytes block of data
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null block of data (raw bytes) of the given private key
  ffi.Pointer<TWData1> TWPrivateKeyData(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyData(
      pk,
    );
  }

  late final _TWPrivateKeyDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWPrivateKey>)>>('TWPrivateKeyData');
  late final _TWPrivateKeyData = _TWPrivateKeyDataPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the public key associated with the given coinType and privateKey
  ///
  /// \param pk Non-null pointer to the private key
  /// \param coinType coinType of the given private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKey(
    ffi.Pointer<TWPrivateKey> pk,
    TWCoinType coinType,
  ) {
    return _TWPrivateKeyGetPublicKey(
      pk,
      coinType.value,
    );
  }

  late final _TWPrivateKeyGetPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>,
              ffi.UnsignedInt)>>('TWPrivateKeyGetPublicKey');
  late final _TWPrivateKeyGetPublicKey =
      _TWPrivateKeyGetPublicKeyPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>, int)>();

  /// Returns the public key associated with the given pubkeyType and privateKey
  ///
  /// \param pk Non-null pointer to the private key
  /// \param pubkeyType pubkeyType of the given private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyByType(
    ffi.Pointer<TWPrivateKey> pk,
    TWPublicKeyType pubkeyType,
  ) {
    return _TWPrivateKeyGetPublicKeyByType(
      pk,
      pubkeyType.value,
    );
  }

  late final _TWPrivateKeyGetPublicKeyByTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>,
              ffi.UnsignedInt)>>('TWPrivateKeyGetPublicKeyByType');
  late final _TWPrivateKeyGetPublicKeyByType =
      _TWPrivateKeyGetPublicKeyByTypePtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>, int)>();

  /// Returns the Secp256k1 public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \param compressed if the given private key is compressed or not
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeySecp256k1(
    ffi.Pointer<TWPrivateKey> pk,
    bool compressed,
  ) {
    return _TWPrivateKeyGetPublicKeySecp256k1(
      pk,
      compressed,
    );
  }

  late final _TWPrivateKeyGetPublicKeySecp256k1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Bool)>>('TWPrivateKeyGetPublicKeySecp256k1');
  late final _TWPrivateKeyGetPublicKeySecp256k1 =
      _TWPrivateKeyGetPublicKeySecp256k1Ptr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>, bool)>();

  /// Returns the Nist256p1 public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyNist256p1(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyNist256p1(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyNist256p1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWPrivateKey>)>>('TWPrivateKeyGetPublicKeyNist256p1');
  late final _TWPrivateKeyGetPublicKeyNist256p1 =
      _TWPrivateKeyGetPublicKeyNist256p1Ptr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the Ed25519 public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyEd25519(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyEd25519(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyEd25519Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWPrivateKey>)>>('TWPrivateKeyGetPublicKeyEd25519');
  late final _TWPrivateKeyGetPublicKeyEd25519 =
      _TWPrivateKeyGetPublicKeyEd25519Ptr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the Ed25519Blake2b public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyEd25519Blake2b(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyEd25519Blake2b(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyEd25519Blake2bPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>>(
      'TWPrivateKeyGetPublicKeyEd25519Blake2b');
  late final _TWPrivateKeyGetPublicKeyEd25519Blake2b =
      _TWPrivateKeyGetPublicKeyEd25519Blake2bPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the Ed25519Cardano public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyEd25519Cardano(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyEd25519Cardano(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyEd25519CardanoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>>(
      'TWPrivateKeyGetPublicKeyEd25519Cardano');
  late final _TWPrivateKeyGetPublicKeyEd25519Cardano =
      _TWPrivateKeyGetPublicKeyEd25519CardanoPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the Curve25519 public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyCurve25519(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyCurve25519(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyCurve25519Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>>(
      'TWPrivateKeyGetPublicKeyCurve25519');
  late final _TWPrivateKeyGetPublicKeyCurve25519 =
      _TWPrivateKeyGetPublicKeyCurve25519Ptr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Signs a digest using ECDSA and given curve.
  ///
  /// \param pk  Non-null pointer to a Private key
  /// \param digest Non-null digest block of data
  /// \param curve Eliptic curve
  /// \return Signature as a Non-null block of data
  ffi.Pointer<TWData1> TWPrivateKeySign(
    ffi.Pointer<TWPrivateKey> pk,
    ffi.Pointer<TWData1> digest,
    TWCurve curve,
  ) {
    return _TWPrivateKeySign(
      pk,
      digest,
      curve.value,
    );
  }

  late final _TWPrivateKeySignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWData1>, ffi.UnsignedInt)>>('TWPrivateKeySign');
  late final _TWPrivateKeySign = _TWPrivateKeySignPtr.asFunction<
      ffi.Pointer<TWData1> Function(
          ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWData1>, int)>();

  /// Signs a digest using ECDSA. The result is encoded with DER.
  ///
  /// \param pk  Non-null pointer to a Private key
  /// \param digest Non-null digest block of data
  /// \return Signature as a Non-null block of data
  ffi.Pointer<TWData1> TWPrivateKeySignAsDER(
    ffi.Pointer<TWPrivateKey> pk,
    ffi.Pointer<TWData1> digest,
  ) {
    return _TWPrivateKeySignAsDER(
      pk,
      digest,
    );
  }

  late final _TWPrivateKeySignAsDERPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWData1>)>>('TWPrivateKeySignAsDER');
  late final _TWPrivateKeySignAsDER = _TWPrivateKeySignAsDERPtr.asFunction<
      ffi.Pointer<TWData1> Function(
          ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWData1>)>();

  /// Signs a digest using ECDSA and Zilliqa schnorr signature scheme.
  ///
  /// \param pk Non-null pointer to a Private key
  /// \param message Non-null message
  /// \return Signature as a Non-null block of data
  ffi.Pointer<TWData1> TWPrivateKeySignZilliqaSchnorr(
    ffi.Pointer<TWPrivateKey> pk,
    ffi.Pointer<TWData1> message,
  ) {
    return _TWPrivateKeySignZilliqaSchnorr(
      pk,
      message,
    );
  }

  late final _TWPrivateKeySignZilliqaSchnorrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWData1>)>>('TWPrivateKeySignZilliqaSchnorr');
  late final _TWPrivateKeySignZilliqaSchnorr =
      _TWPrivateKeySignZilliqaSchnorrPtr.asFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWData1>)>();

  /// Creates a new HDWallet with a new random mnemonic with the provided strength in bits.
  ///
  /// \param strength strength in bits
  /// \param passphrase non-null passphrase
  /// \note Null is returned on invalid strength
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Nullable TWHDWallet
  ffi.Pointer<TWHDWallet> TWHDWalletCreate(
    int strength,
    ffi.Pointer<TWString1> passphrase,
  ) {
    return _TWHDWalletCreate(
      strength,
      passphrase,
    );
  }

  late final _TWHDWalletCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Int, ffi.Pointer<TWString1>)>>('TWHDWalletCreate');
  late final _TWHDWalletCreate = _TWHDWalletCreatePtr.asFunction<
      ffi.Pointer<TWHDWallet> Function(int, ffi.Pointer<TWString1>)>();

  /// Creates an HDWallet from a valid BIP39 English mnemonic and a passphrase.
  ///
  /// \param mnemonic non-null Valid BIP39 mnemonic
  /// \param passphrase  non-null passphrase
  /// \note Null is returned on invalid mnemonic
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Nullable TWHDWallet
  ffi.Pointer<TWHDWallet> TWHDWalletCreateWithMnemonic(
    ffi.Pointer<TWString1> mnemonic,
    ffi.Pointer<TWString1> passphrase,
  ) {
    return _TWHDWalletCreateWithMnemonic(
      mnemonic,
      passphrase,
    );
  }

  late final _TWHDWalletCreateWithMnemonicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWHDWalletCreateWithMnemonic');
  late final _TWHDWalletCreateWithMnemonic =
      _TWHDWalletCreateWithMnemonicPtr.asFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Pointer<TWString1>, ffi.Pointer<TWString1>)>();

  /// Creates an HDWallet from a BIP39 mnemonic, a passphrase and validation flag.
  ///
  /// \param mnemonic non-null Valid BIP39 mnemonic
  /// \param passphrase  non-null passphrase
  /// \param check validation flag
  /// \note Null is returned on invalid mnemonic
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Nullable TWHDWallet
  ffi.Pointer<TWHDWallet> TWHDWalletCreateWithMnemonicCheck(
    ffi.Pointer<TWString1> mnemonic,
    ffi.Pointer<TWString1> passphrase,
    bool check,
  ) {
    return _TWHDWalletCreateWithMnemonicCheck(
      mnemonic,
      passphrase,
      check,
    );
  }

  late final _TWHDWalletCreateWithMnemonicCheckPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Bool)>>('TWHDWalletCreateWithMnemonicCheck');
  late final _TWHDWalletCreateWithMnemonicCheck =
      _TWHDWalletCreateWithMnemonicCheckPtr.asFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Pointer<TWString1>, ffi.Pointer<TWString1>, bool)>();

  /// Creates an HDWallet from entropy (corresponding to a mnemonic).
  ///
  /// \param entropy Non-null entropy data (corresponding to a mnemonic)
  /// \param passphrase non-null passphrase
  /// \note Null is returned on invalid input
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Nullable TWHDWallet
  ffi.Pointer<TWHDWallet> TWHDWalletCreateWithEntropy(
    ffi.Pointer<TWData1> entropy,
    ffi.Pointer<TWString1> passphrase,
  ) {
    return _TWHDWalletCreateWithEntropy(
      entropy,
      passphrase,
    );
  }

  late final _TWHDWalletCreateWithEntropyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>)>>('TWHDWalletCreateWithEntropy');
  late final _TWHDWalletCreateWithEntropy =
      _TWHDWalletCreateWithEntropyPtr.asFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Pointer<TWData1>, ffi.Pointer<TWString1>)>();

  /// Deletes a wallet.
  ///
  /// \param wallet non-null TWHDWallet
  void TWHDWalletDelete(
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWHDWalletDelete(
      wallet,
    );
  }

  late final _TWHDWalletDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWHDWallet>)>>(
          'TWHDWalletDelete');
  late final _TWHDWalletDelete =
      _TWHDWalletDeletePtr.asFunction<void Function(ffi.Pointer<TWHDWallet>)>();

  /// Wallet seed.
  ///
  /// \param wallet non-null TWHDWallet
  /// \return The wallet seed as a Non-null block of data.
  ffi.Pointer<TWData1> TWHDWalletSeed(
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWHDWalletSeed(
      wallet,
    );
  }

  late final _TWHDWalletSeedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWHDWallet>)>>('TWHDWalletSeed');
  late final _TWHDWalletSeed = _TWHDWalletSeedPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWHDWallet>)>();

  /// Wallet Mnemonic
  ///
  /// \param wallet non-null TWHDWallet
  /// \return The wallet mnemonic as a non-null TWString
  ffi.Pointer<TWString1> TWHDWalletMnemonic(
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWHDWalletMnemonic(
      wallet,
    );
  }

  late final _TWHDWalletMnemonicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>)>>('TWHDWalletMnemonic');
  late final _TWHDWalletMnemonic = _TWHDWalletMnemonicPtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWHDWallet>)>();

  /// Wallet entropy
  ///
  /// \param wallet non-null TWHDWallet
  /// \return The wallet entropy as a non-null block of data.
  ffi.Pointer<TWData1> TWHDWalletEntropy(
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWHDWalletEntropy(
      wallet,
    );
  }

  late final _TWHDWalletEntropyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWHDWallet>)>>('TWHDWalletEntropy');
  late final _TWHDWalletEntropy = _TWHDWalletEntropyPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWHDWallet>)>();

  /// Returns master key.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param curve  a curve
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return Non-null corresponding private key
  ffi.Pointer<TWPrivateKey> TWHDWalletGetMasterKey(
    ffi.Pointer<TWHDWallet> wallet,
    TWCurve curve,
  ) {
    return _TWHDWalletGetMasterKey(
      wallet,
      curve.value,
    );
  }

  late final _TWHDWalletGetMasterKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt)>>('TWHDWalletGetMasterKey');
  late final _TWHDWalletGetMasterKey = _TWHDWalletGetMasterKeyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>, int)>();

  /// Generates the default private key for the specified coin, using default derivation.
  ///
  /// \see TWHDWalletGetKey
  /// \see TWHDWalletGetKeyDerivation
  /// \param wallet non-null TWHDWallet
  /// \param coin  a coin type
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return return the default private key for the specified coin
  ffi.Pointer<TWPrivateKey> TWHDWalletGetKeyForCoin(
    ffi.Pointer<TWHDWallet> wallet,
    TWCoinType coin,
  ) {
    return _TWHDWalletGetKeyForCoin(
      wallet,
      coin.value,
    );
  }

  late final _TWHDWalletGetKeyForCoinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt)>>('TWHDWalletGetKeyForCoin');
  late final _TWHDWalletGetKeyForCoin = _TWHDWalletGetKeyForCoinPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>, int)>();

  /// Generates the default address for the specified coin (without exposing intermediary private key), default derivation.
  ///
  /// \see TWHDWalletGetAddressDerivation
  /// \param wallet non-null TWHDWallet
  /// \param coin  a coin type
  /// \return return the default address for the specified coin as a non-null TWString
  ffi.Pointer<TWString1> TWHDWalletGetAddressForCoin(
    ffi.Pointer<TWHDWallet> wallet,
    TWCoinType coin,
  ) {
    return _TWHDWalletGetAddressForCoin(
      wallet,
      coin.value,
    );
  }

  late final _TWHDWalletGetAddressForCoinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt)>>('TWHDWalletGetAddressForCoin');
  late final _TWHDWalletGetAddressForCoin =
      _TWHDWalletGetAddressForCoinPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWHDWallet>, int)>();

  /// Generates the default address for the specified coin and derivation (without exposing intermediary private key).
  ///
  /// \see TWHDWalletGetAddressForCoin
  /// \param wallet non-null TWHDWallet
  /// \param coin  a coin type
  /// \param derivation  a (custom) derivation to use
  /// \return return the default address for the specified coin as a non-null TWString
  ffi.Pointer<TWString1> TWHDWalletGetAddressDerivation(
    ffi.Pointer<TWHDWallet> wallet,
    TWCoinType coin,
    TWDerivation derivation,
  ) {
    return _TWHDWalletGetAddressDerivation(
      wallet,
      coin.value,
      derivation.value,
    );
  }

  late final _TWHDWalletGetAddressDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWHDWalletGetAddressDerivation');
  late final _TWHDWalletGetAddressDerivation =
      _TWHDWalletGetAddressDerivationPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWHDWallet>, int, int)>();

  /// Generates the private key for the specified derivation path.
  ///
  /// \see TWHDWalletGetKeyForCoin
  /// \see TWHDWalletGetKeyDerivation
  /// \param wallet non-null TWHDWallet
  /// \param coin a coin type
  /// \param derivationPath  a non-null derivation path
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return The private key for the specified derivation path/coin
  ffi.Pointer<TWPrivateKey> TWHDWalletGetKey(
    ffi.Pointer<TWHDWallet> wallet,
    TWCoinType coin,
    ffi.Pointer<TWString1> derivationPath,
  ) {
    return _TWHDWalletGetKey(
      wallet,
      coin.value,
      derivationPath,
    );
  }

  late final _TWHDWalletGetKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt, ffi.Pointer<TWString1>)>>('TWHDWalletGetKey');
  late final _TWHDWalletGetKey = _TWHDWalletGetKeyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(
          ffi.Pointer<TWHDWallet>, int, ffi.Pointer<TWString1>)>();

  /// Generates the private key for the specified derivation.
  ///
  /// \see TWHDWalletGetKey
  /// \see TWHDWalletGetKeyForCoin
  /// \param wallet non-null TWHDWallet
  /// \param coin a coin type
  /// \param derivation a (custom) derivation to use
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return The private key for the specified derivation path/coin
  ffi.Pointer<TWPrivateKey> TWHDWalletGetKeyDerivation(
    ffi.Pointer<TWHDWallet> wallet,
    TWCoinType coin,
    TWDerivation derivation,
  ) {
    return _TWHDWalletGetKeyDerivation(
      wallet,
      coin.value,
      derivation.value,
    );
  }

  late final _TWHDWalletGetKeyDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt, ffi.UnsignedInt)>>('TWHDWalletGetKeyDerivation');
  late final _TWHDWalletGetKeyDerivation =
      _TWHDWalletGetKeyDerivationPtr.asFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWHDWallet>, int, int)>();

  /// Generates the private key for the specified derivation path and curve.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param curve a curve
  /// \param derivationPath  a non-null derivation path
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return The private key for the specified derivation path/curve
  ffi.Pointer<TWPrivateKey> TWHDWalletGetKeyByCurve(
    ffi.Pointer<TWHDWallet> wallet,
    TWCurve curve,
    ffi.Pointer<TWString1> derivationPath,
  ) {
    return _TWHDWalletGetKeyByCurve(
      wallet,
      curve.value,
      derivationPath,
    );
  }

  late final _TWHDWalletGetKeyByCurvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.Pointer<TWString1>)>>('TWHDWalletGetKeyByCurve');
  late final _TWHDWalletGetKeyByCurve = _TWHDWalletGetKeyByCurvePtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(
          ffi.Pointer<TWHDWallet>, int, ffi.Pointer<TWString1>)>();

  /// Shortcut method to generate private key with the specified account/change/address (bip44 standard).
  ///
  /// \see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
  ///
  /// \param wallet non-null TWHDWallet
  /// \param coin a coin type
  /// \param account valid bip44 account
  /// \param change valid bip44 change
  /// \param address valid bip44 address
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return The private key for the specified bip44 parameters
  ffi.Pointer<TWPrivateKey> TWHDWalletGetDerivedKey(
    ffi.Pointer<TWHDWallet> wallet,
    TWCoinType coin,
    int account,
    int change,
    int address,
  ) {
    return _TWHDWalletGetDerivedKey(
      wallet,
      coin.value,
      account,
      change,
      address,
    );
  }

  late final _TWHDWalletGetDerivedKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32)>>('TWHDWalletGetDerivedKey');
  late final _TWHDWalletGetDerivedKey = _TWHDWalletGetDerivedKeyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(
          ffi.Pointer<TWHDWallet>, int, int, int, int)>();

  /// Returns the extended private key (for default 0 account).
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param version hd version
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended private key as a non-null TWString
  ffi.Pointer<TWString1> TWHDWalletGetExtendedPrivateKey(
    ffi.Pointer<TWHDWallet> wallet,
    TWPurpose purpose,
    TWCoinType coin,
    TWHDVersion version,
  ) {
    return _TWHDWalletGetExtendedPrivateKey(
      wallet,
      purpose.value,
      coin.value,
      version.value,
    );
  }

  late final _TWHDWalletGetExtendedPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWHDWalletGetExtendedPrivateKey');
  late final _TWHDWalletGetExtendedPrivateKey =
      _TWHDWalletGetExtendedPrivateKeyPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>, int, int, int)>();

  /// Returns the extended public key (for default 0 account).
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param version hd version
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended public key as a non-null TWString
  ffi.Pointer<TWString1> TWHDWalletGetExtendedPublicKey(
    ffi.Pointer<TWHDWallet> wallet,
    TWPurpose purpose,
    TWCoinType coin,
    TWHDVersion version,
  ) {
    return _TWHDWalletGetExtendedPublicKey(
      wallet,
      purpose.value,
      coin.value,
      version.value,
    );
  }

  late final _TWHDWalletGetExtendedPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWHDWalletGetExtendedPublicKey');
  late final _TWHDWalletGetExtendedPublicKey =
      _TWHDWalletGetExtendedPublicKeyPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>, int, int, int)>();

  /// Returns the extended private key, for custom account.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param derivation a derivation
  /// \param version an hd version
  /// \param account valid bip44 account
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended private key as a non-null TWString
  ffi.Pointer<TWString1> TWHDWalletGetExtendedPrivateKeyAccount(
    ffi.Pointer<TWHDWallet> wallet,
    TWPurpose purpose,
    TWCoinType coin,
    TWDerivation derivation,
    TWHDVersion version,
    int account,
  ) {
    return _TWHDWalletGetExtendedPrivateKeyAccount(
      wallet,
      purpose.value,
      coin.value,
      derivation.value,
      version.value,
      account,
    );
  }

  late final _TWHDWalletGetExtendedPrivateKeyAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Uint32)>>('TWHDWalletGetExtendedPrivateKeyAccount');
  late final _TWHDWalletGetExtendedPrivateKeyAccount =
      _TWHDWalletGetExtendedPrivateKeyAccountPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>, int, int, int, int, int)>();

  /// Returns the extended public key, for custom account.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param derivation a derivation
  /// \param version an hd version
  /// \param account valid bip44 account
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return Extended public key as a non-null TWString
  ffi.Pointer<TWString1> TWHDWalletGetExtendedPublicKeyAccount(
    ffi.Pointer<TWHDWallet> wallet,
    TWPurpose purpose,
    TWCoinType coin,
    TWDerivation derivation,
    TWHDVersion version,
    int account,
  ) {
    return _TWHDWalletGetExtendedPublicKeyAccount(
      wallet,
      purpose.value,
      coin.value,
      derivation.value,
      version.value,
      account,
    );
  }

  late final _TWHDWalletGetExtendedPublicKeyAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Uint32)>>('TWHDWalletGetExtendedPublicKeyAccount');
  late final _TWHDWalletGetExtendedPublicKeyAccount =
      _TWHDWalletGetExtendedPublicKeyAccountPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>, int, int, int, int, int)>();

  /// Returns the extended private key (for default 0 account with derivation).
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param derivation a derivation
  /// \param version an hd version
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended private key as a non-null TWString
  ffi.Pointer<TWString1> TWHDWalletGetExtendedPrivateKeyDerivation(
    ffi.Pointer<TWHDWallet> wallet,
    TWPurpose purpose,
    TWCoinType coin,
    TWDerivation derivation,
    TWHDVersion version,
  ) {
    return _TWHDWalletGetExtendedPrivateKeyDerivation(
      wallet,
      purpose.value,
      coin.value,
      derivation.value,
      version.value,
    );
  }

  late final _TWHDWalletGetExtendedPrivateKeyDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWHDWalletGetExtendedPrivateKeyDerivation');
  late final _TWHDWalletGetExtendedPrivateKeyDerivation =
      _TWHDWalletGetExtendedPrivateKeyDerivationPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>, int, int, int, int)>();

  /// Returns the extended public key (for default 0 account with derivation).
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param derivation a derivation
  /// \param version an hd version
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended public key as a non-null TWString
  ffi.Pointer<TWString1> TWHDWalletGetExtendedPublicKeyDerivation(
    ffi.Pointer<TWHDWallet> wallet,
    TWPurpose purpose,
    TWCoinType coin,
    TWDerivation derivation,
    TWHDVersion version,
  ) {
    return _TWHDWalletGetExtendedPublicKeyDerivation(
      wallet,
      purpose.value,
      coin.value,
      derivation.value,
      version.value,
    );
  }

  late final _TWHDWalletGetExtendedPublicKeyDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWHDWalletGetExtendedPublicKeyDerivation');
  late final _TWHDWalletGetExtendedPublicKeyDerivation =
      _TWHDWalletGetExtendedPublicKeyDerivationPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWHDWallet>, int, int, int, int)>();

  /// Computes the public key from an extended public key representation.
  ///
  /// \param extended extended public key
  /// \param coin a coin type
  /// \param derivationPath a derivation path
  /// \note Returned object needs to be deleted with \TWPublicKeyDelete
  /// \return Nullable TWPublic key
  ffi.Pointer<TWPublicKey> TWHDWalletGetPublicKeyFromExtended(
    ffi.Pointer<TWString1> extended,
    TWCoinType coin,
    ffi.Pointer<TWString1> derivationPath,
  ) {
    return _TWHDWalletGetPublicKeyFromExtended(
      extended,
      coin.value,
      derivationPath,
    );
  }

  late final _TWHDWalletGetPublicKeyFromExtendedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWString1>,
              ffi.UnsignedInt,
              ffi.Pointer<TWString1>)>>('TWHDWalletGetPublicKeyFromExtended');
  late final _TWHDWalletGetPublicKeyFromExtended =
      _TWHDWalletGetPublicKeyFromExtendedPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWString1>, int, ffi.Pointer<TWString1>)>();

  /// Encode an item or a list of items as Eth RLP binary format.
  ///
  /// \param coin EVM-compatible coin type.
  /// \param input Non-null serialized `EthereumRlp::Proto::EncodingInput`.
  /// \return serialized `EthereumRlp::Proto::EncodingOutput`.
  ffi.Pointer<TWData1> TWEthereumRlpEncode(
    TWCoinType coin,
    ffi.Pointer<TWData1> input,
  ) {
    return _TWEthereumRlpEncode(
      coin.value,
      input,
    );
  }

  late final _TWEthereumRlpEncodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.UnsignedInt, ffi.Pointer<TWData1>)>>('TWEthereumRlpEncode');
  late final _TWEthereumRlpEncode = _TWEthereumRlpEncodePtr.asFunction<
      ffi.Pointer<TWData1> Function(int, ffi.Pointer<TWData1>)>();

  /// Creates a Vector of Data.
  ///
  /// \note Must be deleted with \TWDataVectorDelete
  /// \return a non-null Vector of Data.
  ffi.Pointer<TWDataVector> TWDataVectorCreate() {
    return _TWDataVectorCreate();
  }

  late final _TWDataVectorCreatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWDataVector> Function()>>(
          'TWDataVectorCreate');
  late final _TWDataVectorCreate =
      _TWDataVectorCreatePtr.asFunction<ffi.Pointer<TWDataVector> Function()>();

  /// Creates a Vector of Data with the given element
  ///
  /// \param data A non-null valid block of data
  /// \return A Vector of data with a single given element
  ffi.Pointer<TWDataVector> TWDataVectorCreateWithData(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWDataVectorCreateWithData(
      data,
    );
  }

  late final _TWDataVectorCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDataVector> Function(
              ffi.Pointer<TWData1>)>>('TWDataVectorCreateWithData');
  late final _TWDataVectorCreateWithData = _TWDataVectorCreateWithDataPtr
      .asFunction<ffi.Pointer<TWDataVector> Function(ffi.Pointer<TWData1>)>();

  /// Delete/Deallocate a Vector of Data
  ///
  /// \param dataVector A non-null Vector of data
  void TWDataVectorDelete(
    ffi.Pointer<TWDataVector> dataVector,
  ) {
    return _TWDataVectorDelete(
      dataVector,
    );
  }

  late final _TWDataVectorDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWDataVector>)>>(
          'TWDataVectorDelete');
  late final _TWDataVectorDelete = _TWDataVectorDeletePtr.asFunction<
      void Function(ffi.Pointer<TWDataVector>)>();

  /// Add an element to a Vector of Data. Element is cloned
  ///
  /// \param dataVector A non-null Vector of data
  /// \param data A non-null valid block of data
  /// \note data input parameter must be deleted on its own
  void TWDataVectorAdd(
    ffi.Pointer<TWDataVector> dataVector,
    ffi.Pointer<TWData1> data,
  ) {
    return _TWDataVectorAdd(
      dataVector,
      data,
    );
  }

  late final _TWDataVectorAddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWDataVector>,
              ffi.Pointer<TWData1>)>>('TWDataVectorAdd');
  late final _TWDataVectorAdd = _TWDataVectorAddPtr.asFunction<
      void Function(ffi.Pointer<TWDataVector>, ffi.Pointer<TWData1>)>();

  /// Retrieve the number of elements
  ///
  /// \param dataVector A non-null Vector of data
  /// \return the size of the given vector.
  int TWDataVectorSize(
    ffi.Pointer<TWDataVector> dataVector,
  ) {
    return _TWDataVectorSize(
      dataVector,
    );
  }

  late final _TWDataVectorSizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWDataVector>)>>(
          'TWDataVectorSize');
  late final _TWDataVectorSize = _TWDataVectorSizePtr.asFunction<
      int Function(ffi.Pointer<TWDataVector>)>();

  /// Retrieve the n-th element.
  ///
  /// \param dataVector A non-null Vector of data
  /// \param index index element of the vector to be retrieved, need to be < TWDataVectorSize
  /// \note Returned element must be freed with \TWDataDelete
  /// \return A non-null block of data
  ffi.Pointer<TWData1> TWDataVectorGet(
    ffi.Pointer<TWDataVector> dataVector,
    int index,
  ) {
    return _TWDataVectorGet(
      dataVector,
      index,
    );
  }

  late final _TWDataVectorGetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWDataVector>, ffi.Size)>>('TWDataVectorGet');
  late final _TWDataVectorGet = _TWDataVectorGetPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWDataVector>, int)>();

  /// Obtains pre-signing hashes of a transaction.
  ///
  /// We provide a default `PreSigningOutput` in TransactionCompiler.proto.
  /// For some special coins, such as bitcoin, we will create a custom `PreSigningOutput` object in its proto file.
  /// \param coin coin type.
  /// \param txInputData The serialized data of a signing input
  /// \return serialized data of a proto object `PreSigningOutput` includes hash.
  ffi.Pointer<TWData1> TWTransactionCompilerPreImageHashes(
    TWCoinType coinType,
    ffi.Pointer<TWData1> txInputData,
  ) {
    return _TWTransactionCompilerPreImageHashes(
      coinType.value,
      txInputData,
    );
  }

  late final _TWTransactionCompilerPreImageHashesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.UnsignedInt,
              ffi.Pointer<TWData1>)>>('TWTransactionCompilerPreImageHashes');
  late final _TWTransactionCompilerPreImageHashes =
      _TWTransactionCompilerPreImageHashesPtr.asFunction<
          ffi.Pointer<TWData1> Function(int, ffi.Pointer<TWData1>)>();

  /// Compiles a complete transation with one or more external signatures.
  ///
  /// Puts together from transaction input and provided public keys and signatures. The signatures must match the hashes
  /// returned by TWTransactionCompilerPreImageHashes, in the same order. The publicKeyHash attached
  /// to the hashes enable identifying the private key needed for signing the hash.
  /// \param coin coin type.
  /// \param txInputData The serialized data of a signing input.
  /// \param signatures signatures to compile, using TWDataVector.
  /// \param publicKeys public keys for signers to match private keys, using TWDataVector.
  /// \return serialized data of a proto object `SigningOutput`.
  ffi.Pointer<TWData1> TWTransactionCompilerCompileWithSignatures(
    TWCoinType coinType,
    ffi.Pointer<TWData1> txInputData,
    ffi.Pointer<TWDataVector> signatures,
    ffi.Pointer<TWDataVector> publicKeys,
  ) {
    return _TWTransactionCompilerCompileWithSignatures(
      coinType.value,
      txInputData,
      signatures,
      publicKeys,
    );
  }

  late final _TWTransactionCompilerCompileWithSignaturesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData1> Function(
                  ffi.UnsignedInt,
                  ffi.Pointer<TWData1>,
                  ffi.Pointer<TWDataVector>,
                  ffi.Pointer<TWDataVector>)>>(
      'TWTransactionCompilerCompileWithSignatures');
  late final _TWTransactionCompilerCompileWithSignatures =
      _TWTransactionCompilerCompileWithSignaturesPtr.asFunction<
          ffi.Pointer<TWData1> Function(int, ffi.Pointer<TWData1>,
              ffi.Pointer<TWDataVector>, ffi.Pointer<TWDataVector>)>();

  ffi.Pointer<TWData1> TWTransactionCompilerCompileWithSignaturesAndPubKeyType(
    TWCoinType coinType,
    ffi.Pointer<TWData1> txInputData,
    ffi.Pointer<TWDataVector> signatures,
    ffi.Pointer<TWDataVector> publicKeys,
    TWPublicKeyType pubKeyType,
  ) {
    return _TWTransactionCompilerCompileWithSignaturesAndPubKeyType(
      coinType.value,
      txInputData,
      signatures,
      publicKeys,
      pubKeyType.value,
    );
  }

  late final _TWTransactionCompilerCompileWithSignaturesAndPubKeyTypePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Pointer<TWData1> Function(
                      ffi.UnsignedInt,
                      ffi.Pointer<TWData1>,
                      ffi.Pointer<TWDataVector>,
                      ffi.Pointer<TWDataVector>,
                      ffi.UnsignedInt)>>(
          'TWTransactionCompilerCompileWithSignaturesAndPubKeyType');
  late final _TWTransactionCompilerCompileWithSignaturesAndPubKeyType =
      _TWTransactionCompilerCompileWithSignaturesAndPubKeyTypePtr.asFunction<
          ffi.Pointer<TWData1> Function(int, ffi.Pointer<TWData1>,
              ffi.Pointer<TWDataVector>, ffi.Pointer<TWDataVector>, int)>();

  /// Generates the private stark key at the given derivation path from a valid eth signature
  ///
  /// \param derivationPath non-null StarkEx Derivation path
  /// \param signature valid eth signature
  /// \return  The private key for the specified derivation path/signature
  ffi.Pointer<TWPrivateKey> TWStarkWareGetStarkKeyFromSignature(
    ffi.Pointer<TWDerivationPath> derivationPath,
    ffi.Pointer<TWString> signature,
  ) {
    return _TWStarkWareGetStarkKeyFromSignature(
      derivationPath,
      signature,
    );
  }

  late final _TWStarkWareGetStarkKeyFromSignaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWDerivationPath>,
              ffi.Pointer<TWString>)>>('TWStarkWareGetStarkKeyFromSignature');
  late final _TWStarkWareGetStarkKeyFromSignature =
      _TWStarkWareGetStarkKeyFromSignaturePtr.asFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWDerivationPath>, ffi.Pointer<TWString>)>();

  /// Determines if the given sig hash is single
  ///
  /// \param type sig hash type
  /// \return true if the sigh hash type is single, false otherwise
  bool TWBitcoinSigHashTypeIsSingle(
    TWBitcoinSigHashType type,
  ) {
    return _TWBitcoinSigHashTypeIsSingle(
      type.value,
    );
  }

  late final _TWBitcoinSigHashTypeIsSinglePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.UnsignedInt)>>(
          'TWBitcoinSigHashTypeIsSingle');
  late final _TWBitcoinSigHashTypeIsSingle =
      _TWBitcoinSigHashTypeIsSinglePtr.asFunction<bool Function(int)>();

  /// Determines if the given sig hash is none
  ///
  /// \param type sig hash type
  /// \return true if the sigh hash type is none, false otherwise
  bool TWBitcoinSigHashTypeIsNone(
    TWBitcoinSigHashType type,
  ) {
    return _TWBitcoinSigHashTypeIsNone(
      type.value,
    );
  }

  late final _TWBitcoinSigHashTypeIsNonePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.UnsignedInt)>>(
          'TWBitcoinSigHashTypeIsNone');
  late final _TWBitcoinSigHashTypeIsNone =
      _TWBitcoinSigHashTypeIsNonePtr.asFunction<bool Function(int)>();

  /// Encode a bool according to Ethereum ABI, into 32 bytes.  Values are padded by 0 on the left, unless specified otherwise
  ///
  /// \param value a boolean value
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData1> TWEthereumAbiValueEncodeBool(
    bool value,
  ) {
    return _TWEthereumAbiValueEncodeBool(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeBoolPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWData1> Function(ffi.Bool)>>(
          'TWEthereumAbiValueEncodeBool');
  late final _TWEthereumAbiValueEncodeBool = _TWEthereumAbiValueEncodeBoolPtr
      .asFunction<ffi.Pointer<TWData1> Function(bool)>();

  /// Encode a int32 according to Ethereum ABI, into 32 bytes. Values are padded by 0 on the left, unless specified otherwise
  ///
  /// \param value a int32 value
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData1> TWEthereumAbiValueEncodeInt32(
    int value,
  ) {
    return _TWEthereumAbiValueEncodeInt32(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeInt32Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWData1> Function(ffi.Int32)>>(
          'TWEthereumAbiValueEncodeInt32');
  late final _TWEthereumAbiValueEncodeInt32 = _TWEthereumAbiValueEncodeInt32Ptr
      .asFunction<ffi.Pointer<TWData1> Function(int)>();

  /// Encode a uint32 according to Ethereum ABI, into 32 bytes.  Values are padded by 0 on the left, unless specified otherwise
  ///
  /// \param value a uint32 value
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData1> TWEthereumAbiValueEncodeUInt32(
    int value,
  ) {
    return _TWEthereumAbiValueEncodeUInt32(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeUInt32Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWData1> Function(ffi.Uint32)>>(
          'TWEthereumAbiValueEncodeUInt32');
  late final _TWEthereumAbiValueEncodeUInt32 =
      _TWEthereumAbiValueEncodeUInt32Ptr.asFunction<
          ffi.Pointer<TWData1> Function(int)>();

  /// Encode a int256 according to Ethereum ABI, into 32 bytes.  Values are padded by 0 on the left, unless specified otherwise
  ///
  /// \param value a int256 value stored in a block of data
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData1> TWEthereumAbiValueEncodeInt256(
    ffi.Pointer<TWData1> value,
  ) {
    return _TWEthereumAbiValueEncodeInt256(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeInt256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWEthereumAbiValueEncodeInt256');
  late final _TWEthereumAbiValueEncodeInt256 =
      _TWEthereumAbiValueEncodeInt256Ptr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Encode an int256 according to Ethereum ABI, into 32 bytes.  Values are padded by 0 on the left, unless specified otherwise
  ///
  /// \param value a int256 value stored in a block of data
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData1> TWEthereumAbiValueEncodeUInt256(
    ffi.Pointer<TWData1> value,
  ) {
    return _TWEthereumAbiValueEncodeUInt256(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeUInt256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWEthereumAbiValueEncodeUInt256');
  late final _TWEthereumAbiValueEncodeUInt256 =
      _TWEthereumAbiValueEncodeUInt256Ptr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Encode an address according to Ethereum ABI, 20 bytes of the address.
  ///
  /// \param value an address value stored in a block of data
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData1> TWEthereumAbiValueEncodeAddress(
    ffi.Pointer<TWData1> value,
  ) {
    return _TWEthereumAbiValueEncodeAddress(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeAddressPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWEthereumAbiValueEncodeAddress');
  late final _TWEthereumAbiValueEncodeAddress =
      _TWEthereumAbiValueEncodeAddressPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Encode a string according to Ethereum ABI by encoding its hash.
  ///
  /// \param value a string value
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData1> TWEthereumAbiValueEncodeString(
    ffi.Pointer<TWString1> value,
  ) {
    return _TWEthereumAbiValueEncodeString(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWString1>)>>('TWEthereumAbiValueEncodeString');
  late final _TWEthereumAbiValueEncodeString =
      _TWEthereumAbiValueEncodeStringPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWString1>)>();

  /// Encode a number of bytes, up to 32 bytes, padded on the right.  Longer arrays are truncated.
  ///
  /// \param value bunch of bytes
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData1> TWEthereumAbiValueEncodeBytes(
    ffi.Pointer<TWData1> value,
  ) {
    return _TWEthereumAbiValueEncodeBytes(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeBytesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWEthereumAbiValueEncodeBytes');
  late final _TWEthereumAbiValueEncodeBytes = _TWEthereumAbiValueEncodeBytesPtr
      .asFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Encode a dynamic number of bytes by encoding its hash
  ///
  /// \param value bunch of bytes
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData1> TWEthereumAbiValueEncodeBytesDyn(
    ffi.Pointer<TWData1> value,
  ) {
    return _TWEthereumAbiValueEncodeBytesDyn(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeBytesDynPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWEthereumAbiValueEncodeBytesDyn');
  late final _TWEthereumAbiValueEncodeBytesDyn =
      _TWEthereumAbiValueEncodeBytesDynPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Decodes input data (bytes longer than 32 will be truncated) as uint256
  ///
  /// \param input Data to be decoded
  /// \return Non-null decoded string value
  ffi.Pointer<TWString1> TWEthereumAbiValueDecodeUInt256(
    ffi.Pointer<TWData1> input,
  ) {
    return _TWEthereumAbiValueDecodeUInt256(
      input,
    );
  }

  late final _TWEthereumAbiValueDecodeUInt256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>)>>('TWEthereumAbiValueDecodeUInt256');
  late final _TWEthereumAbiValueDecodeUInt256 =
      _TWEthereumAbiValueDecodeUInt256Ptr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWData1>)>();

  /// Decode an arbitrary type, return value as string
  ///
  /// \param input Data to be decoded
  /// \param type the underlying type that need to be decoded
  /// \return Non-null decoded string value
  ffi.Pointer<TWString1> TWEthereumAbiValueDecodeValue(
    ffi.Pointer<TWData1> input,
    ffi.Pointer<TWString1> type,
  ) {
    return _TWEthereumAbiValueDecodeValue(
      input,
      type,
    );
  }

  late final _TWEthereumAbiValueDecodeValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>)>>('TWEthereumAbiValueDecodeValue');
  late final _TWEthereumAbiValueDecodeValue =
      _TWEthereumAbiValueDecodeValuePtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>, ffi.Pointer<TWString1>)>();

  /// Decode an array of given simple types.  Return a '\n'-separated string of elements
  ///
  /// \param input Data to be decoded
  /// \param type the underlying type that need to be decoded
  /// \return Non-null decoded string value
  ffi.Pointer<TWString1> TWEthereumAbiValueDecodeArray(
    ffi.Pointer<TWData1> input,
    ffi.Pointer<TWString1> type,
  ) {
    return _TWEthereumAbiValueDecodeArray(
      input,
      type,
    );
  }

  late final _TWEthereumAbiValueDecodeArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>)>>('TWEthereumAbiValueDecodeArray');
  late final _TWEthereumAbiValueDecodeArray =
      _TWEthereumAbiValueDecodeArrayPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>, ffi.Pointer<TWString1>)>();

  /// Signs a transaction specified by the signing input and coin type.
  ///
  /// \param input The serialized data of a signing input (e.g. TW.Bitcoin.Proto.SigningInput).
  /// \param coin The given coin type to sign the transaction for.
  /// \return The serialized data of a `SigningOutput` proto object. (e.g. TW.Bitcoin.Proto.SigningOutput).
  ffi.Pointer<TWData1> TWAnySignerSign(
    ffi.Pointer<TWData1> input,
    TWCoinType coin,
  ) {
    return _TWAnySignerSign(
      input,
      coin.value,
    );
  }

  late final _TWAnySignerSignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>, ffi.UnsignedInt)>>('TWAnySignerSign');
  late final _TWAnySignerSign = _TWAnySignerSignPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>, int)>();

  /// Signs a transaction specified by the JSON representation of signing input, coin type and a private key, returning the JSON representation of the signing output.
  ///
  /// \param json JSON representation of a signing input
  /// \param key The private key to sign with.
  /// \param coin The given coin type to sign the transaction for.
  /// \return The JSON representation of a `SigningOutput` proto object.
  ffi.Pointer<TWString1> TWAnySignerSignJSON(
    ffi.Pointer<TWString1> json,
    ffi.Pointer<TWData1> key,
    TWCoinType coin,
  ) {
    return _TWAnySignerSignJSON(
      json,
      key,
      coin.value,
    );
  }

  late final _TWAnySignerSignJSONPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>, ffi.UnsignedInt)>>('TWAnySignerSignJSON');
  late final _TWAnySignerSignJSON = _TWAnySignerSignJSONPtr.asFunction<
      ffi.Pointer<TWString1> Function(
          ffi.Pointer<TWString1>, ffi.Pointer<TWData1>, int)>();

  /// Check if AnySigner supports signing JSON representation of signing input.
  ///
  /// \param coin The given coin type to sign the transaction for.
  /// \return true if AnySigner supports signing JSON representation of signing input for a given coin.
  bool TWAnySignerSupportsJSON(
    TWCoinType coin,
  ) {
    return _TWAnySignerSupportsJSON(
      coin.value,
    );
  }

  late final _TWAnySignerSupportsJSONPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.UnsignedInt)>>(
          'TWAnySignerSupportsJSON');
  late final _TWAnySignerSupportsJSON =
      _TWAnySignerSupportsJSONPtr.asFunction<bool Function(int)>();

  /// Plans a transaction (for UTXO chains only).
  ///
  /// \param input The serialized data of a signing input
  /// \param coin The given coin type to plan the transaction for.
  /// \return The serialized data of a `TransactionPlan` proto object.
  ffi.Pointer<TWData1> TWAnySignerPlan(
    ffi.Pointer<TWData1> input,
    TWCoinType coin,
  ) {
    return _TWAnySignerPlan(
      input,
      coin.value,
    );
  }

  late final _TWAnySignerPlanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>, ffi.UnsignedInt)>>('TWAnySignerPlan');
  late final _TWAnySignerPlan = _TWAnySignerPlanPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>, int)>();

  /// Compares two addresses for equality.
  ///
  /// \param lhs The first address to compare.
  /// \param rhs The second address to compare.
  /// \return bool indicating the addresses are equal.
  bool TWNervosAddressEqual(
    ffi.Pointer<TWNervosAddress> lhs,
    ffi.Pointer<TWNervosAddress> rhs,
  ) {
    return _TWNervosAddressEqual(
      lhs,
      rhs,
    );
  }

  late final _TWNervosAddressEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWNervosAddress>,
              ffi.Pointer<TWNervosAddress>)>>('TWNervosAddressEqual');
  late final _TWNervosAddressEqual = _TWNervosAddressEqualPtr.asFunction<
      bool Function(
          ffi.Pointer<TWNervosAddress>, ffi.Pointer<TWNervosAddress>)>();

  /// Determines if the string is a valid Nervos address.
  ///
  /// \param string string to validate.
  /// \return bool indicating if the address is valid.
  bool TWNervosAddressIsValidString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWNervosAddressIsValidString(
      string,
    );
  }

  late final _TWNervosAddressIsValidStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString>)>>(
          'TWNervosAddressIsValidString');
  late final _TWNervosAddressIsValidString = _TWNervosAddressIsValidStringPtr
      .asFunction<bool Function(ffi.Pointer<TWString>)>();

  /// Initializes an address from a sring representaion.
  ///
  /// \param string Bech32 string to initialize the address from.
  /// \return TWNervosAddress pointer or nullptr if string is invalid.
  ffi.Pointer<TWNervosAddress> TWNervosAddressCreateWithString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWNervosAddressCreateWithString(
      string,
    );
  }

  late final _TWNervosAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWNervosAddress> Function(
              ffi.Pointer<TWString>)>>('TWNervosAddressCreateWithString');
  late final _TWNervosAddressCreateWithString =
      _TWNervosAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWNervosAddress> Function(ffi.Pointer<TWString>)>();

  /// Deletes a Nervos address.
  ///
  /// \param address Address to delete.
  void TWNervosAddressDelete(
    ffi.Pointer<TWNervosAddress> address,
  ) {
    return _TWNervosAddressDelete(
      address,
    );
  }

  late final _TWNervosAddressDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWNervosAddress>)>>(
      'TWNervosAddressDelete');
  late final _TWNervosAddressDelete = _TWNervosAddressDeletePtr.asFunction<
      void Function(ffi.Pointer<TWNervosAddress>)>();

  /// Returns the address string representation.
  ///
  /// \param address Address to get the string representation of.
  ffi.Pointer<TWString> TWNervosAddressDescription(
    ffi.Pointer<TWNervosAddress> address,
  ) {
    return _TWNervosAddressDescription(
      address,
    );
  }

  late final _TWNervosAddressDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWNervosAddress>)>>('TWNervosAddressDescription');
  late final _TWNervosAddressDescription =
      _TWNervosAddressDescriptionPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWNervosAddress>)>();

  /// Returns the Code hash
  ///
  /// \param address Address to get the keyhash data of.
  ffi.Pointer<TWData> TWNervosAddressCodeHash(
    ffi.Pointer<TWNervosAddress> address,
  ) {
    return _TWNervosAddressCodeHash(
      address,
    );
  }

  late final _TWNervosAddressCodeHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWNervosAddress>)>>('TWNervosAddressCodeHash');
  late final _TWNervosAddressCodeHash = _TWNervosAddressCodeHashPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWNervosAddress>)>();

  /// Returns the address hash type
  ///
  /// \param address Address to get the hash type of.
  ffi.Pointer<TWString> TWNervosAddressHashType(
    ffi.Pointer<TWNervosAddress> address,
  ) {
    return _TWNervosAddressHashType(
      address,
    );
  }

  late final _TWNervosAddressHashTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWNervosAddress>)>>('TWNervosAddressHashType');
  late final _TWNervosAddressHashType = _TWNervosAddressHashTypePtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWNervosAddress>)>();

  /// Returns the address args data.
  ///
  /// \param address Address to get the args data of.
  ffi.Pointer<TWData> TWNervosAddressArgs(
    ffi.Pointer<TWNervosAddress> address,
  ) {
    return _TWNervosAddressArgs(
      address,
    );
  }

  late final _TWNervosAddressArgsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWNervosAddress>)>>('TWNervosAddressArgs');
  late final _TWNervosAddressArgs = _TWNervosAddressArgsPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWNervosAddress>)>();

  /// Decode a Base64 input with the default alphabet (RFC4648 with '+', '/')
  ///
  /// \param string Encoded input to be decoded
  /// \return The decoded data, empty if decoding failed.
  ffi.Pointer<TWData> TWBase64Decode(
    ffi.Pointer<TWString> string,
  ) {
    return _TWBase64Decode(
      string,
    );
  }

  late final _TWBase64DecodePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>>(
      'TWBase64Decode');
  late final _TWBase64Decode = _TWBase64DecodePtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>();

  /// Decode a Base64 input with the alphabet safe for URL-s and filenames (RFC4648 with '-', '_')
  ///
  /// \param string Encoded base64 input to be decoded
  /// \return The decoded data, empty if decoding failed.
  ffi.Pointer<TWData> TWBase64DecodeUrl(
    ffi.Pointer<TWString> string,
  ) {
    return _TWBase64DecodeUrl(
      string,
    );
  }

  late final _TWBase64DecodeUrlPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>>(
      'TWBase64DecodeUrl');
  late final _TWBase64DecodeUrl = _TWBase64DecodeUrlPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>();

  /// Encode an input to Base64 with the default alphabet (RFC4648 with '+', '/')
  ///
  /// \param data Data to be encoded (raw bytes)
  /// \return The encoded data
  ffi.Pointer<TWString> TWBase64Encode(
    ffi.Pointer<TWData> data,
  ) {
    return _TWBase64Encode(
      data,
    );
  }

  late final _TWBase64EncodePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>>(
      'TWBase64Encode');
  late final _TWBase64Encode = _TWBase64EncodePtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>();

  /// Encode an input to Base64 with the alphabet safe for URL-s and filenames (RFC4648 with '-', '_')
  ///
  /// \param data Data to be encoded (raw bytes)
  /// \return The encoded data
  ffi.Pointer<TWString> TWBase64EncodeUrl(
    ffi.Pointer<TWData> data,
  ) {
    return _TWBase64EncodeUrl(
      data,
    );
  }

  late final _TWBase64EncodeUrlPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>>(
      'TWBase64EncodeUrl');
  late final _TWBase64EncodeUrl = _TWBase64EncodeUrlPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>();

  /// Compares two addresses for equality.
  ///
  /// \param lhs left non-null pointer to a Bech32 Address
  /// \param rhs right non-null pointer to a Bech32 Address
  /// \return true if both address are equal, false otherwise
  bool TWSegwitAddressEqual(
    ffi.Pointer<TWSegwitAddress> lhs,
    ffi.Pointer<TWSegwitAddress> rhs,
  ) {
    return _TWSegwitAddressEqual(
      lhs,
      rhs,
    );
  }

  late final _TWSegwitAddressEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWSegwitAddress>,
              ffi.Pointer<TWSegwitAddress>)>>('TWSegwitAddressEqual');
  late final _TWSegwitAddressEqual = _TWSegwitAddressEqualPtr.asFunction<
      bool Function(
          ffi.Pointer<TWSegwitAddress>, ffi.Pointer<TWSegwitAddress>)>();

  /// Determines if the string is a valid Bech32 address.
  ///
  /// \param string Non-null pointer to a Bech32 address as a string
  /// \return true if the string is a valid Bech32 address, false otherwise.
  bool TWSegwitAddressIsValidString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWSegwitAddressIsValidString(
      string,
    );
  }

  late final _TWSegwitAddressIsValidStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString1>)>>(
          'TWSegwitAddressIsValidString');
  late final _TWSegwitAddressIsValidString = _TWSegwitAddressIsValidStringPtr
      .asFunction<bool Function(ffi.Pointer<TWString1>)>();

  /// Creates an address from a string representation.
  ///
  /// \param string Non-null pointer to a Bech32 address as a string
  /// \note should be deleted with \TWSegwitAddressDelete
  /// \return Pointer to a Bech32 address if the string is a valid Bech32 address, null pointer otherwise
  ffi.Pointer<TWSegwitAddress> TWSegwitAddressCreateWithString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWSegwitAddressCreateWithString(
      string,
    );
  }

  late final _TWSegwitAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWSegwitAddress> Function(
              ffi.Pointer<TWString1>)>>('TWSegwitAddressCreateWithString');
  late final _TWSegwitAddressCreateWithString =
      _TWSegwitAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWSegwitAddress> Function(ffi.Pointer<TWString1>)>();

  /// Creates a segwit-version-0 address from a public key and HRP prefix.
  /// Taproot (v>=1) is not supported by this method.
  ///
  /// \param hrp HRP of the utxo coin targeted
  /// \param publicKey Non-null pointer to the public key of the targeted coin
  /// \note should be deleted with \TWSegwitAddressDelete
  /// \return Non-null pointer to the corresponding Segwit address
  ffi.Pointer<TWSegwitAddress> TWSegwitAddressCreateWithPublicKey(
    TWHRP hrp,
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return _TWSegwitAddressCreateWithPublicKey(
      hrp.value,
      publicKey,
    );
  }

  late final _TWSegwitAddressCreateWithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWSegwitAddress> Function(ffi.UnsignedInt,
              ffi.Pointer<TWPublicKey>)>>('TWSegwitAddressCreateWithPublicKey');
  late final _TWSegwitAddressCreateWithPublicKey =
      _TWSegwitAddressCreateWithPublicKeyPtr.asFunction<
          ffi.Pointer<TWSegwitAddress> Function(
              int, ffi.Pointer<TWPublicKey>)>();

  /// Delete the given Segwit address
  ///
  /// \param address Non-null pointer to a Segwit address
  void TWSegwitAddressDelete(
    ffi.Pointer<TWSegwitAddress> address,
  ) {
    return _TWSegwitAddressDelete(
      address,
    );
  }

  late final _TWSegwitAddressDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWSegwitAddress>)>>(
      'TWSegwitAddressDelete');
  late final _TWSegwitAddressDelete = _TWSegwitAddressDeletePtr.asFunction<
      void Function(ffi.Pointer<TWSegwitAddress>)>();

  /// Returns the address string representation.
  ///
  /// \param address Non-null pointer to a Segwit Address
  /// \return Non-null pointer to the segwit address string representation
  ffi.Pointer<TWString1> TWSegwitAddressDescription(
    ffi.Pointer<TWSegwitAddress> address,
  ) {
    return _TWSegwitAddressDescription(
      address,
    );
  }

  late final _TWSegwitAddressDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWSegwitAddress>)>>('TWSegwitAddressDescription');
  late final _TWSegwitAddressDescription =
      _TWSegwitAddressDescriptionPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWSegwitAddress>)>();

  /// Returns the human-readable part.
  ///
  /// \param address Non-null pointer to a Segwit Address
  /// \return the HRP part of the given address
  TWHRP TWSegwitAddressHRP(
    ffi.Pointer<TWSegwitAddress> address,
  ) {
    return TWHRP.fromValue(_TWSegwitAddressHRP(
      address,
    ));
  }

  late final _TWSegwitAddressHRPPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<TWSegwitAddress>)>>('TWSegwitAddressHRP');
  late final _TWSegwitAddressHRP = _TWSegwitAddressHRPPtr.asFunction<
      int Function(ffi.Pointer<TWSegwitAddress>)>();

  /// Returns the human-readable part.
  ///
  /// \param address Non-null pointer to a Segwit Address
  /// \return returns the witness version of the given segwit address
  int TWSegwitAddressWitnessVersion(
    ffi.Pointer<TWSegwitAddress> address,
  ) {
    return _TWSegwitAddressWitnessVersion(
      address,
    );
  }

  late final _TWSegwitAddressWitnessVersionPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<TWSegwitAddress>)>>(
      'TWSegwitAddressWitnessVersion');
  late final _TWSegwitAddressWitnessVersion = _TWSegwitAddressWitnessVersionPtr
      .asFunction<int Function(ffi.Pointer<TWSegwitAddress>)>();

  /// Returns the witness program
  ///
  /// \param address Non-null pointer to a Segwit Address
  /// \return returns the witness data of the given segwit address as a non-null pointer block of data
  ffi.Pointer<TWData1> TWSegwitAddressWitnessProgram(
    ffi.Pointer<TWSegwitAddress> address,
  ) {
    return _TWSegwitAddressWitnessProgram(
      address,
    );
  }

  late final _TWSegwitAddressWitnessProgramPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWSegwitAddress>)>>('TWSegwitAddressWitnessProgram');
  late final _TWSegwitAddressWitnessProgram =
      _TWSegwitAddressWitnessProgramPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWSegwitAddress>)>();

  /// Sign a typed message EIP-712 V4.
  ///
  /// \param privateKey: the private key used for signing
  /// \param messageJson: A custom typed data message in json
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString> TWEthereumMessageSignerSignTypedMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString> messageJson,
  ) {
    return _TWEthereumMessageSignerSignTypedMessage(
      privateKey,
      messageJson,
    );
  }

  late final _TWEthereumMessageSignerSignTypedMessagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(
                  ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString>)>>(
      'TWEthereumMessageSignerSignTypedMessage');
  late final _TWEthereumMessageSignerSignTypedMessage =
      _TWEthereumMessageSignerSignTypedMessagePtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString>)>();

  /// Sign a typed message EIP-712 V4 with EIP-155 replay attack protection.
  ///
  /// \param privateKey: the private key used for signing
  /// \param messageJson: A custom typed data message in json
  /// \param chainId: chainId for eip-155 protection
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned or invalid chainId error message. Returned object needs to be deleted after use.
  ffi.Pointer<TWString> TWEthereumMessageSignerSignTypedMessageEip155(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString> messageJson,
    int chainId,
  ) {
    return _TWEthereumMessageSignerSignTypedMessageEip155(
      privateKey,
      messageJson,
      chainId,
    );
  }

  late final _TWEthereumMessageSignerSignTypedMessageEip155Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString>,
              ffi.Int)>>('TWEthereumMessageSignerSignTypedMessageEip155');
  late final _TWEthereumMessageSignerSignTypedMessageEip155 =
      _TWEthereumMessageSignerSignTypedMessageEip155Ptr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString>, int)>();

  /// Sign a message.
  ///
  /// \param privateKey: the private key used for signing
  /// \param message: A custom message which is input to the signing.
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString> TWEthereumMessageSignerSignMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString> message,
  ) {
    return _TWEthereumMessageSignerSignMessage(
      privateKey,
      message,
    );
  }

  late final _TWEthereumMessageSignerSignMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString>)>>('TWEthereumMessageSignerSignMessage');
  late final _TWEthereumMessageSignerSignMessage =
      _TWEthereumMessageSignerSignMessagePtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString>)>();

  /// Sign a message with Immutable X msg type.
  ///
  /// \param privateKey: the private key used for signing
  /// \param message: A custom message which is input to the signing.
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString> TWEthereumMessageSignerSignMessageImmutableX(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString> message,
  ) {
    return _TWEthereumMessageSignerSignMessageImmutableX(
      privateKey,
      message,
    );
  }

  late final _TWEthereumMessageSignerSignMessageImmutableXPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(
                  ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString>)>>(
      'TWEthereumMessageSignerSignMessageImmutableX');
  late final _TWEthereumMessageSignerSignMessageImmutableX =
      _TWEthereumMessageSignerSignMessageImmutableXPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString>)>();

  /// Sign a message with Eip-155 msg type.
  ///
  /// \param privateKey: the private key used for signing
  /// \param message: A custom message which is input to the signing.
  /// \param chainId: chainId for eip-155 protection
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString> TWEthereumMessageSignerSignMessageEip155(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString> message,
    int chainId,
  ) {
    return _TWEthereumMessageSignerSignMessageEip155(
      privateKey,
      message,
      chainId,
    );
  }

  late final _TWEthereumMessageSignerSignMessageEip155Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString>,
              ffi.Int)>>('TWEthereumMessageSignerSignMessageEip155');
  late final _TWEthereumMessageSignerSignMessageEip155 =
      _TWEthereumMessageSignerSignMessageEip155Ptr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString>, int)>();

  /// Verify signature for a message.
  ///
  /// \param pubKey: pubKey that will verify and recover the message from the signature
  /// \param message: the message signed (without prefix)
  /// \param signature: in Hex-encoded form.
  /// \returns false on any invalid input (does not throw), true if the message can be recovered from the signature
  bool TWEthereumMessageSignerVerifyMessage(
    ffi.Pointer<TWPublicKey> pubKey,
    ffi.Pointer<TWString> message,
    ffi.Pointer<TWString> signature,
  ) {
    return _TWEthereumMessageSignerVerifyMessage(
      pubKey,
      message,
      signature,
    );
  }

  late final _TWEthereumMessageSignerVerifyMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWEthereumMessageSignerVerifyMessage');
  late final _TWEthereumMessageSignerVerifyMessage =
      _TWEthereumMessageSignerVerifyMessagePtr.asFunction<
          bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>();

  /// Decodes a transaction from a binary representation.
  ///
  /// \param coin coin type.
  /// \param encodedTx encoded transaction data.
  /// \return serialized protobuf message specific for the given coin.
  ffi.Pointer<TWData1> TWTransactionDecoderDecode(
    TWCoinType coinType,
    ffi.Pointer<TWData1> encodedTx,
  ) {
    return _TWTransactionDecoderDecode(
      coinType.value,
      encodedTx,
    );
  }

  late final _TWTransactionDecoderDecodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.UnsignedInt,
              ffi.Pointer<TWData1>)>>('TWTransactionDecoderDecode');
  late final _TWTransactionDecoderDecode = _TWTransactionDecoderDecodePtr
      .asFunction<ffi.Pointer<TWData1> Function(int, ffi.Pointer<TWData1>)>();

  /// Compares two addresses for equality.
  ///
  /// \param lhs The first address to compare.
  /// \param rhs The second address to compare.
  /// \return bool indicating the addresses are equal.
  bool TWBitcoinAddressEqual(
    ffi.Pointer<TWBitcoinAddress> lhs,
    ffi.Pointer<TWBitcoinAddress> rhs,
  ) {
    return _TWBitcoinAddressEqual(
      lhs,
      rhs,
    );
  }

  late final _TWBitcoinAddressEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWBitcoinAddress>,
              ffi.Pointer<TWBitcoinAddress>)>>('TWBitcoinAddressEqual');
  late final _TWBitcoinAddressEqual = _TWBitcoinAddressEqualPtr.asFunction<
      bool Function(
          ffi.Pointer<TWBitcoinAddress>, ffi.Pointer<TWBitcoinAddress>)>();

  /// Determines if the data is a valid Bitcoin address.
  ///
  /// \param data data to validate.
  /// \return bool indicating if the address data is valid.
  bool TWBitcoinAddressIsValid(
    ffi.Pointer<TWData> data,
  ) {
    return _TWBitcoinAddressIsValid(
      data,
    );
  }

  late final _TWBitcoinAddressIsValidPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWData>)>>(
          'TWBitcoinAddressIsValid');
  late final _TWBitcoinAddressIsValid = _TWBitcoinAddressIsValidPtr.asFunction<
      bool Function(ffi.Pointer<TWData>)>();

  /// Determines if the string is a valid Bitcoin address.
  ///
  /// \param string string to validate.
  /// \return bool indicating if the address string is valid.
  bool TWBitcoinAddressIsValidString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWBitcoinAddressIsValidString(
      string,
    );
  }

  late final _TWBitcoinAddressIsValidStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString>)>>(
          'TWBitcoinAddressIsValidString');
  late final _TWBitcoinAddressIsValidString = _TWBitcoinAddressIsValidStringPtr
      .asFunction<bool Function(ffi.Pointer<TWString>)>();

  /// Initializes an address from a Base58 sring. Must be deleted with TWBitcoinAddressDelete after use.
  ///
  /// \param string Base58 string to initialize the address from.
  /// \return TWBitcoinAddress pointer or nullptr if string is invalid.
  ffi.Pointer<TWBitcoinAddress> TWBitcoinAddressCreateWithString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWBitcoinAddressCreateWithString(
      string,
    );
  }

  late final _TWBitcoinAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinAddress> Function(
              ffi.Pointer<TWString>)>>('TWBitcoinAddressCreateWithString');
  late final _TWBitcoinAddressCreateWithString =
      _TWBitcoinAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWBitcoinAddress> Function(ffi.Pointer<TWString>)>();

  /// Initializes an address from raw data.
  ///
  /// \param data Raw data to initialize the address from. Must be deleted with TWBitcoinAddressDelete after use.
  /// \return TWBitcoinAddress pointer or nullptr if data is invalid.
  ffi.Pointer<TWBitcoinAddress> TWBitcoinAddressCreateWithData(
    ffi.Pointer<TWData> data,
  ) {
    return _TWBitcoinAddressCreateWithData(
      data,
    );
  }

  late final _TWBitcoinAddressCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinAddress> Function(
              ffi.Pointer<TWData>)>>('TWBitcoinAddressCreateWithData');
  late final _TWBitcoinAddressCreateWithData =
      _TWBitcoinAddressCreateWithDataPtr.asFunction<
          ffi.Pointer<TWBitcoinAddress> Function(ffi.Pointer<TWData>)>();

  /// Initializes an address from a public key and a prefix byte.
  ///
  /// \param publicKey Public key to initialize the address from.
  /// \param prefix Prefix byte (p2pkh, p2sh, etc).
  /// \return TWBitcoinAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWBitcoinAddress> TWBitcoinAddressCreateWithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    int prefix,
  ) {
    return _TWBitcoinAddressCreateWithPublicKey(
      publicKey,
      prefix,
    );
  }

  late final _TWBitcoinAddressCreateWithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinAddress> Function(ffi.Pointer<TWPublicKey>,
              ffi.Uint8)>>('TWBitcoinAddressCreateWithPublicKey');
  late final _TWBitcoinAddressCreateWithPublicKey =
      _TWBitcoinAddressCreateWithPublicKeyPtr.asFunction<
          ffi.Pointer<TWBitcoinAddress> Function(
              ffi.Pointer<TWPublicKey>, int)>();

  /// Deletes a legacy Bitcoin address.
  ///
  /// \param address Address to delete.
  void TWBitcoinAddressDelete(
    ffi.Pointer<TWBitcoinAddress> address,
  ) {
    return _TWBitcoinAddressDelete(
      address,
    );
  }

  late final _TWBitcoinAddressDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWBitcoinAddress>)>>(
      'TWBitcoinAddressDelete');
  late final _TWBitcoinAddressDelete = _TWBitcoinAddressDeletePtr.asFunction<
      void Function(ffi.Pointer<TWBitcoinAddress>)>();

  /// Returns the address in Base58 string representation.
  ///
  /// \param address Address to get the string representation of.
  ffi.Pointer<TWString> TWBitcoinAddressDescription(
    ffi.Pointer<TWBitcoinAddress> address,
  ) {
    return _TWBitcoinAddressDescription(
      address,
    );
  }

  late final _TWBitcoinAddressDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWBitcoinAddress>)>>('TWBitcoinAddressDescription');
  late final _TWBitcoinAddressDescription =
      _TWBitcoinAddressDescriptionPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWBitcoinAddress>)>();

  /// Returns the address prefix.
  ///
  /// \param address Address to get the prefix of.
  int TWBitcoinAddressPrefix(
    ffi.Pointer<TWBitcoinAddress> address,
  ) {
    return _TWBitcoinAddressPrefix(
      address,
    );
  }

  late final _TWBitcoinAddressPrefixPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint8 Function(ffi.Pointer<TWBitcoinAddress>)>>(
      'TWBitcoinAddressPrefix');
  late final _TWBitcoinAddressPrefix = _TWBitcoinAddressPrefixPtr.asFunction<
      int Function(ffi.Pointer<TWBitcoinAddress>)>();

  /// Returns the key hash data.
  ///
  /// \param address Address to get the keyhash data of.
  ffi.Pointer<TWData> TWBitcoinAddressKeyhash(
    ffi.Pointer<TWBitcoinAddress> address,
  ) {
    return _TWBitcoinAddressKeyhash(
      address,
    );
  }

  late final _TWBitcoinAddressKeyhashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWBitcoinAddress>)>>('TWBitcoinAddressKeyhash');
  late final _TWBitcoinAddressKeyhash = _TWBitcoinAddressKeyhashPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinAddress>)>();

  /// Compares two addresses for equality.
  ///
  /// \param lhs The first address to compare.
  /// \param rhs The second address to compare.
  /// \return bool indicating the addresses are equal.
  bool TWAnyAddressEqual(
    ffi.Pointer<TWAnyAddress> lhs,
    ffi.Pointer<TWAnyAddress> rhs,
  ) {
    return _TWAnyAddressEqual(
      lhs,
      rhs,
    );
  }

  late final _TWAnyAddressEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWAnyAddress>,
              ffi.Pointer<TWAnyAddress>)>>('TWAnyAddressEqual');
  late final _TWAnyAddressEqual = _TWAnyAddressEqualPtr.asFunction<
      bool Function(ffi.Pointer<TWAnyAddress>, ffi.Pointer<TWAnyAddress>)>();

  /// Determines if the string is a valid Any address.
  ///
  /// \param string address to validate.
  /// \param coin coin type of the address.
  /// \return bool indicating if the address is valid.
  bool TWAnyAddressIsValid(
    ffi.Pointer<TWString1> string,
    TWCoinType coin,
  ) {
    return _TWAnyAddressIsValid(
      string,
      coin.value,
    );
  }

  late final _TWAnyAddressIsValidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<TWString1>, ffi.UnsignedInt)>>('TWAnyAddressIsValid');
  late final _TWAnyAddressIsValid = _TWAnyAddressIsValidPtr.asFunction<
      bool Function(ffi.Pointer<TWString1>, int)>();

  /// Determines if the string is a valid Any address with the given hrp.
  ///
  /// \param string address to validate.
  /// \param coin coin type of the address.
  /// \param hrp explicit given hrp of the given address.
  /// \return bool indicating if the address is valid.
  bool TWAnyAddressIsValidBech32(
    ffi.Pointer<TWString1> string,
    TWCoinType coin,
    ffi.Pointer<TWString1> hrp,
  ) {
    return _TWAnyAddressIsValidBech32(
      string,
      coin.value,
      hrp,
    );
  }

  late final _TWAnyAddressIsValidBech32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWString1>, ffi.UnsignedInt,
              ffi.Pointer<TWString1>)>>('TWAnyAddressIsValidBech32');
  late final _TWAnyAddressIsValidBech32 =
      _TWAnyAddressIsValidBech32Ptr.asFunction<
          bool Function(ffi.Pointer<TWString1>, int, ffi.Pointer<TWString1>)>();

  /// Determines if the string is a valid Any address with the given SS58 network prefix.
  ///
  /// \param string address to validate.
  /// \param coin coin type of the address.
  /// \param ss58Prefix ss58Prefix of the given address.
  /// \return bool indicating if the address is valid.
  bool TWAnyAddressIsValidSS58(
    ffi.Pointer<TWString1> string,
    TWCoinType coin,
    int ss58Prefix,
  ) {
    return _TWAnyAddressIsValidSS58(
      string,
      coin.value,
      ss58Prefix,
    );
  }

  late final _TWAnyAddressIsValidSS58Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWString1>, ffi.UnsignedInt,
              ffi.Uint32)>>('TWAnyAddressIsValidSS58');
  late final _TWAnyAddressIsValidSS58 = _TWAnyAddressIsValidSS58Ptr.asFunction<
      bool Function(ffi.Pointer<TWString1>, int, int)>();

  /// Creates an address from a string representation and a coin type. Must be deleted with TWAnyAddressDelete after use.
  ///
  /// \param string address to create.
  /// \param coin coin type of the address.
  /// \return TWAnyAddress pointer or nullptr if address and coin are invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithString(
    ffi.Pointer<TWString1> string,
    TWCoinType coin,
  ) {
    return _TWAnyAddressCreateWithString(
      string,
      coin.value,
    );
  }

  late final _TWAnyAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString1>,
              ffi.UnsignedInt)>>('TWAnyAddressCreateWithString');
  late final _TWAnyAddressCreateWithString =
      _TWAnyAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString1>, int)>();

  /// Creates an bech32 address from a string representation, a coin type and the given hrp. Must be deleted with TWAnyAddressDelete after use.
  ///
  /// \param string address to create.
  /// \param coin coin type of the address.
  /// \param hrp hrp of the address.
  /// \return TWAnyAddress pointer or nullptr if address and coin are invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateBech32(
    ffi.Pointer<TWString1> string,
    TWCoinType coin,
    ffi.Pointer<TWString1> hrp,
  ) {
    return _TWAnyAddressCreateBech32(
      string,
      coin.value,
      hrp,
    );
  }

  late final _TWAnyAddressCreateBech32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWString1>,
              ffi.UnsignedInt,
              ffi.Pointer<TWString1>)>>('TWAnyAddressCreateBech32');
  late final _TWAnyAddressCreateBech32 =
      _TWAnyAddressCreateBech32Ptr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWString1>, int, ffi.Pointer<TWString1>)>();

  /// Creates an SS58 address from a string representation, a coin type and the given ss58Prefix. Must be deleted with TWAnyAddressDelete after use.
  ///
  /// \param string address to create.
  /// \param coin coin type of the address.
  /// \param ss58Prefix ss58Prefix of the SS58 address.
  /// \return TWAnyAddress pointer or nullptr if address and coin are invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateSS58(
    ffi.Pointer<TWString1> string,
    TWCoinType coin,
    int ss58Prefix,
  ) {
    return _TWAnyAddressCreateSS58(
      string,
      coin.value,
      ss58Prefix,
    );
  }

  late final _TWAnyAddressCreateSS58Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString1>,
              ffi.UnsignedInt, ffi.Uint32)>>('TWAnyAddressCreateSS58');
  late final _TWAnyAddressCreateSS58 = _TWAnyAddressCreateSS58Ptr.asFunction<
      ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString1>, int, int)>();

  /// Creates an address from a public key.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param coin coin type of the address.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    TWCoinType coin,
  ) {
    return _TWAnyAddressCreateWithPublicKey(
      publicKey,
      coin.value,
    );
  }

  late final _TWAnyAddressCreateWithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>,
              ffi.UnsignedInt)>>('TWAnyAddressCreateWithPublicKey');
  late final _TWAnyAddressCreateWithPublicKey =
      _TWAnyAddressCreateWithPublicKeyPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>, int)>();

  /// Creates an address from a public key and derivation option.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param coin coin type of the address.
  /// \param derivation the custom derivation to use.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithPublicKeyDerivation(
    ffi.Pointer<TWPublicKey> publicKey,
    TWCoinType coin,
    TWDerivation derivation,
  ) {
    return _TWAnyAddressCreateWithPublicKeyDerivation(
      publicKey,
      coin.value,
      derivation.value,
    );
  }

  late final _TWAnyAddressCreateWithPublicKeyDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWAnyAddressCreateWithPublicKeyDerivation');
  late final _TWAnyAddressCreateWithPublicKeyDerivation =
      _TWAnyAddressCreateWithPublicKeyDerivationPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>, int, int)>();

  /// Creates an bech32 address from a public key and a given hrp.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param coin coin type of the address.
  /// \param hrp hrp of the address.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateBech32WithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    TWCoinType coin,
    ffi.Pointer<TWString1> hrp,
  ) {
    return _TWAnyAddressCreateBech32WithPublicKey(
      publicKey,
      coin.value,
      hrp,
    );
  }

  late final _TWAnyAddressCreateBech32WithPublicKeyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>,
                  ffi.UnsignedInt, ffi.Pointer<TWString1>)>>(
      'TWAnyAddressCreateBech32WithPublicKey');
  late final _TWAnyAddressCreateBech32WithPublicKey =
      _TWAnyAddressCreateBech32WithPublicKeyPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>, int, ffi.Pointer<TWString1>)>();

  /// Creates an SS58 address from a public key and a given ss58Prefix.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param coin coin type of the address.
  /// \param ss58Prefix ss58Prefix of the SS58 address.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateSS58WithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    TWCoinType coin,
    int ss58Prefix,
  ) {
    return _TWAnyAddressCreateSS58WithPublicKey(
      publicKey,
      coin.value,
      ss58Prefix,
    );
  }

  late final _TWAnyAddressCreateSS58WithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>,
              ffi.UnsignedInt,
              ffi.Uint32)>>('TWAnyAddressCreateSS58WithPublicKey');
  late final _TWAnyAddressCreateSS58WithPublicKey =
      _TWAnyAddressCreateSS58WithPublicKeyPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>, int, int)>();

  /// Creates a Filecoin address from a public key and a given address type.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param filecoinAddressType Filecoin address type.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithPublicKeyFilecoinAddressType(
    ffi.Pointer<TWPublicKey> publicKey,
    TWFilecoinAddressType filecoinAddressType,
  ) {
    return _TWAnyAddressCreateWithPublicKeyFilecoinAddressType(
      publicKey,
      filecoinAddressType.value,
    );
  }

  late final _TWAnyAddressCreateWithPublicKeyFilecoinAddressTypePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWAnyAddress> Function(
                  ffi.Pointer<TWPublicKey>, ffi.UnsignedInt)>>(
      'TWAnyAddressCreateWithPublicKeyFilecoinAddressType');
  late final _TWAnyAddressCreateWithPublicKeyFilecoinAddressType =
      _TWAnyAddressCreateWithPublicKeyFilecoinAddressTypePtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>, int)>();

  /// Creates a Firo address from a public key and a given address type.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param firoAddressType Firo address type.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithPublicKeyFiroAddressType(
    ffi.Pointer<TWPublicKey> publicKey,
    TWFiroAddressType firoAddressType,
  ) {
    return _TWAnyAddressCreateWithPublicKeyFiroAddressType(
      publicKey,
      firoAddressType.value,
    );
  }

  late final _TWAnyAddressCreateWithPublicKeyFiroAddressTypePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWAnyAddress> Function(
                  ffi.Pointer<TWPublicKey>, ffi.UnsignedInt)>>(
      'TWAnyAddressCreateWithPublicKeyFiroAddressType');
  late final _TWAnyAddressCreateWithPublicKeyFiroAddressType =
      _TWAnyAddressCreateWithPublicKeyFiroAddressTypePtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>, int)>();

  /// Deletes an address.
  ///
  /// \param address address to delete.
  void TWAnyAddressDelete(
    ffi.Pointer<TWAnyAddress> address,
  ) {
    return _TWAnyAddressDelete(
      address,
    );
  }

  late final _TWAnyAddressDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWAnyAddress>)>>(
          'TWAnyAddressDelete');
  late final _TWAnyAddressDelete = _TWAnyAddressDeletePtr.asFunction<
      void Function(ffi.Pointer<TWAnyAddress>)>();

  /// Returns the address string representation.
  ///
  /// \param address address to get the string representation of.
  ffi.Pointer<TWString1> TWAnyAddressDescription(
    ffi.Pointer<TWAnyAddress> address,
  ) {
    return _TWAnyAddressDescription(
      address,
    );
  }

  late final _TWAnyAddressDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWAnyAddress>)>>('TWAnyAddressDescription');
  late final _TWAnyAddressDescription = _TWAnyAddressDescriptionPtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWAnyAddress>)>();

  /// Returns coin type of address.
  ///
  /// \param address address to get the coin type of.
  TWCoinType TWAnyAddressCoin(
    ffi.Pointer<TWAnyAddress> address,
  ) {
    return TWCoinType.fromValue(_TWAnyAddressCoin(
      address,
    ));
  }

  late final _TWAnyAddressCoinPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<TWAnyAddress>)>>(
      'TWAnyAddressCoin');
  late final _TWAnyAddressCoin = _TWAnyAddressCoinPtr.asFunction<
      int Function(ffi.Pointer<TWAnyAddress>)>();

  /// Returns underlaying data (public key or key hash)
  ///
  /// \param address address to get the data of.
  ffi.Pointer<TWData1> TWAnyAddressData(
    ffi.Pointer<TWAnyAddress> address,
  ) {
    return _TWAnyAddressData(
      address,
    );
  }

  late final _TWAnyAddressDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWAnyAddress>)>>('TWAnyAddressData');
  late final _TWAnyAddressData = _TWAnyAddressDataPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWAnyAddress>)>();

  /// Parses the given ECDSA signature from ASN.1 DER encoded bytes.
  ///
  /// \param encoded The ASN.1 DER encoded signature.
  /// \return The ECDSA signature standard binary representation: RS, where R - 32 byte array, S - 32 byte array.
  ffi.Pointer<TWData> TWAsnParserEcdsaSignatureFromDer(
    ffi.Pointer<TWData> encoded,
  ) {
    return _TWAsnParserEcdsaSignatureFromDer(
      encoded,
    );
  }

  late final _TWAsnParserEcdsaSignatureFromDerPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWAsnParserEcdsaSignatureFromDer');
  late final _TWAsnParserEcdsaSignatureFromDer =
      _TWAsnParserEcdsaSignatureFromDerPtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Builds a THORChainSwap transaction input.
  ///
  /// \param input The serialized data of SwapInput.
  /// \return The serialized data of SwapOutput.
  ffi.Pointer<TWData> TWTHORChainSwapBuildSwap(
    ffi.Pointer<TWData> input,
  ) {
    return _TWTHORChainSwapBuildSwap(
      input,
    );
  }

  late final _TWTHORChainSwapBuildSwapPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWTHORChainSwapBuildSwap');
  late final _TWTHORChainSwapBuildSwap = _TWTHORChainSwapBuildSwapPtr
      .asFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Encodes data as a Base58 string, including the checksum.
  ///
  /// \param data The data to encode.
  /// \return the encoded Base58 string with checksum.
  ffi.Pointer<TWString> TWBase58Encode(
    ffi.Pointer<TWData> data,
  ) {
    return _TWBase58Encode(
      data,
    );
  }

  late final _TWBase58EncodePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>>(
      'TWBase58Encode');
  late final _TWBase58Encode = _TWBase58EncodePtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>();

  /// Encodes data as a Base58 string, not including the checksum.
  ///
  /// \param data The data to encode.
  /// \return then encoded Base58 string without checksum.
  ffi.Pointer<TWString> TWBase58EncodeNoCheck(
    ffi.Pointer<TWData> data,
  ) {
    return _TWBase58EncodeNoCheck(
      data,
    );
  }

  late final _TWBase58EncodeNoCheckPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>>(
      'TWBase58EncodeNoCheck');
  late final _TWBase58EncodeNoCheck = _TWBase58EncodeNoCheckPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>();

  /// Decodes a Base58 string, checking the checksum. Returns null if the string is not a valid Base58 string.
  ///
  /// \param string The Base58 string to decode.
  /// \return the decoded data, empty if the string is not a valid Base58 string with checksum.
  ffi.Pointer<TWData> TWBase58Decode(
    ffi.Pointer<TWString> string,
  ) {
    return _TWBase58Decode(
      string,
    );
  }

  late final _TWBase58DecodePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>>(
      'TWBase58Decode');
  late final _TWBase58Decode = _TWBase58DecodePtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>();

  /// Decodes a Base58 string, w/o checking the checksum. Returns null if the string is not a valid Base58 string.
  ///
  /// \param string The Base58 string to decode.
  /// \return the decoded data, empty if the string is not a valid Base58 string without checksum.
  ffi.Pointer<TWData> TWBase58DecodeNoCheck(
    ffi.Pointer<TWString> string,
  ) {
    return _TWBase58DecodeNoCheck(
      string,
    );
  }

  late final _TWBase58DecodeNoCheckPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>>(
      'TWBase58DecodeNoCheck');
  late final _TWBase58DecodeNoCheck = _TWBase58DecodeNoCheckPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>();

  /// Calculates the minimum ADA amount needed for a UTXO.
  ///
  /// \deprecated consider using `TWCardanoOutputMinAdaAmount` instead.
  /// \see reference https://docs.cardano.org/native-tokens/minimum-ada-value-requirement
  /// \param tokenBundle serialized data of TW.Cardano.Proto.TokenBundle.
  /// \return the minimum ADA amount.
  int TWCardanoMinAdaAmount(
    ffi.Pointer<TWData> tokenBundle,
  ) {
    return _TWCardanoMinAdaAmount(
      tokenBundle,
    );
  }

  late final _TWCardanoMinAdaAmountPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<TWData>)>>(
          'TWCardanoMinAdaAmount');
  late final _TWCardanoMinAdaAmount =
      _TWCardanoMinAdaAmountPtr.asFunction<int Function(ffi.Pointer<TWData>)>();

  /// Calculates the minimum ADA amount needed for an output.
  ///
  /// \see reference https://docs.cardano.org/native-tokens/minimum-ada-value-requirement
  /// \param toAddress valid destination address, as string.
  /// \param tokenBundle serialized data of TW.Cardano.Proto.TokenBundle.
  /// \param coinsPerUtxoByte cost per one byte of a serialized UTXO (Base-10 decimal string).
  /// \return the minimum ADA amount (Base-10 decimal string).
  ffi.Pointer<TWString> TWCardanoOutputMinAdaAmount(
    ffi.Pointer<TWString> toAddress,
    ffi.Pointer<TWData> tokenBundle,
    ffi.Pointer<TWString> coinsPerUtxoByte,
  ) {
    return _TWCardanoOutputMinAdaAmount(
      toAddress,
      tokenBundle,
      coinsPerUtxoByte,
    );
  }

  late final _TWCardanoOutputMinAdaAmountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.Pointer<TWString>)>>('TWCardanoOutputMinAdaAmount');
  late final _TWCardanoOutputMinAdaAmount =
      _TWCardanoOutputMinAdaAmountPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWData>, ffi.Pointer<TWString>)>();

  /// Return the staking address associated to (contained in) this address. Must be a Base address.
  /// Empty string is returned on error. Result must be freed.
  /// \param baseAddress A valid base address, as string.
  /// \return the associated staking (reward) address, as string, or empty string on error.
  ffi.Pointer<TWString> TWCardanoGetStakingAddress(
    ffi.Pointer<TWString> baseAddress,
  ) {
    return _TWCardanoGetStakingAddress(
      baseAddress,
    );
  }

  late final _TWCardanoGetStakingAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>)>>('TWCardanoGetStakingAddress');
  late final _TWCardanoGetStakingAddress = _TWCardanoGetStakingAddressPtr
      .asFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>();

  /// Return the legacy(byron) address.
  /// \param publicKey A valid public key with TWPublicKeyTypeED25519Cardano type.
  /// \return the legacy(byron) address, as string, or empty string on error.
  ffi.Pointer<TWString> TWCardanoGetByronAddress(
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return _TWCardanoGetByronAddress(
      publicKey,
    );
  }

  late final _TWCardanoGetByronAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPublicKey>)>>('TWCardanoGetByronAddress');
  late final _TWCardanoGetByronAddress = _TWCardanoGetByronAddressPtr
      .asFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWPublicKey>)>();

  /// Creates a new Index with a value and hardened flag.
  /// Must be deleted with TWDerivationPathIndexDelete after use.
  ///
  /// \param value Index value
  /// \param hardened Indicates if the Index is hardened.
  /// \return A new Index.
  ffi.Pointer<TWDerivationPathIndex> TWDerivationPathIndexCreate(
    int value,
    bool hardened,
  ) {
    return _TWDerivationPathIndexCreate(
      value,
      hardened,
    );
  }

  late final _TWDerivationPathIndexCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDerivationPathIndex> Function(
              ffi.Uint32, ffi.Bool)>>('TWDerivationPathIndexCreate');
  late final _TWDerivationPathIndexCreate = _TWDerivationPathIndexCreatePtr
      .asFunction<ffi.Pointer<TWDerivationPathIndex> Function(int, bool)>();

  /// Deletes an Index.
  ///
  /// \param index Index to delete.
  void TWDerivationPathIndexDelete(
    ffi.Pointer<TWDerivationPathIndex> index,
  ) {
    return _TWDerivationPathIndexDelete(
      index,
    );
  }

  late final _TWDerivationPathIndexDeletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<TWDerivationPathIndex>)>>(
      'TWDerivationPathIndexDelete');
  late final _TWDerivationPathIndexDelete = _TWDerivationPathIndexDeletePtr
      .asFunction<void Function(ffi.Pointer<TWDerivationPathIndex>)>();

  /// Returns numeric value of an Index.
  ///
  /// \param index Index to get the numeric value of.
  int TWDerivationPathIndexValue(
    ffi.Pointer<TWDerivationPathIndex> index,
  ) {
    return _TWDerivationPathIndexValue(
      index,
    );
  }

  late final _TWDerivationPathIndexValuePtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<TWDerivationPathIndex>)>>(
      'TWDerivationPathIndexValue');
  late final _TWDerivationPathIndexValue = _TWDerivationPathIndexValuePtr
      .asFunction<int Function(ffi.Pointer<TWDerivationPathIndex>)>();

  /// Returns hardened flag of an Index.
  ///
  /// \param index Index to get hardened flag.
  /// \return true if hardened, false otherwise.
  bool TWDerivationPathIndexHardened(
    ffi.Pointer<TWDerivationPathIndex> index,
  ) {
    return _TWDerivationPathIndexHardened(
      index,
    );
  }

  late final _TWDerivationPathIndexHardenedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<TWDerivationPathIndex>)>>(
      'TWDerivationPathIndexHardened');
  late final _TWDerivationPathIndexHardened = _TWDerivationPathIndexHardenedPtr
      .asFunction<bool Function(ffi.Pointer<TWDerivationPathIndex>)>();

  /// Returns the string description of a derivation path index.
  ///
  /// \param path Index to get the address of.
  /// \return The string description of the derivation path index.
  ffi.Pointer<TWString1> TWDerivationPathIndexDescription(
    ffi.Pointer<TWDerivationPathIndex> index,
  ) {
    return _TWDerivationPathIndexDescription(
      index,
    );
  }

  late final _TWDerivationPathIndexDescriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString1> Function(
                  ffi.Pointer<TWDerivationPathIndex>)>>(
      'TWDerivationPathIndexDescription');
  late final _TWDerivationPathIndexDescription =
      _TWDerivationPathIndexDescriptionPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWDerivationPathIndex>)>();

  /// Compares two addresses for equality.
  ///
  /// \param lhs left non-null pointer to a Ripple Address
  /// \param rhs right non-null pointer to a Ripple Address
  /// \return true if both address are equal, false otherwise
  bool TWRippleXAddressEqual(
    ffi.Pointer<TWRippleXAddress> lhs,
    ffi.Pointer<TWRippleXAddress> rhs,
  ) {
    return _TWRippleXAddressEqual(
      lhs,
      rhs,
    );
  }

  late final _TWRippleXAddressEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWRippleXAddress>,
              ffi.Pointer<TWRippleXAddress>)>>('TWRippleXAddressEqual');
  late final _TWRippleXAddressEqual = _TWRippleXAddressEqualPtr.asFunction<
      bool Function(
          ffi.Pointer<TWRippleXAddress>, ffi.Pointer<TWRippleXAddress>)>();

  /// Determines if the string is a valid Ripple address.
  ///
  /// \param string Non-null pointer to a string that represent the Ripple Address to be checked
  /// \return true if the given address is a valid Ripple address, false otherwise
  bool TWRippleXAddressIsValidString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWRippleXAddressIsValidString(
      string,
    );
  }

  late final _TWRippleXAddressIsValidStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString1>)>>(
          'TWRippleXAddressIsValidString');
  late final _TWRippleXAddressIsValidString = _TWRippleXAddressIsValidStringPtr
      .asFunction<bool Function(ffi.Pointer<TWString1>)>();

  /// Creates an address from a string representation.
  ///
  /// \param string Non-null pointer to a string that should be a valid ripple address
  /// \note Should be deleted with \TWRippleXAddressDelete
  /// \return Null pointer if the given string is an invalid ripple address, pointer to a Ripple address otherwise
  ffi.Pointer<TWRippleXAddress> TWRippleXAddressCreateWithString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWRippleXAddressCreateWithString(
      string,
    );
  }

  late final _TWRippleXAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWRippleXAddress> Function(
              ffi.Pointer<TWString1>)>>('TWRippleXAddressCreateWithString');
  late final _TWRippleXAddressCreateWithString =
      _TWRippleXAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWRippleXAddress> Function(ffi.Pointer<TWString1>)>();

  /// Creates an address from a public key and destination tag.
  ///
  /// \param publicKey Non-null pointer to a public key
  /// \param tag valid ripple destination tag (1-10)
  /// \note Should be deleted with \TWRippleXAddressDelete
  /// \return Non-null pointer to a Ripple Address
  ffi.Pointer<TWRippleXAddress> TWRippleXAddressCreateWithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    int tag,
  ) {
    return _TWRippleXAddressCreateWithPublicKey(
      publicKey,
      tag,
    );
  }

  late final _TWRippleXAddressCreateWithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWRippleXAddress> Function(ffi.Pointer<TWPublicKey>,
              ffi.Uint32)>>('TWRippleXAddressCreateWithPublicKey');
  late final _TWRippleXAddressCreateWithPublicKey =
      _TWRippleXAddressCreateWithPublicKeyPtr.asFunction<
          ffi.Pointer<TWRippleXAddress> Function(
              ffi.Pointer<TWPublicKey>, int)>();

  /// Delete the given ripple address
  ///
  /// \param address Non-null pointer to a Ripple Address
  void TWRippleXAddressDelete(
    ffi.Pointer<TWRippleXAddress> address,
  ) {
    return _TWRippleXAddressDelete(
      address,
    );
  }

  late final _TWRippleXAddressDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWRippleXAddress>)>>(
      'TWRippleXAddressDelete');
  late final _TWRippleXAddressDelete = _TWRippleXAddressDeletePtr.asFunction<
      void Function(ffi.Pointer<TWRippleXAddress>)>();

  /// Returns the address string representation.
  ///
  /// \param address Non-null pointer to a Ripple Address
  /// \return Non-null pointer to the ripple address string representation
  ffi.Pointer<TWString1> TWRippleXAddressDescription(
    ffi.Pointer<TWRippleXAddress> address,
  ) {
    return _TWRippleXAddressDescription(
      address,
    );
  }

  late final _TWRippleXAddressDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWRippleXAddress>)>>('TWRippleXAddressDescription');
  late final _TWRippleXAddressDescription =
      _TWRippleXAddressDescriptionPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWRippleXAddress>)>();

  /// Returns the destination tag.
  ///
  /// \param address Non-null pointer to a Ripple Address
  /// \return The destination tag of the given Ripple Address (1-10)
  int TWRippleXAddressTag(
    ffi.Pointer<TWRippleXAddress> address,
  ) {
    return _TWRippleXAddressTag(
      address,
    );
  }

  late final _TWRippleXAddressTagPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWRippleXAddress>)>>(
      'TWRippleXAddressTag');
  late final _TWRippleXAddressTag = _TWRippleXAddressTagPtr.asFunction<
      int Function(ffi.Pointer<TWRippleXAddress>)>();

  /// Builds a LiquidStaking transaction input.
  ///
  /// \param input The serialized data of LiquidStakingInput.
  /// \return The serialized data of LiquidStakingOutput.
  ffi.Pointer<TWData> TWLiquidStakingBuildRequest(
    ffi.Pointer<TWData> input,
  ) {
    return _TWLiquidStakingBuildRequest(
      input,
    );
  }

  late final _TWLiquidStakingBuildRequestPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWLiquidStakingBuildRequest');
  late final _TWLiquidStakingBuildRequest = _TWLiquidStakingBuildRequestPtr
      .asFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Converts a TON user address into a Bag of Cells (BoC) with a single root Cell.
  /// The function is mostly used to request a Jetton user address via `get_wallet_address` RPC.
  /// https://docs.ton.org/develop/dapps/asset-processing/jettons#retrieving-jetton-wallet-addresses-for-a-given-user
  ///
  /// \param address Address to be converted into a Bag Of Cells (BoC).
  /// \return Pointer to a base64 encoded Bag Of Cells (BoC). Null if invalid address provided.
  ffi.Pointer<TWString1> TWTONAddressConverterToBoc(
    ffi.Pointer<TWString1> address,
  ) {
    return _TWTONAddressConverterToBoc(
      address,
    );
  }

  late final _TWTONAddressConverterToBocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWString1>)>>('TWTONAddressConverterToBoc');
  late final _TWTONAddressConverterToBoc = _TWTONAddressConverterToBocPtr
      .asFunction<ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>)>();

  /// Parses a TON address from a Bag of Cells (BoC) with a single root Cell.
  /// The function is mostly used to parse a Jetton user address received on `get_wallet_address` RPC.
  /// https://docs.ton.org/develop/dapps/asset-processing/jettons#retrieving-jetton-wallet-addresses-for-a-given-user
  ///
  /// \param boc Base64 encoded Bag Of Cells (BoC).
  /// \return Pointer to a Jetton address.
  ffi.Pointer<TWString1> TWTONAddressConverterFromBoc(
    ffi.Pointer<TWString1> boc,
  ) {
    return _TWTONAddressConverterFromBoc(
      boc,
    );
  }

  late final _TWTONAddressConverterFromBocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWString1>)>>('TWTONAddressConverterFromBoc');
  late final _TWTONAddressConverterFromBoc = _TWTONAddressConverterFromBocPtr
      .asFunction<ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>)>();

  /// Converts any TON address format to user friendly with the given parameters.
  ///
  /// \param address raw or user-friendly address to be converted.
  /// \param bounceable whether the result address should be bounceable.
  /// \param testnet whether the result address should be testnet.
  /// \return user-friendly address str.
  ffi.Pointer<TWString1> TWTONAddressConverterToUserFriendly(
    ffi.Pointer<TWString1> address,
    bool bounceable,
    bool testnet,
  ) {
    return _TWTONAddressConverterToUserFriendly(
      address,
      bounceable,
      testnet,
    );
  }

  late final _TWTONAddressConverterToUserFriendlyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>, ffi.Bool,
              ffi.Bool)>>('TWTONAddressConverterToUserFriendly');
  late final _TWTONAddressConverterToUserFriendly =
      _TWTONAddressConverterToUserFriendlyPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWString1>, bool, bool)>();

  /// Parses the WalletConnect signing request as a `SigningInput`.
  ///
  /// \param coin The given coin type to plan the transaction for.
  /// \param input The serialized data of a `WalletConnect::Proto::ParseRequestInput` proto object.
  /// \return The serialized data of `WalletConnect::Proto::ParseRequestOutput` proto object.
  ffi.Pointer<TWData1> TWWalletConnectRequestParse(
    TWCoinType coin,
    ffi.Pointer<TWData1> input,
  ) {
    return _TWWalletConnectRequestParse(
      coin.value,
      input,
    );
  }

  late final _TWWalletConnectRequestParsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.UnsignedInt,
              ffi.Pointer<TWData1>)>>('TWWalletConnectRequestParse');
  late final _TWWalletConnectRequestParse = _TWWalletConnectRequestParsePtr
      .asFunction<ffi.Pointer<TWData1> Function(int, ffi.Pointer<TWData1>)>();

  /// Sign a message.
  ///
  /// \param privateKey: the private key used for signing
  /// \param message: A custom message which is input to the signing.
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString> TWTronMessageSignerSignMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString> message,
  ) {
    return _TWTronMessageSignerSignMessage(
      privateKey,
      message,
    );
  }

  late final _TWTronMessageSignerSignMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString>)>>('TWTronMessageSignerSignMessage');
  late final _TWTronMessageSignerSignMessage =
      _TWTronMessageSignerSignMessagePtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString>)>();

  /// Verify signature for a message.
  ///
  /// \param pubKey: pubKey that will verify and recover the message from the signature
  /// \param message: the message signed (without prefix)
  /// \param signature: in Hex-encoded form.
  /// \returns false on any invalid input (does not throw), true if the message can be recovered from the signature
  bool TWTronMessageSignerVerifyMessage(
    ffi.Pointer<TWPublicKey> pubKey,
    ffi.Pointer<TWString> message,
    ffi.Pointer<TWString> signature,
  ) {
    return _TWTronMessageSignerVerifyMessage(
      pubKey,
      message,
      signature,
    );
  }

  late final _TWTronMessageSignerVerifyMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWTronMessageSignerVerifyMessage');
  late final _TWTronMessageSignerVerifyMessage =
      _TWTronMessageSignerVerifyMessagePtr.asFunction<
          bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>();

  /// Converts attestation object to the public key on P256 curve
  ///
  /// \param attestationObject Attestation object retrieved from webuthn.get method
  /// \return Public key.
  ffi.Pointer<TWPublicKey> TWWebAuthnGetPublicKey(
    ffi.Pointer<TWData> attestationObject,
  ) {
    return _TWWebAuthnGetPublicKey(
      attestationObject,
    );
  }

  late final _TWWebAuthnGetPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWData>)>>('TWWebAuthnGetPublicKey');
  late final _TWWebAuthnGetPublicKey = _TWWebAuthnGetPublicKeyPtr.asFunction<
      ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWData>)>();

  /// Uses ASN parser to extract r and s values from a webauthn signature
  ///
  /// \param signature ASN encoded webauthn signature: https://www.w3.org/TR/webauthn-2/#sctn-signature-attestation-types
  /// \return Concatenated r and s values.
  ffi.Pointer<TWData> TWWebAuthnGetRSValues(
    ffi.Pointer<TWData> signature,
  ) {
    return _TWWebAuthnGetRSValues(
      signature,
    );
  }

  late final _TWWebAuthnGetRSValuesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWWebAuthnGetRSValues');
  late final _TWWebAuthnGetRSValues = _TWWebAuthnGetRSValuesPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Reconstructs the original message that was signed via P256 curve. Can be used for signature validation.
  ///
  /// \param authenticatorData Authenticator Data: https://www.w3.org/TR/webauthn-2/#authenticator-data
  /// \param clientDataJSON clientDataJSON: https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson
  /// \return original messages.
  ffi.Pointer<TWData> TWWebAuthnReconstructOriginalMessage(
    ffi.Pointer<TWData> authenticatorData,
    ffi.Pointer<TWData> clientDataJSON,
  ) {
    return _TWWebAuthnReconstructOriginalMessage(
      authenticatorData,
      clientDataJSON,
    );
  }

  late final _TWWebAuthnReconstructOriginalMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWData>)>>('TWWebAuthnReconstructOriginalMessage');
  late final _TWWebAuthnReconstructOriginalMessage =
      _TWWebAuthnReconstructOriginalMessagePtr.asFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWData>)>();

  /// Derives a key from a password and a salt using PBKDF2 + Sha256.
  ///
  /// \param password is the master password from which a derived key is generated
  /// \param salt is a sequence of bits, known as a cryptographic salt
  /// \param iterations is the number of iterations desired
  /// \param dkLen is the desired bit-length of the derived key
  /// \return the derived key data.
  ffi.Pointer<TWData> TWPBKDF2HmacSha256(
    ffi.Pointer<TWData> password,
    ffi.Pointer<TWData> salt,
    int iterations,
    int dkLen,
  ) {
    return _TWPBKDF2HmacSha256(
      password,
      salt,
      iterations,
      dkLen,
    );
  }

  late final _TWPBKDF2HmacSha256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>,
              ffi.Uint32, ffi.Uint32)>>('TWPBKDF2HmacSha256');
  late final _TWPBKDF2HmacSha256 = _TWPBKDF2HmacSha256Ptr.asFunction<
      ffi.Pointer<TWData> Function(
          ffi.Pointer<TWData>, ffi.Pointer<TWData>, int, int)>();

  /// Derives a key from a password and a salt using PBKDF2 + Sha512.
  ///
  /// \param password is the master password from which a derived key is generated
  /// \param salt is a sequence of bits, known as a cryptographic salt
  /// \param iterations is the number of iterations desired
  /// \param dkLen is the desired bit-length of the derived key
  /// \return the derived key data.
  ffi.Pointer<TWData> TWPBKDF2HmacSha512(
    ffi.Pointer<TWData> password,
    ffi.Pointer<TWData> salt,
    int iterations,
    int dkLen,
  ) {
    return _TWPBKDF2HmacSha512(
      password,
      salt,
      iterations,
      dkLen,
    );
  }

  late final _TWPBKDF2HmacSha512Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>,
              ffi.Uint32, ffi.Uint32)>>('TWPBKDF2HmacSha512');
  late final _TWPBKDF2HmacSha512 = _TWPBKDF2HmacSha512Ptr.asFunction<
      ffi.Pointer<TWData> Function(
          ffi.Pointer<TWData>, ffi.Pointer<TWData>, int, int)>();

  /// Converts a Filecoin address to Ethereum.
  ///
  /// \param filecoinAddress: a Filecoin address.
  /// \returns the Ethereum address. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString> TWFilecoinAddressConverterConvertToEthereum(
    ffi.Pointer<TWString> filecoinAddress,
  ) {
    return _TWFilecoinAddressConverterConvertToEthereum(
      filecoinAddress,
    );
  }

  late final _TWFilecoinAddressConverterConvertToEthereumPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>>(
      'TWFilecoinAddressConverterConvertToEthereum');
  late final _TWFilecoinAddressConverterConvertToEthereum =
      _TWFilecoinAddressConverterConvertToEthereumPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>();

  /// Converts an Ethereum address to Filecoin.
  ///
  /// \param ethAddress: an Ethereum address.
  /// \returns the Filecoin address. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString> TWFilecoinAddressConverterConvertFromEthereum(
    ffi.Pointer<TWString> ethAddress,
  ) {
    return _TWFilecoinAddressConverterConvertFromEthereum(
      ethAddress,
    );
  }

  late final _TWFilecoinAddressConverterConvertFromEthereumPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>>(
      'TWFilecoinAddressConverterConvertFromEthereum');
  late final _TWFilecoinAddressConverterConvertFromEthereum =
      _TWFilecoinAddressConverterConvertFromEthereumPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>();

  /// Determines if the given public key is valid or not.
  ///
  /// \param data *non-null* byte array.
  /// \return true if the public key is valid, false otherwise.
  bool TWCryptoBoxPublicKeyIsValid(
    ffi.Pointer<TWData> data,
  ) {
    return _TWCryptoBoxPublicKeyIsValid(
      data,
    );
  }

  late final _TWCryptoBoxPublicKeyIsValidPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWData>)>>(
          'TWCryptoBoxPublicKeyIsValid');
  late final _TWCryptoBoxPublicKeyIsValid = _TWCryptoBoxPublicKeyIsValidPtr
      .asFunction<bool Function(ffi.Pointer<TWData>)>();

  /// Create a `crypto_box` public key with the given block of data.
  ///
  /// \param data *non-null* byte array. Expected to have 32 bytes.
  /// \note Should be deleted with \tw_crypto_box_public_key_delete.
  /// \return Nullable pointer to Public Key.
  ffi.Pointer<TWCryptoBoxPublicKey> TWCryptoBoxPublicKeyCreateWithData(
    ffi.Pointer<TWData> data,
  ) {
    return _TWCryptoBoxPublicKeyCreateWithData(
      data,
    );
  }

  late final _TWCryptoBoxPublicKeyCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWCryptoBoxPublicKey> Function(
              ffi.Pointer<TWData>)>>('TWCryptoBoxPublicKeyCreateWithData');
  late final _TWCryptoBoxPublicKeyCreateWithData =
      _TWCryptoBoxPublicKeyCreateWithDataPtr.asFunction<
          ffi.Pointer<TWCryptoBoxPublicKey> Function(ffi.Pointer<TWData>)>();

  /// Delete the given public key.
  ///
  /// \param publicKey *non-null* pointer to public key.
  void TWCryptoBoxPublicKeyDelete(
    ffi.Pointer<TWCryptoBoxPublicKey> publicKey,
  ) {
    return _TWCryptoBoxPublicKeyDelete(
      publicKey,
    );
  }

  late final _TWCryptoBoxPublicKeyDeletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<TWCryptoBoxPublicKey>)>>(
      'TWCryptoBoxPublicKeyDelete');
  late final _TWCryptoBoxPublicKeyDelete = _TWCryptoBoxPublicKeyDeletePtr
      .asFunction<void Function(ffi.Pointer<TWCryptoBoxPublicKey>)>();

  /// Returns the raw data of the given public-key.
  ///
  /// \param publicKey *non-null* pointer to a public key.
  /// \return C-compatible result with a C-compatible byte array.
  ffi.Pointer<TWData> TWCryptoBoxPublicKeyData(
    ffi.Pointer<TWCryptoBoxPublicKey> publicKey,
  ) {
    return _TWCryptoBoxPublicKeyData(
      publicKey,
    );
  }

  late final _TWCryptoBoxPublicKeyDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWCryptoBoxPublicKey>)>>('TWCryptoBoxPublicKeyData');
  late final _TWCryptoBoxPublicKeyData =
      _TWCryptoBoxPublicKeyDataPtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWCryptoBoxPublicKey>)>();

  /// Create a random secret key.
  ///
  /// \note Should be deleted with \tw_crypto_box_secret_key_delete.
  /// \return *non-null* pointer to Secret Key.
  ffi.Pointer<TWCryptoBoxSecretKey> TWCryptoBoxSecretKeyCreate() {
    return _TWCryptoBoxSecretKeyCreate();
  }

  late final _TWCryptoBoxSecretKeyCreatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWCryptoBoxSecretKey> Function()>>(
          'TWCryptoBoxSecretKeyCreate');
  late final _TWCryptoBoxSecretKeyCreate = _TWCryptoBoxSecretKeyCreatePtr
      .asFunction<ffi.Pointer<TWCryptoBoxSecretKey> Function()>();

  /// Delete the given secret `key`.
  ///
  /// \param key *non-null* pointer to secret key.
  void TWCryptoBoxSecretKeyDelete(
    ffi.Pointer<TWCryptoBoxSecretKey> key,
  ) {
    return _TWCryptoBoxSecretKeyDelete(
      key,
    );
  }

  late final _TWCryptoBoxSecretKeyDeletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<TWCryptoBoxSecretKey>)>>(
      'TWCryptoBoxSecretKeyDelete');
  late final _TWCryptoBoxSecretKeyDelete = _TWCryptoBoxSecretKeyDeletePtr
      .asFunction<void Function(ffi.Pointer<TWCryptoBoxSecretKey>)>();

  /// Returns the public key associated with the given `key`.
  ///
  /// \param key *non-null* pointer to the private key.
  /// \return *non-null* pointer to the corresponding public key.
  ffi.Pointer<TWCryptoBoxPublicKey> TWCryptoBoxSecretKeyGetPublicKey(
    ffi.Pointer<TWCryptoBoxSecretKey> key,
  ) {
    return _TWCryptoBoxSecretKeyGetPublicKey(
      key,
    );
  }

  late final _TWCryptoBoxSecretKeyGetPublicKeyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWCryptoBoxPublicKey> Function(
                  ffi.Pointer<TWCryptoBoxSecretKey>)>>(
      'TWCryptoBoxSecretKeyGetPublicKey');
  late final _TWCryptoBoxSecretKeyGetPublicKey =
      _TWCryptoBoxSecretKeyGetPublicKeyPtr.asFunction<
          ffi.Pointer<TWCryptoBoxPublicKey> Function(
              ffi.Pointer<TWCryptoBoxSecretKey>)>();

  /// Decode a Base32 input with the given alphabet
  ///
  /// \param string Encoded base32 input to be decoded
  /// \param alphabet Decode with the given alphabet, if nullptr ALPHABET_RFC4648 is used by default
  /// \return The decoded data, can be null.
  /// \note ALPHABET_RFC4648 doesn't support padding in the default alphabet
  ffi.Pointer<TWData> TWBase32DecodeWithAlphabet(
    ffi.Pointer<TWString> string,
    ffi.Pointer<TWString> alphabet,
  ) {
    return _TWBase32DecodeWithAlphabet(
      string,
      alphabet,
    );
  }

  late final _TWBase32DecodeWithAlphabetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWBase32DecodeWithAlphabet');
  late final _TWBase32DecodeWithAlphabet =
      _TWBase32DecodeWithAlphabetPtr.asFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWString>)>();

  /// Decode a Base32 input with the default alphabet (ALPHABET_RFC4648)
  ///
  /// \param string Encoded input to be decoded
  /// \return The decoded data
  /// \note Call TWBase32DecodeWithAlphabet with nullptr.
  ffi.Pointer<TWData> TWBase32Decode(
    ffi.Pointer<TWString> string,
  ) {
    return _TWBase32Decode(
      string,
    );
  }

  late final _TWBase32DecodePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>>(
      'TWBase32Decode');
  late final _TWBase32Decode = _TWBase32DecodePtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>();

  /// Encode an input to Base32 with the given alphabet
  ///
  /// \param data Data to be encoded (raw bytes)
  /// \param alphabet Encode with the given alphabet, if nullptr ALPHABET_RFC4648 is used by default
  /// \return The encoded data
  /// \note ALPHABET_RFC4648 doesn't support padding in the default alphabet
  ffi.Pointer<TWString> TWBase32EncodeWithAlphabet(
    ffi.Pointer<TWData> data,
    ffi.Pointer<TWString> alphabet,
  ) {
    return _TWBase32EncodeWithAlphabet(
      data,
      alphabet,
    );
  }

  late final _TWBase32EncodeWithAlphabetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWString>)>>('TWBase32EncodeWithAlphabet');
  late final _TWBase32EncodeWithAlphabet =
      _TWBase32EncodeWithAlphabetPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWString>)>();

  /// Encode an input to Base32 with the default alphabet (ALPHABET_RFC4648)
  ///
  /// \param data Data to be encoded (raw bytes)
  /// \return The encoded data
  /// \note Call TWBase32EncodeWithAlphabet with nullptr.
  ffi.Pointer<TWString> TWBase32Encode(
    ffi.Pointer<TWData> data,
  ) {
    return _TWBase32Encode(
      data,
    );
  }

  late final _TWBase32EncodePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>>(
      'TWBase32Encode');
  late final _TWBase32Encode = _TWBase32EncodePtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>();

  /// Decode a contract call (function input) according to an ABI json.
  ///
  /// \param coin EVM-compatible coin type.
  /// \param input The serialized data of `TW.EthereumAbi.Proto.ContractCallDecodingInput`.
  /// \return The serialized data of a `TW.EthereumAbi.Proto.ContractCallDecodingOutput` proto object.
  ffi.Pointer<TWData1> TWEthereumAbiDecodeContractCall(
    TWCoinType coin,
    ffi.Pointer<TWData1> input,
  ) {
    return _TWEthereumAbiDecodeContractCall(
      coin.value,
      input,
    );
  }

  late final _TWEthereumAbiDecodeContractCallPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.UnsignedInt,
              ffi.Pointer<TWData1>)>>('TWEthereumAbiDecodeContractCall');
  late final _TWEthereumAbiDecodeContractCall =
      _TWEthereumAbiDecodeContractCallPtr.asFunction<
          ffi.Pointer<TWData1> Function(int, ffi.Pointer<TWData1>)>();

  /// Decode a function input or output data according to a given ABI.
  ///
  /// \param coin EVM-compatible coin type.
  /// \param input The serialized data of `TW.EthereumAbi.Proto.ParamsDecodingInput`.
  /// \return The serialized data of a `TW.EthereumAbi.Proto.ParamsDecodingOutput` proto object.
  ffi.Pointer<TWData1> TWEthereumAbiDecodeParams(
    TWCoinType coin,
    ffi.Pointer<TWData1> input,
  ) {
    return _TWEthereumAbiDecodeParams(
      coin.value,
      input,
    );
  }

  late final _TWEthereumAbiDecodeParamsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.UnsignedInt,
              ffi.Pointer<TWData1>)>>('TWEthereumAbiDecodeParams');
  late final _TWEthereumAbiDecodeParams = _TWEthereumAbiDecodeParamsPtr
      .asFunction<ffi.Pointer<TWData1> Function(int, ffi.Pointer<TWData1>)>();

  /// /// Decodes an Eth ABI value according to a given type.
  ///
  /// \param coin EVM-compatible coin type.
  /// \param input The serialized data of `TW.EthereumAbi.Proto.ValueDecodingInput`.
  /// \return The serialized data of a `TW.EthereumAbi.Proto.ValueDecodingOutput` proto object.
  ffi.Pointer<TWData1> TWEthereumAbiDecodeValue(
    TWCoinType coin,
    ffi.Pointer<TWData1> input,
  ) {
    return _TWEthereumAbiDecodeValue(
      coin.value,
      input,
    );
  }

  late final _TWEthereumAbiDecodeValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.UnsignedInt,
              ffi.Pointer<TWData1>)>>('TWEthereumAbiDecodeValue');
  late final _TWEthereumAbiDecodeValue = _TWEthereumAbiDecodeValuePtr
      .asFunction<ffi.Pointer<TWData1> Function(int, ffi.Pointer<TWData1>)>();

  /// Encode function to Eth ABI binary.
  ///
  /// \param coin EVM-compatible coin type.
  /// \param input The serialized data of `TW.EthereumAbi.Proto.FunctionEncodingInput`.
  /// \return The serialized data of a `TW.EthereumAbi.Proto.FunctionEncodingOutput` proto object.
  ffi.Pointer<TWData1> TWEthereumAbiEncodeFunction(
    TWCoinType coin,
    ffi.Pointer<TWData1> input,
  ) {
    return _TWEthereumAbiEncodeFunction(
      coin.value,
      input,
    );
  }

  late final _TWEthereumAbiEncodeFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.UnsignedInt,
              ffi.Pointer<TWData1>)>>('TWEthereumAbiEncodeFunction');
  late final _TWEthereumAbiEncodeFunction = _TWEthereumAbiEncodeFunctionPtr
      .asFunction<ffi.Pointer<TWData1> Function(int, ffi.Pointer<TWData1>)>();

  /// Encode function to Eth ABI binary
  ///
  /// \param fn Non-null Eth abi function
  /// \return Non-null encoded block of data
  ffi.Pointer<TWData1> TWEthereumAbiEncode(
    ffi.Pointer<TWEthereumAbiFunction> fn,
  ) {
    return _TWEthereumAbiEncode(
      fn,
    );
  }

  late final _TWEthereumAbiEncodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWEthereumAbiFunction>)>>('TWEthereumAbiEncode');
  late final _TWEthereumAbiEncode = _TWEthereumAbiEncodePtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWEthereumAbiFunction>)>();

  /// Decode function output from Eth ABI binary, fill output parameters
  ///
  /// \param[in] fn Non-null Eth abi function
  /// \param[out] encoded Non-null block of data
  /// \return true if encoded have been filled correctly, false otherwise
  bool TWEthereumAbiDecodeOutput(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    ffi.Pointer<TWData1> encoded,
  ) {
    return _TWEthereumAbiDecodeOutput(
      fn,
      encoded,
    );
  }

  late final _TWEthereumAbiDecodeOutputPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWData1>)>>('TWEthereumAbiDecodeOutput');
  late final _TWEthereumAbiDecodeOutput =
      _TWEthereumAbiDecodeOutputPtr.asFunction<
          bool Function(
              ffi.Pointer<TWEthereumAbiFunction>, ffi.Pointer<TWData1>)>();

  /// Decode function call data to human readable json format, according to input abi json
  ///
  /// \param data Non-null block of data
  /// \param abi Non-null string
  /// \return Non-null json string function call data
  ffi.Pointer<TWString1> TWEthereumAbiDecodeCall(
    ffi.Pointer<TWData1> data,
    ffi.Pointer<TWString1> abi,
  ) {
    return _TWEthereumAbiDecodeCall(
      data,
      abi,
    );
  }

  late final _TWEthereumAbiDecodeCallPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>)>>('TWEthereumAbiDecodeCall');
  late final _TWEthereumAbiDecodeCall = _TWEthereumAbiDecodeCallPtr.asFunction<
      ffi.Pointer<TWString1> Function(
          ffi.Pointer<TWData1>, ffi.Pointer<TWString1>)>();

  /// Compute the hash of a struct, used for signing, according to EIP712 ("v4").
  /// Input is a Json object (as string), with following fields:
  /// - types: map of used struct types (see makeTypes())
  /// - primaryType: the type of the message (string)
  /// - domain: EIP712 domain specifier values
  /// - message: the message (object).
  /// Throws on error.
  /// Example input:
  /// R"({
  /// "types": {
  /// "EIP712Domain": [
  /// {"name": "name", "type": "string"},
  /// {"name": "version", "type": "string"},
  /// {"name": "chainId", "type": "uint256"},
  /// {"name": "verifyingContract", "type": "address"}
  /// ],
  /// "Person": [
  /// {"name": "name", "type": "string"},
  /// {"name": "wallet", "type": "address"}
  /// ]
  /// },
  /// "primaryType": "Person",
  /// "domain": {
  /// "name": "Ether Person",
  /// "version": "1",
  /// "chainId": 1,
  /// "verifyingContract": "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"
  /// },
  /// "message": {
  /// "name": "Cow",
  /// "wallet": "CD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"
  /// }
  /// })");
  /// On error, empty Data is returned.
  /// Returned data must be deleted (hint: use WRAPD() macro).
  ///
  /// \param messageJson Non-null json abi input
  /// \return Non-null block of data, encoded abi input
  ffi.Pointer<TWData1> TWEthereumAbiEncodeTyped(
    ffi.Pointer<TWString1> messageJson,
  ) {
    return _TWEthereumAbiEncodeTyped(
      messageJson,
    );
  }

  late final _TWEthereumAbiEncodeTypedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWString1>)>>('TWEthereumAbiEncodeTyped');
  late final _TWEthereumAbiEncodeTyped = _TWEthereumAbiEncodeTypedPtr
      .asFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWString1>)>();

  /// Implement format input as described in https://tezostaquito.io/docs/signing/
  ///
  /// \param message message to format e.g: Hello, World
  /// \param dAppUrl the app url, e.g: testUrl
  /// \returns the formatted message as a string
  ffi.Pointer<TWString> TWTezosMessageSignerFormatMessage(
    ffi.Pointer<TWString> message,
    ffi.Pointer<TWString> url,
  ) {
    return _TWTezosMessageSignerFormatMessage(
      message,
      url,
    );
  }

  late final _TWTezosMessageSignerFormatMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWTezosMessageSignerFormatMessage');
  late final _TWTezosMessageSignerFormatMessage =
      _TWTezosMessageSignerFormatMessagePtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWString>)>();

  /// Implement input to payload as described in: https://tezostaquito.io/docs/signing/
  ///
  /// \param message formatted message to be turned into an hex payload
  /// \return the hexpayload of the formated message as a hex string
  ffi.Pointer<TWString> TWTezosMessageSignerInputToPayload(
    ffi.Pointer<TWString> message,
  ) {
    return _TWTezosMessageSignerInputToPayload(
      message,
    );
  }

  late final _TWTezosMessageSignerInputToPayloadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>)>>('TWTezosMessageSignerInputToPayload');
  late final _TWTezosMessageSignerInputToPayload =
      _TWTezosMessageSignerInputToPayloadPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>();

  /// Sign a message as described in https://tezostaquito.io/docs/signing/
  ///
  /// \param privateKey: the private key used for signing
  /// \param message: A custom message payload (hex) which is input to the signing.
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString> TWTezosMessageSignerSignMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString> message,
  ) {
    return _TWTezosMessageSignerSignMessage(
      privateKey,
      message,
    );
  }

  late final _TWTezosMessageSignerSignMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString>)>>('TWTezosMessageSignerSignMessage');
  late final _TWTezosMessageSignerSignMessage =
      _TWTezosMessageSignerSignMessagePtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString>)>();

  /// Verify signature for a message as described in https://tezostaquito.io/docs/signing/
  ///
  /// \param pubKey: pubKey that will verify the message from the signature
  /// \param message: the message signed as a payload (hex)
  /// \param signature: in Base58-encoded form.
  /// \returns false on any invalid input (does not throw), true if the message can be verified from the signature
  bool TWTezosMessageSignerVerifyMessage(
    ffi.Pointer<TWPublicKey> pubKey,
    ffi.Pointer<TWString> message,
    ffi.Pointer<TWString> signature,
  ) {
    return _TWTezosMessageSignerVerifyMessage(
      pubKey,
      message,
      signature,
    );
  }

  late final _TWTezosMessageSignerVerifyMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWTezosMessageSignerVerifyMessage');
  late final _TWTezosMessageSignerVerifyMessage =
      _TWTezosMessageSignerVerifyMessagePtr.asFunction<
          bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _TWStellarPassphrase_Stellar =
      _lookup<ffi.Pointer<ffi.Char>>('TWStellarPassphrase_Stellar');

  ffi.Pointer<ffi.Char> get TWStellarPassphrase_Stellar =>
      _TWStellarPassphrase_Stellar.value;

  set TWStellarPassphrase_Stellar(ffi.Pointer<ffi.Char> value) =>
      _TWStellarPassphrase_Stellar.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _TWStellarPassphrase_Kin =
      _lookup<ffi.Pointer<ffi.Char>>('TWStellarPassphrase_Kin');

  ffi.Pointer<ffi.Char> get TWStellarPassphrase_Kin =>
      _TWStellarPassphrase_Kin.value;

  set TWStellarPassphrase_Kin(ffi.Pointer<ffi.Char> value) =>
      _TWStellarPassphrase_Kin.value = value;

  late final ffi.Pointer<ffi.Size> _TWHashSHA1Length =
      _lookup<ffi.Size>('TWHashSHA1Length');

  int get TWHashSHA1Length => _TWHashSHA1Length.value;

  late final ffi.Pointer<ffi.Size> _TWHashSHA256Length =
      _lookup<ffi.Size>('TWHashSHA256Length');

  int get TWHashSHA256Length => _TWHashSHA256Length.value;

  late final ffi.Pointer<ffi.Size> _TWHashSHA512Length =
      _lookup<ffi.Size>('TWHashSHA512Length');

  int get TWHashSHA512Length => _TWHashSHA512Length.value;

  late final ffi.Pointer<ffi.Size> _TWHashRipemdLength =
      _lookup<ffi.Size>('TWHashRipemdLength');

  int get TWHashRipemdLength => _TWHashRipemdLength.value;

  /// Computes the SHA1 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA1 block of data
  ffi.Pointer<TWData> TWHashSHA1(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashSHA1(
      data,
    );
  }

  late final _TWHashSHA1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>('TWHashSHA1');
  late final _TWHashSHA1 = _TWHashSHA1Ptr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the SHA256 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA256 block of data
  ffi.Pointer<TWData> TWHashSHA256(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashSHA256(
      data,
    );
  }

  late final _TWHashSHA256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>('TWHashSHA256');
  late final _TWHashSHA256 = _TWHashSHA256Ptr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the SHA512 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA512 block of data
  ffi.Pointer<TWData> TWHashSHA512(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashSHA512(
      data,
    );
  }

  late final _TWHashSHA512Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>('TWHashSHA512');
  late final _TWHashSHA512 = _TWHashSHA512Ptr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the SHA512_256 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA512_256 block of data
  ffi.Pointer<TWData> TWHashSHA512_256(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashSHA512_256(
      data,
    );
  }

  late final _TWHashSHA512_256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWHashSHA512_256');
  late final _TWHashSHA512_256 = _TWHashSHA512_256Ptr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the Keccak256 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Keccak256 block of data
  ffi.Pointer<TWData> TWHashKeccak256(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashKeccak256(
      data,
    );
  }

  late final _TWHashKeccak256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWHashKeccak256');
  late final _TWHashKeccak256 = _TWHashKeccak256Ptr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the Keccak512 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Keccak512 block of data
  ffi.Pointer<TWData> TWHashKeccak512(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashKeccak512(
      data,
    );
  }

  late final _TWHashKeccak512Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWHashKeccak512');
  late final _TWHashKeccak512 = _TWHashKeccak512Ptr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the SHA3_256 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA3_256 block of data
  ffi.Pointer<TWData> TWHashSHA3_256(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashSHA3_256(
      data,
    );
  }

  late final _TWHashSHA3_256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>('TWHashSHA3_256');
  late final _TWHashSHA3_256 = _TWHashSHA3_256Ptr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the SHA3_512 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA3_512 block of data
  ffi.Pointer<TWData> TWHashSHA3_512(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashSHA3_512(
      data,
    );
  }

  late final _TWHashSHA3_512Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>('TWHashSHA3_512');
  late final _TWHashSHA3_512 = _TWHashSHA3_512Ptr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the RIPEMD of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed RIPEMD block of data
  ffi.Pointer<TWData> TWHashRIPEMD(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashRIPEMD(
      data,
    );
  }

  late final _TWHashRIPEMDPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>('TWHashRIPEMD');
  late final _TWHashRIPEMD = _TWHashRIPEMDPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the Blake256 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Blake256 block of data
  ffi.Pointer<TWData> TWHashBlake256(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashBlake256(
      data,
    );
  }

  late final _TWHashBlake256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>('TWHashBlake256');
  late final _TWHashBlake256 = _TWHashBlake256Ptr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the Blake2b of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Blake2b block of data
  ffi.Pointer<TWData> TWHashBlake2b(
    ffi.Pointer<TWData> data,
    int size,
  ) {
    return _TWHashBlake2b(
      data,
      size,
    );
  }

  late final _TWHashBlake2bPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWData>, ffi.Size)>>('TWHashBlake2b');
  late final _TWHashBlake2b = _TWHashBlake2bPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, int)>();

  /// Computes the Groestl512 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Groestl512 block of data
  ffi.Pointer<TWData> TWHashBlake2bPersonal(
    ffi.Pointer<TWData> data,
    ffi.Pointer<TWData> personal,
    int outlen,
  ) {
    return _TWHashBlake2bPersonal(
      data,
      personal,
      outlen,
    );
  }

  late final _TWHashBlake2bPersonalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>,
              ffi.Size)>>('TWHashBlake2bPersonal');
  late final _TWHashBlake2bPersonal = _TWHashBlake2bPersonalPtr.asFunction<
      ffi.Pointer<TWData> Function(
          ffi.Pointer<TWData>, ffi.Pointer<TWData>, int)>();

  ffi.Pointer<TWData> TWHashGroestl512(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashGroestl512(
      data,
    );
  }

  late final _TWHashGroestl512Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWHashGroestl512');
  late final _TWHashGroestl512 = _TWHashGroestl512Ptr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the SHA256D of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA256D block of data
  ffi.Pointer<TWData> TWHashSHA256SHA256(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashSHA256SHA256(
      data,
    );
  }

  late final _TWHashSHA256SHA256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWHashSHA256SHA256');
  late final _TWHashSHA256SHA256 = _TWHashSHA256SHA256Ptr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the SHA256RIPEMD of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA256RIPEMD block of data
  ffi.Pointer<TWData> TWHashSHA256RIPEMD(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashSHA256RIPEMD(
      data,
    );
  }

  late final _TWHashSHA256RIPEMDPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWHashSHA256RIPEMD');
  late final _TWHashSHA256RIPEMD = _TWHashSHA256RIPEMDPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the SHA3_256RIPEMD of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA3_256RIPEMD block of data
  ffi.Pointer<TWData> TWHashSHA3_256RIPEMD(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashSHA3_256RIPEMD(
      data,
    );
  }

  late final _TWHashSHA3_256RIPEMDPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWHashSHA3_256RIPEMD');
  late final _TWHashSHA3_256RIPEMD = _TWHashSHA3_256RIPEMDPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the Blake256D of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Blake256D block of data
  ffi.Pointer<TWData> TWHashBlake256Blake256(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashBlake256Blake256(
      data,
    );
  }

  late final _TWHashBlake256Blake256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWHashBlake256Blake256');
  late final _TWHashBlake256Blake256 = _TWHashBlake256Blake256Ptr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the Blake256RIPEMD of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Blake256RIPEMD block of data
  ffi.Pointer<TWData> TWHashBlake256RIPEMD(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashBlake256RIPEMD(
      data,
    );
  }

  late final _TWHashBlake256RIPEMDPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWHashBlake256RIPEMD');
  late final _TWHashBlake256RIPEMD = _TWHashBlake256RIPEMDPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Computes the Groestl512D of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Groestl512D block of data
  ffi.Pointer<TWData> TWHashGroestl512Groestl512(
    ffi.Pointer<TWData> data,
  ) {
    return _TWHashGroestl512Groestl512(
      data,
    );
  }

  late final _TWHashGroestl512Groestl512Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWHashGroestl512Groestl512');
  late final _TWHashGroestl512Groestl512 = _TWHashGroestl512Groestl512Ptr
      .asFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Loads a key from a file.
  ///
  /// \param path filepath to the key as a non-null string
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be load, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyLoad(
    ffi.Pointer<TWString1> path,
  ) {
    return _TWStoredKeyLoad(
      path,
    );
  }

  late final _TWStoredKeyLoadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString1>)>>('TWStoredKeyLoad');
  late final _TWStoredKeyLoad = _TWStoredKeyLoadPtr.asFunction<
      ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString1>)>();

  /// Imports a private key.
  ///
  /// \param privateKey Non-null Block of data private key
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportPrivateKey(
    ffi.Pointer<TWData1> privateKey,
    ffi.Pointer<TWString1> name,
    ffi.Pointer<TWData1> password,
    TWCoinType coin,
  ) {
    return _TWStoredKeyImportPrivateKey(
      privateKey,
      name,
      password,
      coin.value,
    );
  }

  late final _TWStoredKeyImportPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>,
              ffi.UnsignedInt)>>('TWStoredKeyImportPrivateKey');
  late final _TWStoredKeyImportPrivateKey =
      _TWStoredKeyImportPrivateKeyPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>, ffi.Pointer<TWData1>, int)>();

  /// Imports a private key.
  ///
  /// \param privateKey Non-null Block of data private key
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportPrivateKeyWithEncryption(
    ffi.Pointer<TWData1> privateKey,
    ffi.Pointer<TWString1> name,
    ffi.Pointer<TWData1> password,
    TWCoinType coin,
    TWStoredKeyEncryption encryption,
  ) {
    return _TWStoredKeyImportPrivateKeyWithEncryption(
      privateKey,
      name,
      password,
      coin.value,
      encryption.value,
    );
  }

  late final _TWStoredKeyImportPrivateKeyWithEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWStoredKeyImportPrivateKeyWithEncryption');
  late final _TWStoredKeyImportPrivateKeyWithEncryption =
      _TWStoredKeyImportPrivateKeyWithEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>, ffi.Pointer<TWData1>, int, int)>();

  /// Imports an HD wallet.
  ///
  /// \param mnemonic Non-null bip39 mnemonic
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportHDWallet(
    ffi.Pointer<TWString1> mnemonic,
    ffi.Pointer<TWString1> name,
    ffi.Pointer<TWData1> password,
    TWCoinType coin,
  ) {
    return _TWStoredKeyImportHDWallet(
      mnemonic,
      name,
      password,
      coin.value,
    );
  }

  late final _TWStoredKeyImportHDWalletPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>,
              ffi.UnsignedInt)>>('TWStoredKeyImportHDWallet');
  late final _TWStoredKeyImportHDWallet =
      _TWStoredKeyImportHDWalletPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>, ffi.Pointer<TWData1>, int)>();

  /// Imports an HD wallet.
  ///
  /// \param mnemonic Non-null bip39 mnemonic
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportHDWalletWithEncryption(
    ffi.Pointer<TWString1> mnemonic,
    ffi.Pointer<TWString1> name,
    ffi.Pointer<TWData1> password,
    TWCoinType coin,
    TWStoredKeyEncryption encryption,
  ) {
    return _TWStoredKeyImportHDWalletWithEncryption(
      mnemonic,
      name,
      password,
      coin.value,
      encryption.value,
    );
  }

  late final _TWStoredKeyImportHDWalletWithEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWStoredKeyImportHDWalletWithEncryption');
  late final _TWStoredKeyImportHDWalletWithEncryption =
      _TWStoredKeyImportHDWalletWithEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>, ffi.Pointer<TWData1>, int, int)>();

  /// Imports a key from JSON.
  ///
  /// \param json Json stored key import format as a non-null block of data
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportJSON(
    ffi.Pointer<TWData1> json,
  ) {
    return _TWStoredKeyImportJSON(
      json,
    );
  }

  late final _TWStoredKeyImportJSONPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWData1>)>>('TWStoredKeyImportJSON');
  late final _TWStoredKeyImportJSON = _TWStoredKeyImportJSONPtr.asFunction<
      ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWData1>)>();

  /// Creates a new key, with given encryption strength level. Returned object needs to be deleted.
  ///
  /// \param name The name of the key to be stored
  /// \param password Non-null block of data, password of the stored key
  /// \param encryptionLevel The level of encryption, see \TWStoredKeyEncryptionLevel
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return The stored key as a non-null pointer
  ffi.Pointer<TWStoredKey> TWStoredKeyCreateLevel(
    ffi.Pointer<TWString1> name,
    ffi.Pointer<TWData1> password,
    TWStoredKeyEncryptionLevel encryptionLevel,
  ) {
    return _TWStoredKeyCreateLevel(
      name,
      password,
      encryptionLevel.value,
    );
  }

  late final _TWStoredKeyCreateLevelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>,
              ffi.UnsignedInt)>>('TWStoredKeyCreateLevel');
  late final _TWStoredKeyCreateLevel = _TWStoredKeyCreateLevelPtr.asFunction<
      ffi.Pointer<TWStoredKey> Function(
          ffi.Pointer<TWString1>, ffi.Pointer<TWData1>, int)>();

  /// Creates a new key, with given encryption strength level.  Returned object needs to be deleted.
  ///
  /// \param name The name of the key to be stored
  /// \param password Non-null block of data, password of the stored key
  /// \param encryptionLevel The level of encryption, see \TWStoredKeyEncryptionLevel
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return The stored key as a non-null pointer
  ffi.Pointer<TWStoredKey> TWStoredKeyCreateLevelAndEncryption(
    ffi.Pointer<TWString1> name,
    ffi.Pointer<TWData1> password,
    TWStoredKeyEncryptionLevel encryptionLevel,
    TWStoredKeyEncryption encryption,
  ) {
    return _TWStoredKeyCreateLevelAndEncryption(
      name,
      password,
      encryptionLevel.value,
      encryption.value,
    );
  }

  late final _TWStoredKeyCreateLevelAndEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWStoredKeyCreateLevelAndEncryption');
  late final _TWStoredKeyCreateLevelAndEncryption =
      _TWStoredKeyCreateLevelAndEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString1>, ffi.Pointer<TWData1>, int, int)>();

  /// Creates a new key.
  ///
  /// \deprecated use TWStoredKeyCreateLevel.
  /// \param name The name of the key to be stored
  /// \param password Non-null block of data, password of the stored key
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return The stored key as a non-null pointer
  ffi.Pointer<TWStoredKey> TWStoredKeyCreate(
    ffi.Pointer<TWString1> name,
    ffi.Pointer<TWData1> password,
  ) {
    return _TWStoredKeyCreate(
      name,
      password,
    );
  }

  late final _TWStoredKeyCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>)>>('TWStoredKeyCreate');
  late final _TWStoredKeyCreate = _TWStoredKeyCreatePtr.asFunction<
      ffi.Pointer<TWStoredKey> Function(
          ffi.Pointer<TWString1>, ffi.Pointer<TWData1>)>();

  /// Creates a new key.
  ///
  /// \deprecated use TWStoredKeyCreateLevel.
  /// \param name The name of the key to be stored
  /// \param password Non-null block of data, password of the stored key
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return The stored key as a non-null pointer
  ffi.Pointer<TWStoredKey> TWStoredKeyCreateEncryption(
    ffi.Pointer<TWString1> name,
    ffi.Pointer<TWData1> password,
    TWStoredKeyEncryption encryption,
  ) {
    return _TWStoredKeyCreateEncryption(
      name,
      password,
      encryption.value,
    );
  }

  late final _TWStoredKeyCreateEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>,
              ffi.UnsignedInt)>>('TWStoredKeyCreateEncryption');
  late final _TWStoredKeyCreateEncryption =
      _TWStoredKeyCreateEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString1>, ffi.Pointer<TWData1>, int)>();

  /// Delete a stored key
  ///
  /// \param key The key to be deleted
  void TWStoredKeyDelete(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyDelete(
      key,
    );
  }

  late final _TWStoredKeyDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWStoredKey>)>>(
          'TWStoredKeyDelete');
  late final _TWStoredKeyDelete = _TWStoredKeyDeletePtr.asFunction<
      void Function(ffi.Pointer<TWStoredKey>)>();

  /// Stored key unique identifier.
  ///
  /// \param key Non-null pointer to a stored key
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return The stored key unique identifier if it's found, null pointer otherwise.
  ffi.Pointer<TWString1> TWStoredKeyIdentifier(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyIdentifier(
      key,
    );
  }

  late final _TWStoredKeyIdentifierPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWStoredKey>)>>('TWStoredKeyIdentifier');
  late final _TWStoredKeyIdentifier = _TWStoredKeyIdentifierPtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWStoredKey>)>();

  /// Stored key namer.
  ///
  /// \param key Non-null pointer to a stored key
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return The stored key name as a non-null string pointer.
  ffi.Pointer<TWString1> TWStoredKeyName(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyName(
      key,
    );
  }

  late final _TWStoredKeyNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWStoredKey>)>>('TWStoredKeyName');
  late final _TWStoredKeyName = _TWStoredKeyNamePtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWStoredKey>)>();

  /// Whether this key is a mnemonic phrase for a HD wallet.
  ///
  /// \param key Non-null pointer to a stored key
  /// \return true if the given stored key is a mnemonic, false otherwise
  bool TWStoredKeyIsMnemonic(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyIsMnemonic(
      key,
    );
  }

  late final _TWStoredKeyIsMnemonicPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWStoredKey>)>>(
          'TWStoredKeyIsMnemonic');
  late final _TWStoredKeyIsMnemonic = _TWStoredKeyIsMnemonicPtr.asFunction<
      bool Function(ffi.Pointer<TWStoredKey>)>();

  /// The number of accounts.
  ///
  /// \param key Non-null pointer to a stored key
  /// \return the number of accounts associated to the given stored key
  int TWStoredKeyAccountCount(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyAccountCount(
      key,
    );
  }

  late final _TWStoredKeyAccountCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWStoredKey>)>>(
          'TWStoredKeyAccountCount');
  late final _TWStoredKeyAccountCount = _TWStoredKeyAccountCountPtr.asFunction<
      int Function(ffi.Pointer<TWStoredKey>)>();

  /// Returns the account at a given index.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param index the account index to be retrieved
  /// \note Returned object needs to be deleted with \TWAccountDelete
  /// \return Null pointer if the associated account is not found, pointer to the account otherwise.
  ffi.Pointer<TWAccount> TWStoredKeyAccount(
    ffi.Pointer<TWStoredKey> key,
    int index,
  ) {
    return _TWStoredKeyAccount(
      key,
      index,
    );
  }

  late final _TWStoredKeyAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>, ffi.Size)>>('TWStoredKeyAccount');
  late final _TWStoredKeyAccount = _TWStoredKeyAccountPtr.asFunction<
      ffi.Pointer<TWAccount> Function(ffi.Pointer<TWStoredKey>, int)>();

  /// Returns the account for a specific coin, creating it if necessary.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin The coin type
  /// \param wallet The associated HD wallet, can be null.
  /// \note Returned object needs to be deleted with \TWAccountDelete
  /// \return Null pointer if the associated account is not found/not created, pointer to the account otherwise.
  ffi.Pointer<TWAccount> TWStoredKeyAccountForCoin(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWStoredKeyAccountForCoin(
      key,
      coin.value,
      wallet,
    );
  }

  late final _TWStoredKeyAccountForCoinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>,
              ffi.UnsignedInt,
              ffi.Pointer<TWHDWallet>)>>('TWStoredKeyAccountForCoin');
  late final _TWStoredKeyAccountForCoin =
      _TWStoredKeyAccountForCoinPtr.asFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>, int, ffi.Pointer<TWHDWallet>)>();

  /// Returns the account for a specific coin + derivation, creating it if necessary.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin The coin type
  /// \param derivation The derivation for the given coin
  /// \param wallet the associated HD wallet, can be null.
  /// \note Returned object needs to be deleted with \TWAccountDelete
  /// \return Null pointer if the associated account is not found/not created, pointer to the account otherwise.
  ffi.Pointer<TWAccount> TWStoredKeyAccountForCoinDerivation(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
    TWDerivation derivation,
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWStoredKeyAccountForCoinDerivation(
      key,
      coin.value,
      derivation.value,
      wallet,
    );
  }

  late final _TWStoredKeyAccountForCoinDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<TWHDWallet>)>>('TWStoredKeyAccountForCoinDerivation');
  late final _TWStoredKeyAccountForCoinDerivation =
      _TWStoredKeyAccountForCoinDerivationPtr.asFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>, int, int, ffi.Pointer<TWHDWallet>)>();

  /// Adds a new account, using given derivation (usually TWDerivationDefault)
  /// and derivation path (usually matches path from derivation, but custom possible).
  ///
  /// \param key Non-null pointer to a stored key
  /// \param address Non-null pointer to the address of the coin for this account
  /// \param coin coin type
  /// \param derivation derivation of the given coin type
  /// \param derivationPath HD bip44 derivation path of the given coin
  /// \param publicKey Non-null public key of the given coin/address
  /// \param extendedPublicKey Non-null extended public key of the given coin/address
  void TWStoredKeyAddAccountDerivation(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWString1> address,
    TWCoinType coin,
    TWDerivation derivation,
    ffi.Pointer<TWString1> derivationPath,
    ffi.Pointer<TWString1> publicKey,
    ffi.Pointer<TWString1> extendedPublicKey,
  ) {
    return _TWStoredKeyAddAccountDerivation(
      key,
      address,
      coin.value,
      derivation.value,
      derivationPath,
      publicKey,
      extendedPublicKey,
    );
  }

  late final _TWStoredKeyAddAccountDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWString1>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWStoredKeyAddAccountDerivation');
  late final _TWStoredKeyAddAccountDerivation =
      _TWStoredKeyAddAccountDerivationPtr.asFunction<
          void Function(
              ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWString1>,
              int,
              int,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>();

  /// Adds a new account, using given derivation path.
  ///
  /// \deprecated Use TWStoredKeyAddAccountDerivation (with TWDerivationDefault) instead.
  /// \param key Non-null pointer to a stored key
  /// \param address Non-null pointer to the address of the coin for this account
  /// \param coin coin type
  /// \param derivationPath HD bip44 derivation path of the given coin
  /// \param publicKey Non-null public key of the given coin/address
  /// \param extendedPublicKey Non-null extended public key of the given coin/address
  void TWStoredKeyAddAccount(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWString1> address,
    TWCoinType coin,
    ffi.Pointer<TWString1> derivationPath,
    ffi.Pointer<TWString1> publicKey,
    ffi.Pointer<TWString1> extendedPublicKey,
  ) {
    return _TWStoredKeyAddAccount(
      key,
      address,
      coin.value,
      derivationPath,
      publicKey,
      extendedPublicKey,
    );
  }

  late final _TWStoredKeyAddAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWString1>,
              ffi.UnsignedInt,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWStoredKeyAddAccount');
  late final _TWStoredKeyAddAccount = _TWStoredKeyAddAccountPtr.asFunction<
      void Function(
          ffi.Pointer<TWStoredKey>,
          ffi.Pointer<TWString1>,
          int,
          ffi.Pointer<TWString1>,
          ffi.Pointer<TWString1>,
          ffi.Pointer<TWString1>)>();

  /// Remove the account for a specific coin
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account coin type to be removed
  void TWStoredKeyRemoveAccountForCoin(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
  ) {
    return _TWStoredKeyRemoveAccountForCoin(
      key,
      coin.value,
    );
  }

  late final _TWStoredKeyRemoveAccountForCoinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWStoredKey>,
              ffi.UnsignedInt)>>('TWStoredKeyRemoveAccountForCoin');
  late final _TWStoredKeyRemoveAccountForCoin =
      _TWStoredKeyRemoveAccountForCoinPtr.asFunction<
          void Function(ffi.Pointer<TWStoredKey>, int)>();

  /// Remove the account for a specific coin with the given derivation.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account coin type to be removed
  /// \param derivation The derivation of the given coin type
  void TWStoredKeyRemoveAccountForCoinDerivation(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
    TWDerivation derivation,
  ) {
    return _TWStoredKeyRemoveAccountForCoinDerivation(
      key,
      coin.value,
      derivation.value,
    );
  }

  late final _TWStoredKeyRemoveAccountForCoinDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWStoredKey>, ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWStoredKeyRemoveAccountForCoinDerivation');
  late final _TWStoredKeyRemoveAccountForCoinDerivation =
      _TWStoredKeyRemoveAccountForCoinDerivationPtr.asFunction<
          void Function(ffi.Pointer<TWStoredKey>, int, int)>();

  /// Remove the account for a specific coin with the given derivation path.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account coin type to be removed
  /// \param derivationPath The derivation path (bip44) of the given coin type
  void TWStoredKeyRemoveAccountForCoinDerivationPath(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
    ffi.Pointer<TWString1> derivationPath,
  ) {
    return _TWStoredKeyRemoveAccountForCoinDerivationPath(
      key,
      coin.value,
      derivationPath,
    );
  }

  late final _TWStoredKeyRemoveAccountForCoinDerivationPathPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<TWStoredKey>, ffi.UnsignedInt,
                  ffi.Pointer<TWString1>)>>(
      'TWStoredKeyRemoveAccountForCoinDerivationPath');
  late final _TWStoredKeyRemoveAccountForCoinDerivationPath =
      _TWStoredKeyRemoveAccountForCoinDerivationPathPtr.asFunction<
          void Function(
              ffi.Pointer<TWStoredKey>, int, ffi.Pointer<TWString1>)>();

  /// Saves the key to a file.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param path Non-null string filepath where the key will be saved
  /// \return true if the key was successfully stored in the given filepath file, false otherwise
  bool TWStoredKeyStore(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWString1> path,
  ) {
    return _TWStoredKeyStore(
      key,
      path,
    );
  }

  late final _TWStoredKeyStorePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWString1>)>>('TWStoredKeyStore');
  late final _TWStoredKeyStore = _TWStoredKeyStorePtr.asFunction<
      bool Function(ffi.Pointer<TWStoredKey>, ffi.Pointer<TWString1>)>();

  /// Decrypts the private key.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \return Decrypted private key as a block of data if success, null pointer otherwise
  ffi.Pointer<TWData1> TWStoredKeyDecryptPrivateKey(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData1> password,
  ) {
    return _TWStoredKeyDecryptPrivateKey(
      key,
      password,
    );
  }

  late final _TWStoredKeyDecryptPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData1>)>>('TWStoredKeyDecryptPrivateKey');
  late final _TWStoredKeyDecryptPrivateKey =
      _TWStoredKeyDecryptPrivateKeyPtr.asFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData1>)>();

  /// Decrypts the mnemonic phrase.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \return Bip39 decrypted mnemonic if success, null pointer otherwise
  ffi.Pointer<TWString1> TWStoredKeyDecryptMnemonic(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData1> password,
  ) {
    return _TWStoredKeyDecryptMnemonic(
      key,
      password,
    );
  }

  late final _TWStoredKeyDecryptMnemonicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData1>)>>('TWStoredKeyDecryptMnemonic');
  late final _TWStoredKeyDecryptMnemonic =
      _TWStoredKeyDecryptMnemonicPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData1>)>();

  /// Returns the private key for a specific coin.  Returned object needs to be deleted.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account coin type to be queried
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return Null pointer on failure, pointer to the private key otherwise
  ffi.Pointer<TWPrivateKey> TWStoredKeyPrivateKey(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
    ffi.Pointer<TWData1> password,
  ) {
    return _TWStoredKeyPrivateKey(
      key,
      coin.value,
      password,
    );
  }

  late final _TWStoredKeyPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWStoredKey>,
              ffi.UnsignedInt, ffi.Pointer<TWData1>)>>('TWStoredKeyPrivateKey');
  late final _TWStoredKeyPrivateKey = _TWStoredKeyPrivateKeyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(
          ffi.Pointer<TWStoredKey>, int, ffi.Pointer<TWData1>)>();

  /// Decrypts and returns the HD Wallet for mnemonic phrase keys.  Returned object needs to be deleted.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Null pointer on failure, pointer to the HDWallet otherwise
  ffi.Pointer<TWHDWallet> TWStoredKeyWallet(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData1> password,
  ) {
    return _TWStoredKeyWallet(
      key,
      password,
    );
  }

  late final _TWStoredKeyWalletPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData1>)>>('TWStoredKeyWallet');
  late final _TWStoredKeyWallet = _TWStoredKeyWalletPtr.asFunction<
      ffi.Pointer<TWHDWallet> Function(
          ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData1>)>();

  /// Exports the key as JSON
  ///
  /// \param key Non-null pointer to a stored key
  /// \return Null pointer on failure, pointer to a block of data containing the json otherwise
  ffi.Pointer<TWData1> TWStoredKeyExportJSON(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyExportJSON(
      key,
    );
  }

  late final _TWStoredKeyExportJSONPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWStoredKey>)>>('TWStoredKeyExportJSON');
  late final _TWStoredKeyExportJSON = _TWStoredKeyExportJSONPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWStoredKey>)>();

  /// Fills in empty and invalid addresses.
  /// This method needs the encryption password to re-derive addresses from private keys.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \return `false` if the password is incorrect, true otherwise.
  bool TWStoredKeyFixAddresses(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData1> password,
  ) {
    return _TWStoredKeyFixAddresses(
      key,
      password,
    );
  }

  late final _TWStoredKeyFixAddressesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData1>)>>('TWStoredKeyFixAddresses');
  late final _TWStoredKeyFixAddresses = _TWStoredKeyFixAddressesPtr.asFunction<
      bool Function(ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData1>)>();

  /// Re-derives address for the account(s) associated with the given coin.
  /// This method can be used if address format has been changed.
  /// In case of multiple accounts, all of them will be updated.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account(s) coin type to be updated
  /// \return `false` if there are no accounts associated with the given coin, true otherwise
  bool TWStoredKeyUpdateAddress(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
  ) {
    return _TWStoredKeyUpdateAddress(
      key,
      coin.value,
    );
  }

  late final _TWStoredKeyUpdateAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWStoredKey>,
              ffi.UnsignedInt)>>('TWStoredKeyUpdateAddress');
  late final _TWStoredKeyUpdateAddress = _TWStoredKeyUpdateAddressPtr
      .asFunction<bool Function(ffi.Pointer<TWStoredKey>, int)>();

  /// Retrieve stored key encoding parameters, as JSON string.
  ///
  /// \param key Non-null pointer to a stored key
  /// \return Null pointer on failure, encoding parameter as a json string otherwise.
  ffi.Pointer<TWString1> TWStoredKeyEncryptionParameters(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyEncryptionParameters(
      key,
    );
  }

  late final _TWStoredKeyEncryptionParametersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWStoredKey>)>>('TWStoredKeyEncryptionParameters');
  late final _TWStoredKeyEncryptionParameters =
      _TWStoredKeyEncryptionParametersPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWStoredKey>)>();

  /// Creates an empty script.
  ///
  /// \return A pointer to the script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptCreate() {
    return _TWBitcoinScriptCreate();
  }

  late final _TWBitcoinScriptCreatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWBitcoinScript> Function()>>(
          'TWBitcoinScriptCreate');
  late final _TWBitcoinScriptCreate = _TWBitcoinScriptCreatePtr.asFunction<
      ffi.Pointer<TWBitcoinScript> Function()>();

  /// Creates a script from a raw data representation.
  ///
  /// \param data The data buffer
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptCreateWithData(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWBitcoinScriptCreateWithData(
      data,
    );
  }

  late final _TWBitcoinScriptCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWData1>)>>('TWBitcoinScriptCreateWithData');
  late final _TWBitcoinScriptCreateWithData =
      _TWBitcoinScriptCreateWithDataPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData1>)>();

  /// Creates a script from a raw bytes and size.
  ///
  /// \param bytes The buffer
  /// \param size The size of the buffer
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptCreateWithBytes(
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _TWBitcoinScriptCreateWithBytes(
      bytes,
      size,
    );
  }

  late final _TWBitcoinScriptCreateWithBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('TWBitcoinScriptCreateWithBytes');
  late final _TWBitcoinScriptCreateWithBytes =
      _TWBitcoinScriptCreateWithBytesPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Creates a script by copying an existing script.
  ///
  /// \param script Non-null pointer to a script
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptCreateCopy(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptCreateCopy(
      script,
    );
  }

  late final _TWBitcoinScriptCreateCopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWBitcoinScript>)>>('TWBitcoinScriptCreateCopy');
  late final _TWBitcoinScriptCreateCopy =
      _TWBitcoinScriptCreateCopyPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWBitcoinScript>)>();

  /// Delete/Deallocate a given script.
  ///
  /// \param script Non-null pointer to a script
  void TWBitcoinScriptDelete(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptDelete(
      script,
    );
  }

  late final _TWBitcoinScriptDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptDelete');
  late final _TWBitcoinScriptDelete = _TWBitcoinScriptDeletePtr.asFunction<
      void Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Get size of a script
  ///
  /// \param script Non-null pointer to a script
  /// \return size of the script
  int TWBitcoinScriptSize(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptSize(
      script,
    );
  }

  late final _TWBitcoinScriptSizePtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptSize');
  late final _TWBitcoinScriptSize = _TWBitcoinScriptSizePtr.asFunction<
      int Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Get data of a script
  ///
  /// \param script Non-null pointer to a script
  /// \return data of the given script
  ffi.Pointer<TWData1> TWBitcoinScriptData(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptData(
      script,
    );
  }

  late final _TWBitcoinScriptDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWBitcoinScript>)>>('TWBitcoinScriptData');
  late final _TWBitcoinScriptData = _TWBitcoinScriptDataPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Return script hash of a script
  ///
  /// \param script Non-null pointer to a script
  /// \return script hash of the given script
  ffi.Pointer<TWData1> TWBitcoinScriptScriptHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptScriptHash(
      script,
    );
  }

  late final _TWBitcoinScriptScriptHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWBitcoinScript>)>>('TWBitcoinScriptScriptHash');
  late final _TWBitcoinScriptScriptHash =
      _TWBitcoinScriptScriptHashPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Determines whether this is a pay-to-script-hash (P2SH) script.
  ///
  /// \param script Non-null pointer to a script
  /// \return true if this is a pay-to-script-hash (P2SH) script, false otherwise
  bool TWBitcoinScriptIsPayToScriptHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptIsPayToScriptHash(
      script,
    );
  }

  late final _TWBitcoinScriptIsPayToScriptHashPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptIsPayToScriptHash');
  late final _TWBitcoinScriptIsPayToScriptHash =
      _TWBitcoinScriptIsPayToScriptHashPtr.asFunction<
          bool Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Determines whether this is a pay-to-witness-script-hash (P2WSH) script.
  ///
  /// \param script Non-null pointer to a script
  /// \return true if this is a pay-to-witness-script-hash (P2WSH) script, false otherwise
  bool TWBitcoinScriptIsPayToWitnessScriptHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptIsPayToWitnessScriptHash(
      script,
    );
  }

  late final _TWBitcoinScriptIsPayToWitnessScriptHashPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptIsPayToWitnessScriptHash');
  late final _TWBitcoinScriptIsPayToWitnessScriptHash =
      _TWBitcoinScriptIsPayToWitnessScriptHashPtr.asFunction<
          bool Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Determines whether this is a pay-to-witness-public-key-hash (P2WPKH) script.
  ///
  /// \param script Non-null pointer to a script
  /// \return true if this is a pay-to-witness-public-key-hash (P2WPKH) script, false otherwise
  bool TWBitcoinScriptIsPayToWitnessPublicKeyHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptIsPayToWitnessPublicKeyHash(
      script,
    );
  }

  late final _TWBitcoinScriptIsPayToWitnessPublicKeyHashPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptIsPayToWitnessPublicKeyHash');
  late final _TWBitcoinScriptIsPayToWitnessPublicKeyHash =
      _TWBitcoinScriptIsPayToWitnessPublicKeyHashPtr.asFunction<
          bool Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Determines whether this is a witness program script.
  ///
  /// \param script Non-null pointer to a script
  /// \return true if this is a witness program script, false otherwise
  bool TWBitcoinScriptIsWitnessProgram(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptIsWitnessProgram(
      script,
    );
  }

  late final _TWBitcoinScriptIsWitnessProgramPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptIsWitnessProgram');
  late final _TWBitcoinScriptIsWitnessProgram =
      _TWBitcoinScriptIsWitnessProgramPtr.asFunction<
          bool Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Determines whether 2 scripts have the same content
  ///
  /// \param lhs Non-null pointer to the first script
  /// \param rhs Non-null pointer to the second script
  /// \return true if both script have the same content
  bool TWBitcoinScriptEqual(
    ffi.Pointer<TWBitcoinScript> lhs,
    ffi.Pointer<TWBitcoinScript> rhs,
  ) {
    return _TWBitcoinScriptEqual(
      lhs,
      rhs,
    );
  }

  late final _TWBitcoinScriptEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWBitcoinScript>,
              ffi.Pointer<TWBitcoinScript>)>>('TWBitcoinScriptEqual');
  late final _TWBitcoinScriptEqual = _TWBitcoinScriptEqualPtr.asFunction<
      bool Function(
          ffi.Pointer<TWBitcoinScript>, ffi.Pointer<TWBitcoinScript>)>();

  /// Matches the script to a pay-to-public-key (P2PK) script.
  ///
  /// \param script Non-null pointer to a script
  /// \return The public key.
  ffi.Pointer<TWData1> TWBitcoinScriptMatchPayToPubkey(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptMatchPayToPubkey(
      script,
    );
  }

  late final _TWBitcoinScriptMatchPayToPubkeyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptMatchPayToPubkey');
  late final _TWBitcoinScriptMatchPayToPubkey =
      _TWBitcoinScriptMatchPayToPubkeyPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Matches the script to a pay-to-public-key-hash (P2PKH).
  ///
  /// \param script Non-null pointer to a script
  /// \return the key hash.
  ffi.Pointer<TWData1> TWBitcoinScriptMatchPayToPubkeyHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptMatchPayToPubkeyHash(
      script,
    );
  }

  late final _TWBitcoinScriptMatchPayToPubkeyHashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptMatchPayToPubkeyHash');
  late final _TWBitcoinScriptMatchPayToPubkeyHash =
      _TWBitcoinScriptMatchPayToPubkeyHashPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Matches the script to a pay-to-script-hash (P2SH).
  ///
  /// \param script Non-null pointer to a script
  /// \return the script hash.
  ffi.Pointer<TWData1> TWBitcoinScriptMatchPayToScriptHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptMatchPayToScriptHash(
      script,
    );
  }

  late final _TWBitcoinScriptMatchPayToScriptHashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptMatchPayToScriptHash');
  late final _TWBitcoinScriptMatchPayToScriptHash =
      _TWBitcoinScriptMatchPayToScriptHashPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Matches the script to a pay-to-witness-public-key-hash (P2WPKH).
  ///
  /// \param script Non-null pointer to a script
  /// \return the key hash.
  ffi.Pointer<TWData1> TWBitcoinScriptMatchPayToWitnessPublicKeyHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptMatchPayToWitnessPublicKeyHash(
      script,
    );
  }

  late final _TWBitcoinScriptMatchPayToWitnessPublicKeyHashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptMatchPayToWitnessPublicKeyHash');
  late final _TWBitcoinScriptMatchPayToWitnessPublicKeyHash =
      _TWBitcoinScriptMatchPayToWitnessPublicKeyHashPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Matches the script to a pay-to-witness-script-hash (P2WSH).
  ///
  /// \param script Non-null pointer to a script
  /// \return the script hash, a SHA256 of the witness script..
  ffi.Pointer<TWData1> TWBitcoinScriptMatchPayToWitnessScriptHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptMatchPayToWitnessScriptHash(
      script,
    );
  }

  late final _TWBitcoinScriptMatchPayToWitnessScriptHashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptMatchPayToWitnessScriptHash');
  late final _TWBitcoinScriptMatchPayToWitnessScriptHash =
      _TWBitcoinScriptMatchPayToWitnessScriptHashPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Encodes the script.
  ///
  /// \param script Non-null pointer to a script
  /// \return The encoded script
  ffi.Pointer<TWData1> TWBitcoinScriptEncode(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptEncode(
      script,
    );
  }

  late final _TWBitcoinScriptEncodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWBitcoinScript>)>>('TWBitcoinScriptEncode');
  late final _TWBitcoinScriptEncode = _TWBitcoinScriptEncodePtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Builds a standard 'pay to public key' script.
  ///
  /// \param pubkey Non-null pointer to a pubkey
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the built script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptBuildPayToPublicKey(
    ffi.Pointer<TWData1> pubkey,
  ) {
    return _TWBitcoinScriptBuildPayToPublicKey(
      pubkey,
    );
  }

  late final _TWBitcoinScriptBuildPayToPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWData1>)>>('TWBitcoinScriptBuildPayToPublicKey');
  late final _TWBitcoinScriptBuildPayToPublicKey =
      _TWBitcoinScriptBuildPayToPublicKeyPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData1>)>();

  /// Builds a standard 'pay to public key hash' script.
  ///
  /// \param hash Non-null pointer to a PublicKey hash
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the built script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptBuildPayToPublicKeyHash(
    ffi.Pointer<TWData1> hash,
  ) {
    return _TWBitcoinScriptBuildPayToPublicKeyHash(
      hash,
    );
  }

  late final _TWBitcoinScriptBuildPayToPublicKeyHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWData1>)>>('TWBitcoinScriptBuildPayToPublicKeyHash');
  late final _TWBitcoinScriptBuildPayToPublicKeyHash =
      _TWBitcoinScriptBuildPayToPublicKeyHashPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData1>)>();

  /// Builds a standard 'pay to script hash' script.
  ///
  /// \param scriptHash Non-null pointer to a script hash
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the built script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptBuildPayToScriptHash(
    ffi.Pointer<TWData1> scriptHash,
  ) {
    return _TWBitcoinScriptBuildPayToScriptHash(
      scriptHash,
    );
  }

  late final _TWBitcoinScriptBuildPayToScriptHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWData1>)>>('TWBitcoinScriptBuildPayToScriptHash');
  late final _TWBitcoinScriptBuildPayToScriptHash =
      _TWBitcoinScriptBuildPayToScriptHashPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData1>)>();

  /// Builds a pay-to-witness-public-key-hash (P2WPKH) script..
  ///
  /// \param hash Non-null pointer to a witness public key hash
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the built script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptBuildPayToWitnessPubkeyHash(
    ffi.Pointer<TWData1> hash,
  ) {
    return _TWBitcoinScriptBuildPayToWitnessPubkeyHash(
      hash,
    );
  }

  late final _TWBitcoinScriptBuildPayToWitnessPubkeyHashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData1>)>>(
      'TWBitcoinScriptBuildPayToWitnessPubkeyHash');
  late final _TWBitcoinScriptBuildPayToWitnessPubkeyHash =
      _TWBitcoinScriptBuildPayToWitnessPubkeyHashPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData1>)>();

  /// Builds a pay-to-witness-script-hash (P2WSH) script.
  ///
  /// \param scriptHash Non-null pointer to a script hash
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the built script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptBuildPayToWitnessScriptHash(
    ffi.Pointer<TWData1> scriptHash,
  ) {
    return _TWBitcoinScriptBuildPayToWitnessScriptHash(
      scriptHash,
    );
  }

  late final _TWBitcoinScriptBuildPayToWitnessScriptHashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData1>)>>(
      'TWBitcoinScriptBuildPayToWitnessScriptHash');
  late final _TWBitcoinScriptBuildPayToWitnessScriptHash =
      _TWBitcoinScriptBuildPayToWitnessScriptHashPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData1>)>();

  /// Builds a appropriate lock script for the given address..
  ///
  /// \param address Non-null pointer to an address
  /// \param coin coin type
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the built script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptLockScriptForAddress(
    ffi.Pointer<TWString1> address,
    TWCoinType coin,
  ) {
    return _TWBitcoinScriptLockScriptForAddress(
      address,
      coin.value,
    );
  }

  late final _TWBitcoinScriptLockScriptForAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWString1>,
              ffi.UnsignedInt)>>('TWBitcoinScriptLockScriptForAddress');
  late final _TWBitcoinScriptLockScriptForAddress =
      _TWBitcoinScriptLockScriptForAddressPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWString1>, int)>();

  /// Builds a appropriate lock script for the given address with replay.
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptLockScriptForAddressReplay(
    ffi.Pointer<TWString1> address,
    TWCoinType coin,
    ffi.Pointer<TWData1> blockHash,
    int blockHeight,
  ) {
    return _TWBitcoinScriptLockScriptForAddressReplay(
      address,
      coin.value,
      blockHash,
      blockHeight,
    );
  }

  late final _TWBitcoinScriptLockScriptForAddressReplayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWString1>,
              ffi.UnsignedInt,
              ffi.Pointer<TWData1>,
              ffi.Int64)>>('TWBitcoinScriptLockScriptForAddressReplay');
  late final _TWBitcoinScriptLockScriptForAddressReplay =
      _TWBitcoinScriptLockScriptForAddressReplayPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWString1>, int, ffi.Pointer<TWData1>, int)>();

  /// Return the default HashType for the given coin, such as TWBitcoinSigHashTypeAll.
  ///
  /// \param coinType coin type
  /// \return default HashType for the given coin
  int TWBitcoinScriptHashTypeForCoin(
    TWCoinType coinType,
  ) {
    return _TWBitcoinScriptHashTypeForCoin(
      coinType.value,
    );
  }

  late final _TWBitcoinScriptHashTypeForCoinPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.UnsignedInt)>>(
          'TWBitcoinScriptHashTypeForCoin');
  late final _TWBitcoinScriptHashTypeForCoin =
      _TWBitcoinScriptHashTypeForCoinPtr.asFunction<int Function(int)>();

  /// Create a FIO Account
  ///
  /// \param string Account name
  /// \note Must be deleted with \TWFIOAccountDelete
  /// \return Pointer to a nullable FIO Account
  ffi.Pointer<TWFIOAccount> TWFIOAccountCreateWithString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWFIOAccountCreateWithString(
      string,
    );
  }

  late final _TWFIOAccountCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWFIOAccount> Function(
              ffi.Pointer<TWString1>)>>('TWFIOAccountCreateWithString');
  late final _TWFIOAccountCreateWithString = _TWFIOAccountCreateWithStringPtr
      .asFunction<ffi.Pointer<TWFIOAccount> Function(ffi.Pointer<TWString1>)>();

  /// Delete a FIO Account
  ///
  /// \param account Pointer to a non-null FIO Account
  void TWFIOAccountDelete(
    ffi.Pointer<TWFIOAccount> account,
  ) {
    return _TWFIOAccountDelete(
      account,
    );
  }

  late final _TWFIOAccountDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWFIOAccount>)>>(
          'TWFIOAccountDelete');
  late final _TWFIOAccountDelete = _TWFIOAccountDeletePtr.asFunction<
      void Function(ffi.Pointer<TWFIOAccount>)>();

  /// Returns the short account string representation.
  ///
  /// \param account Pointer to a non-null FIO Account
  /// \return Account non-null string representation
  ffi.Pointer<TWString1> TWFIOAccountDescription(
    ffi.Pointer<TWFIOAccount> account,
  ) {
    return _TWFIOAccountDescription(
      account,
    );
  }

  late final _TWFIOAccountDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWFIOAccount>)>>('TWFIOAccountDescription');
  late final _TWFIOAccountDescription = _TWFIOAccountDescriptionPtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWFIOAccount>)>();

  /// Compares two addresses for equality.
  ///
  /// \param lhs left Non-null GroestlCoin address to be compared
  /// \param rhs right Non-null GroestlCoin address to be compared
  /// \return true if both address are equal, false otherwise
  bool TWGroestlcoinAddressEqual(
    ffi.Pointer<TWGroestlcoinAddress> lhs,
    ffi.Pointer<TWGroestlcoinAddress> rhs,
  ) {
    return _TWGroestlcoinAddressEqual(
      lhs,
      rhs,
    );
  }

  late final _TWGroestlcoinAddressEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWGroestlcoinAddress>,
              ffi.Pointer<TWGroestlcoinAddress>)>>('TWGroestlcoinAddressEqual');
  late final _TWGroestlcoinAddressEqual =
      _TWGroestlcoinAddressEqualPtr.asFunction<
          bool Function(ffi.Pointer<TWGroestlcoinAddress>,
              ffi.Pointer<TWGroestlcoinAddress>)>();

  /// Determines if the string is a valid Groestlcoin address.
  ///
  /// \param string Non-null string.
  /// \return true if it's a valid address, false otherwise
  bool TWGroestlcoinAddressIsValidString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWGroestlcoinAddressIsValidString(
      string,
    );
  }

  late final _TWGroestlcoinAddressIsValidStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString1>)>>(
          'TWGroestlcoinAddressIsValidString');
  late final _TWGroestlcoinAddressIsValidString =
      _TWGroestlcoinAddressIsValidStringPtr.asFunction<
          bool Function(ffi.Pointer<TWString1>)>();

  /// Create an address from a base58 string representation.
  ///
  /// \param string Non-null string
  /// \note Must be deleted with \TWGroestlcoinAddressDelete
  /// \return Non-null GroestlcoinAddress
  ffi.Pointer<TWGroestlcoinAddress> TWGroestlcoinAddressCreateWithString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWGroestlcoinAddressCreateWithString(
      string,
    );
  }

  late final _TWGroestlcoinAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWGroestlcoinAddress> Function(
              ffi.Pointer<TWString1>)>>('TWGroestlcoinAddressCreateWithString');
  late final _TWGroestlcoinAddressCreateWithString =
      _TWGroestlcoinAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWGroestlcoinAddress> Function(ffi.Pointer<TWString1>)>();

  /// Create an address from a public key and a prefix byte.
  ///
  /// \param publicKey Non-null public key
  /// \param prefix public key prefix
  /// \note Must be deleted with \TWGroestlcoinAddressDelete
  /// \return Non-null GroestlcoinAddress
  ffi.Pointer<TWGroestlcoinAddress> TWGroestlcoinAddressCreateWithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    int prefix,
  ) {
    return _TWGroestlcoinAddressCreateWithPublicKey(
      publicKey,
      prefix,
    );
  }

  late final _TWGroestlcoinAddressCreateWithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWGroestlcoinAddress> Function(ffi.Pointer<TWPublicKey>,
              ffi.Uint8)>>('TWGroestlcoinAddressCreateWithPublicKey');
  late final _TWGroestlcoinAddressCreateWithPublicKey =
      _TWGroestlcoinAddressCreateWithPublicKeyPtr.asFunction<
          ffi.Pointer<TWGroestlcoinAddress> Function(
              ffi.Pointer<TWPublicKey>, int)>();

  /// Delete a Groestlcoin address
  ///
  /// \param address Non-null GroestlcoinAddress
  void TWGroestlcoinAddressDelete(
    ffi.Pointer<TWGroestlcoinAddress> address,
  ) {
    return _TWGroestlcoinAddressDelete(
      address,
    );
  }

  late final _TWGroestlcoinAddressDeletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<TWGroestlcoinAddress>)>>(
      'TWGroestlcoinAddressDelete');
  late final _TWGroestlcoinAddressDelete = _TWGroestlcoinAddressDeletePtr
      .asFunction<void Function(ffi.Pointer<TWGroestlcoinAddress>)>();

  /// Returns the address base58 string representation.
  ///
  /// \param address Non-null GroestlcoinAddress
  /// \return Address description as a non-null string
  ffi.Pointer<TWString1> TWGroestlcoinAddressDescription(
    ffi.Pointer<TWGroestlcoinAddress> address,
  ) {
    return _TWGroestlcoinAddressDescription(
      address,
    );
  }

  late final _TWGroestlcoinAddressDescriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString1> Function(
                  ffi.Pointer<TWGroestlcoinAddress>)>>(
      'TWGroestlcoinAddressDescription');
  late final _TWGroestlcoinAddressDescription =
      _TWGroestlcoinAddressDescriptionPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWGroestlcoinAddress>)>();

  /// Encrypts message using `my_secret` and `other_pubkey`.
  /// The output will have a randomly generated nonce prepended to it.
  /// The output will be Overhead + 24 bytes longer than the original.
  ///
  /// \param mySecret *non-null* pointer to my secret key.
  /// \param otherPubkey *non-null* pointer to other's public key.
  /// \param message *non-null* pointer to the message to be encrypted.
  /// \return *nullable* pointer to the encrypted message with randomly generated nonce prepended to it.
  ffi.Pointer<TWData> TWCryptoBoxEncryptEasy(
    ffi.Pointer<TWCryptoBoxSecretKey> mySecret,
    ffi.Pointer<TWCryptoBoxPublicKey> otherPubkey,
    ffi.Pointer<TWData> message,
  ) {
    return _TWCryptoBoxEncryptEasy(
      mySecret,
      otherPubkey,
      message,
    );
  }

  late final _TWCryptoBoxEncryptEasyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWCryptoBoxSecretKey>,
              ffi.Pointer<TWCryptoBoxPublicKey>,
              ffi.Pointer<TWData>)>>('TWCryptoBoxEncryptEasy');
  late final _TWCryptoBoxEncryptEasy = _TWCryptoBoxEncryptEasyPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWCryptoBoxSecretKey>,
          ffi.Pointer<TWCryptoBoxPublicKey>, ffi.Pointer<TWData>)>();

  /// Decrypts box produced by `TWCryptoBoxEncryptEasy`.
  /// We assume a 24-byte nonce is prepended to the encrypted text in box.
  ///
  /// \param mySecret *non-null* pointer to my secret key.
  /// \param otherPubkey *non-null* pointer to other's public key.
  /// \param encrypted *non-null* pointer to the encrypted message with nonce prepended to it.
  /// \return *nullable* pointer to the decrypted message.
  ffi.Pointer<TWData> TWCryptoBoxDecryptEasy(
    ffi.Pointer<TWCryptoBoxSecretKey> mySecret,
    ffi.Pointer<TWCryptoBoxPublicKey> otherPubkey,
    ffi.Pointer<TWData> encrypted,
  ) {
    return _TWCryptoBoxDecryptEasy(
      mySecret,
      otherPubkey,
      encrypted,
    );
  }

  late final _TWCryptoBoxDecryptEasyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWCryptoBoxSecretKey>,
              ffi.Pointer<TWCryptoBoxPublicKey>,
              ffi.Pointer<TWData>)>>('TWCryptoBoxDecryptEasy');
  late final _TWCryptoBoxDecryptEasy = _TWCryptoBoxDecryptEasyPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWCryptoBoxSecretKey>,
          ffi.Pointer<TWCryptoBoxPublicKey>, ffi.Pointer<TWData>)>();

  /// Determines whether a BIP39 English mnemonic phrase is valid.
  ///
  /// \param mnemonic Non-null BIP39 english mnemonic
  /// \return true if the mnemonic is valid, false otherwise
  bool TWMnemonicIsValid(
    ffi.Pointer<TWString1> mnemonic,
  ) {
    return _TWMnemonicIsValid(
      mnemonic,
    );
  }

  late final _TWMnemonicIsValidPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString1>)>>(
          'TWMnemonicIsValid');
  late final _TWMnemonicIsValid =
      _TWMnemonicIsValidPtr.asFunction<bool Function(ffi.Pointer<TWString1>)>();

  /// Determines whether word is a valid BIP39 English mnemonic word.
  ///
  /// \param word Non-null BIP39 English mnemonic word
  /// \return true if the word is a valid BIP39 English mnemonic word, false otherwise
  bool TWMnemonicIsValidWord(
    ffi.Pointer<TWString1> word,
  ) {
    return _TWMnemonicIsValidWord(
      word,
    );
  }

  late final _TWMnemonicIsValidWordPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString1>)>>(
          'TWMnemonicIsValidWord');
  late final _TWMnemonicIsValidWord = _TWMnemonicIsValidWordPtr.asFunction<
      bool Function(ffi.Pointer<TWString1>)>();

  /// Return BIP39 English words that match the given prefix. A single string is returned, with space-separated list of words.
  ///
  /// \param prefix Non-null string prefix
  /// \return Single non-null string, space-separated list of words containing BIP39 words that match the given prefix.
  ffi.Pointer<TWString1> TWMnemonicSuggest(
    ffi.Pointer<TWString1> prefix,
  ) {
    return _TWMnemonicSuggest(
      prefix,
    );
  }

  late final _TWMnemonicSuggestPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWString1>)>>('TWMnemonicSuggest');
  late final _TWMnemonicSuggest = _TWMnemonicSuggestPtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>)>();

  /// Creates a function object, with the given name and empty parameter list.  It must be deleted at the end.
  ///
  /// \param name function name
  /// \return Non-null Ethereum abi function
  ffi.Pointer<TWEthereumAbiFunction> TWEthereumAbiFunctionCreateWithString(
    ffi.Pointer<TWString> name,
  ) {
    return _TWEthereumAbiFunctionCreateWithString(
      name,
    );
  }

  late final _TWEthereumAbiFunctionCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWEthereumAbiFunction> Function(
              ffi.Pointer<TWString>)>>('TWEthereumAbiFunctionCreateWithString');
  late final _TWEthereumAbiFunctionCreateWithString =
      _TWEthereumAbiFunctionCreateWithStringPtr.asFunction<
          ffi.Pointer<TWEthereumAbiFunction> Function(ffi.Pointer<TWString>)>();

  /// Deletes a function object created with a 'TWEthereumAbiFunctionCreateWithString' method.
  ///
  /// \param fn Non-null Ethereum abi function
  void TWEthereumAbiFunctionDelete(
    ffi.Pointer<TWEthereumAbiFunction> fn,
  ) {
    return _TWEthereumAbiFunctionDelete(
      fn,
    );
  }

  late final _TWEthereumAbiFunctionDeletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<TWEthereumAbiFunction>)>>(
      'TWEthereumAbiFunctionDelete');
  late final _TWEthereumAbiFunctionDelete = _TWEthereumAbiFunctionDeletePtr
      .asFunction<void Function(ffi.Pointer<TWEthereumAbiFunction>)>();

  /// Return the function type signature, of the form "baz(int32,uint256)"
  ///
  /// \param fn A Non-null eth abi function
  /// \return function type signature as a Non-null string.
  ffi.Pointer<TWString> TWEthereumAbiFunctionGetType(
    ffi.Pointer<TWEthereumAbiFunction> fn,
  ) {
    return _TWEthereumAbiFunctionGetType(
      fn,
    );
  }

  late final _TWEthereumAbiFunctionGetTypePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(
                  ffi.Pointer<TWEthereumAbiFunction>)>>(
      'TWEthereumAbiFunctionGetType');
  late final _TWEthereumAbiFunctionGetType =
      _TWEthereumAbiFunctionGetTypePtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWEthereumAbiFunction>)>();

  /// Add a uint8 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamUInt8(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamUInt8(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamUInt8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Uint8,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamUInt8');
  late final _TWEthereumAbiFunctionAddParamUInt8 =
      _TWEthereumAbiFunctionAddParamUInt8Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a uint16 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamUInt16(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamUInt16(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamUInt16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Uint16,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamUInt16');
  late final _TWEthereumAbiFunctionAddParamUInt16 =
      _TWEthereumAbiFunctionAddParamUInt16Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a uint32 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamUInt32(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamUInt32(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamUInt32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Uint32,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamUInt32');
  late final _TWEthereumAbiFunctionAddParamUInt32 =
      _TWEthereumAbiFunctionAddParamUInt32Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a uint64 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamUInt64(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamUInt64(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamUInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Uint64,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamUInt64');
  late final _TWEthereumAbiFunctionAddParamUInt64 =
      _TWEthereumAbiFunctionAddParamUInt64Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a uint256 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamUInt256(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    ffi.Pointer<TWData> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamUInt256(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamUInt256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWData>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamUInt256');
  late final _TWEthereumAbiFunctionAddParamUInt256 =
      _TWEthereumAbiFunctionAddParamUInt256Ptr.asFunction<
          int Function(
              ffi.Pointer<TWEthereumAbiFunction>, ffi.Pointer<TWData>, bool)>();

  /// Add a uint(bits) type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamUIntN(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int bits,
    ffi.Pointer<TWData> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamUIntN(
      fn,
      bits,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamUIntNPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Int,
              ffi.Pointer<TWData>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamUIntN');
  late final _TWEthereumAbiFunctionAddParamUIntN =
      _TWEthereumAbiFunctionAddParamUIntNPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int,
              ffi.Pointer<TWData>, bool)>();

  /// Add a int8 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamInt8(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamInt8(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamInt8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int8,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamInt8');
  late final _TWEthereumAbiFunctionAddParamInt8 =
      _TWEthereumAbiFunctionAddParamInt8Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a int16 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamInt16(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamInt16(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamInt16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int16,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamInt16');
  late final _TWEthereumAbiFunctionAddParamInt16 =
      _TWEthereumAbiFunctionAddParamInt16Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a int32 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamInt32(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamInt32(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamInt32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int32,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamInt32');
  late final _TWEthereumAbiFunctionAddParamInt32 =
      _TWEthereumAbiFunctionAddParamInt32Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a int64 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamInt64(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamInt64(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int64,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamInt64');
  late final _TWEthereumAbiFunctionAddParamInt64 =
      _TWEthereumAbiFunctionAddParamInt64Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a int256 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified (stored in a block of data)
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamInt256(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    ffi.Pointer<TWData> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamInt256(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamInt256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWData>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamInt256');
  late final _TWEthereumAbiFunctionAddParamInt256 =
      _TWEthereumAbiFunctionAddParamInt256Ptr.asFunction<
          int Function(
              ffi.Pointer<TWEthereumAbiFunction>, ffi.Pointer<TWData>, bool)>();

  /// Add a int(bits) type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param bits Number of bits of the integer parameter
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamIntN(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int bits,
    ffi.Pointer<TWData> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamIntN(
      fn,
      bits,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamIntNPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Int,
              ffi.Pointer<TWData>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamIntN');
  late final _TWEthereumAbiFunctionAddParamIntN =
      _TWEthereumAbiFunctionAddParamIntNPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int,
              ffi.Pointer<TWData>, bool)>();

  /// Add a bool type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamBool(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    bool val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamBool(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamBoolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Bool,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamBool');
  late final _TWEthereumAbiFunctionAddParamBool =
      _TWEthereumAbiFunctionAddParamBoolPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, bool, bool)>();

  /// Add a string type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamString(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    ffi.Pointer<TWString> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamString(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWString>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamString');
  late final _TWEthereumAbiFunctionAddParamString =
      _TWEthereumAbiFunctionAddParamStringPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWString>, bool)>();

  /// Add an address type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamAddress(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    ffi.Pointer<TWData> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamAddress(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWData>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamAddress');
  late final _TWEthereumAbiFunctionAddParamAddress =
      _TWEthereumAbiFunctionAddParamAddressPtr.asFunction<
          int Function(
              ffi.Pointer<TWEthereumAbiFunction>, ffi.Pointer<TWData>, bool)>();

  /// Add a bytes type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamBytes(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    ffi.Pointer<TWData> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamBytes(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWData>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamBytes');
  late final _TWEthereumAbiFunctionAddParamBytes =
      _TWEthereumAbiFunctionAddParamBytesPtr.asFunction<
          int Function(
              ffi.Pointer<TWEthereumAbiFunction>, ffi.Pointer<TWData>, bool)>();

  /// Add a bytes[N] type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param size fixed size of the bytes array parameter (val).
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamBytesFix(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int size,
    ffi.Pointer<TWData> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamBytesFix(
      fn,
      size,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamBytesFixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Size,
              ffi.Pointer<TWData>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamBytesFix');
  late final _TWEthereumAbiFunctionAddParamBytesFix =
      _TWEthereumAbiFunctionAddParamBytesFixPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int,
              ffi.Pointer<TWData>, bool)>();

  /// Add a type[] type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamArray(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamArray(
      fn,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamArray');
  late final _TWEthereumAbiFunctionAddParamArray =
      _TWEthereumAbiFunctionAddParamArrayPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, bool)>();

  /// Get a uint8 type parameter at the given index
  ///
  /// \param fn A Non-null eth abi function
  /// \param idx index for the parameter (0-based).
  /// \param isOutput determines if the parameter is an input or output
  /// \return the value of the parameter.
  int TWEthereumAbiFunctionGetParamUInt8(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int idx,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionGetParamUInt8(
      fn,
      idx,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionGetParamUInt8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Bool)>>('TWEthereumAbiFunctionGetParamUInt8');
  late final _TWEthereumAbiFunctionGetParamUInt8 =
      _TWEthereumAbiFunctionGetParamUInt8Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Get a uint64 type parameter at the given index
  ///
  /// \param fn A Non-null eth abi function
  /// \param idx index for the parameter (0-based).
  /// \param isOutput determines if the parameter is an input or output
  /// \return the value of the parameter.
  int TWEthereumAbiFunctionGetParamUInt64(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int idx,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionGetParamUInt64(
      fn,
      idx,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionGetParamUInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Bool)>>('TWEthereumAbiFunctionGetParamUInt64');
  late final _TWEthereumAbiFunctionGetParamUInt64 =
      _TWEthereumAbiFunctionGetParamUInt64Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Get a uint256 type parameter at the given index
  ///
  /// \param fn A Non-null eth abi function
  /// \param idx index for the parameter (0-based).
  /// \param isOutput determines if the parameter is an input or output
  /// \return the value of the parameter stored in a block of data.
  ffi.Pointer<TWData> TWEthereumAbiFunctionGetParamUInt256(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int idx,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionGetParamUInt256(
      fn,
      idx,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionGetParamUInt256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Int, ffi.Bool)>>('TWEthereumAbiFunctionGetParamUInt256');
  late final _TWEthereumAbiFunctionGetParamUInt256 =
      _TWEthereumAbiFunctionGetParamUInt256Ptr.asFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Get a bool type parameter at the given index
  ///
  /// \param fn A Non-null eth abi function
  /// \param idx index for the parameter (0-based).
  /// \param isOutput determines if the parameter is an input or output
  /// \return the value of the parameter.
  bool TWEthereumAbiFunctionGetParamBool(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int idx,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionGetParamBool(
      fn,
      idx,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionGetParamBoolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Bool)>>('TWEthereumAbiFunctionGetParamBool');
  late final _TWEthereumAbiFunctionGetParamBool =
      _TWEthereumAbiFunctionGetParamBoolPtr.asFunction<
          bool Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Get a string type parameter at the given index
  ///
  /// \param fn A Non-null eth abi function
  /// \param idx index for the parameter (0-based).
  /// \param isOutput determines if the parameter is an input or output
  /// \return the value of the parameter.
  ffi.Pointer<TWString> TWEthereumAbiFunctionGetParamString(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int idx,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionGetParamString(
      fn,
      idx,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionGetParamStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Int, ffi.Bool)>>('TWEthereumAbiFunctionGetParamString');
  late final _TWEthereumAbiFunctionGetParamString =
      _TWEthereumAbiFunctionGetParamStringPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Get an address type parameter at the given index
  ///
  /// \param fn A Non-null eth abi function
  /// \param idx index for the parameter (0-based).
  /// \param isOutput determines if the parameter is an input or output
  /// \return the value of the parameter.
  ffi.Pointer<TWData> TWEthereumAbiFunctionGetParamAddress(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int idx,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionGetParamAddress(
      fn,
      idx,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionGetParamAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Int, ffi.Bool)>>('TWEthereumAbiFunctionGetParamAddress');
  late final _TWEthereumAbiFunctionGetParamAddress =
      _TWEthereumAbiFunctionGetParamAddressPtr.asFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Adding a uint8 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamUInt8(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamUInt8(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamUInt8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Uint8)>>('TWEthereumAbiFunctionAddInArrayParamUInt8');
  late final _TWEthereumAbiFunctionAddInArrayParamUInt8 =
      _TWEthereumAbiFunctionAddInArrayParamUInt8Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a uint16 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamUInt16(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamUInt16(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamUInt16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Uint16)>>('TWEthereumAbiFunctionAddInArrayParamUInt16');
  late final _TWEthereumAbiFunctionAddInArrayParamUInt16 =
      _TWEthereumAbiFunctionAddInArrayParamUInt16Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a uint32 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamUInt32(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamUInt32(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamUInt32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Uint32)>>('TWEthereumAbiFunctionAddInArrayParamUInt32');
  late final _TWEthereumAbiFunctionAddInArrayParamUInt32 =
      _TWEthereumAbiFunctionAddInArrayParamUInt32Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a uint64 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamUInt64(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamUInt64(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamUInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Uint64)>>('TWEthereumAbiFunctionAddInArrayParamUInt64');
  late final _TWEthereumAbiFunctionAddInArrayParamUInt64 =
      _TWEthereumAbiFunctionAddInArrayParamUInt64Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a uint256 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter stored in a block of data
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamUInt256(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    ffi.Pointer<TWData> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamUInt256(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamUInt256Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Pointer<TWData>)>>(
      'TWEthereumAbiFunctionAddInArrayParamUInt256');
  late final _TWEthereumAbiFunctionAddInArrayParamUInt256 =
      _TWEthereumAbiFunctionAddInArrayParamUInt256Ptr.asFunction<
          int Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, ffi.Pointer<TWData>)>();

  /// Adding a uint[N] type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param bits Number of bits of the integer parameter
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter stored in a block of data
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamUIntN(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int bits,
    ffi.Pointer<TWData> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamUIntN(
      fn,
      arrayIdx,
      bits,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamUIntNPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Int, ffi.Pointer<TWData>)>>(
      'TWEthereumAbiFunctionAddInArrayParamUIntN');
  late final _TWEthereumAbiFunctionAddInArrayParamUIntN =
      _TWEthereumAbiFunctionAddInArrayParamUIntNPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int,
              ffi.Pointer<TWData>)>();

  /// Adding a int8 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamInt8(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamInt8(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamInt8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Int8)>>('TWEthereumAbiFunctionAddInArrayParamInt8');
  late final _TWEthereumAbiFunctionAddInArrayParamInt8 =
      _TWEthereumAbiFunctionAddInArrayParamInt8Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a int16 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamInt16(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamInt16(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamInt16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Int16)>>('TWEthereumAbiFunctionAddInArrayParamInt16');
  late final _TWEthereumAbiFunctionAddInArrayParamInt16 =
      _TWEthereumAbiFunctionAddInArrayParamInt16Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a int32 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamInt32(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamInt32(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamInt32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Int32)>>('TWEthereumAbiFunctionAddInArrayParamInt32');
  late final _TWEthereumAbiFunctionAddInArrayParamInt32 =
      _TWEthereumAbiFunctionAddInArrayParamInt32Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a int64 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamInt64(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamInt64(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Int64)>>('TWEthereumAbiFunctionAddInArrayParamInt64');
  late final _TWEthereumAbiFunctionAddInArrayParamInt64 =
      _TWEthereumAbiFunctionAddInArrayParamInt64Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a int256 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter stored in a block of data
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamInt256(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    ffi.Pointer<TWData> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamInt256(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamInt256Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Pointer<TWData>)>>(
      'TWEthereumAbiFunctionAddInArrayParamInt256');
  late final _TWEthereumAbiFunctionAddInArrayParamInt256 =
      _TWEthereumAbiFunctionAddInArrayParamInt256Ptr.asFunction<
          int Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, ffi.Pointer<TWData>)>();

  /// Adding a int[N] type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param bits Number of bits of the integer parameter
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter stored in a block of data
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamIntN(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int bits,
    ffi.Pointer<TWData> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamIntN(
      fn,
      arrayIdx,
      bits,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamIntNPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Int, ffi.Pointer<TWData>)>>(
      'TWEthereumAbiFunctionAddInArrayParamIntN');
  late final _TWEthereumAbiFunctionAddInArrayParamIntN =
      _TWEthereumAbiFunctionAddInArrayParamIntNPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int,
              ffi.Pointer<TWData>)>();

  /// Adding a bool type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamBool(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    bool val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamBool(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamBoolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Bool)>>('TWEthereumAbiFunctionAddInArrayParamBool');
  late final _TWEthereumAbiFunctionAddInArrayParamBool =
      _TWEthereumAbiFunctionAddInArrayParamBoolPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Adding a string type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamString(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    ffi.Pointer<TWString> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamString(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamStringPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Pointer<TWString>)>>(
      'TWEthereumAbiFunctionAddInArrayParamString');
  late final _TWEthereumAbiFunctionAddInArrayParamString =
      _TWEthereumAbiFunctionAddInArrayParamStringPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int,
              ffi.Pointer<TWString>)>();

  /// Adding an address type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamAddress(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    ffi.Pointer<TWData> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamAddress(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamAddressPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Pointer<TWData>)>>(
      'TWEthereumAbiFunctionAddInArrayParamAddress');
  late final _TWEthereumAbiFunctionAddInArrayParamAddress =
      _TWEthereumAbiFunctionAddInArrayParamAddressPtr.asFunction<
          int Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, ffi.Pointer<TWData>)>();

  /// Adding a bytes type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamBytes(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    ffi.Pointer<TWData> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamBytes(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamBytesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Pointer<TWData>)>>(
      'TWEthereumAbiFunctionAddInArrayParamBytes');
  late final _TWEthereumAbiFunctionAddInArrayParamBytes =
      _TWEthereumAbiFunctionAddInArrayParamBytesPtr.asFunction<
          int Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, ffi.Pointer<TWData>)>();

  /// Adding a int64 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param size fixed size of the bytes array parameter (val).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamBytesFix(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int size,
    ffi.Pointer<TWData> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamBytesFix(
      fn,
      arrayIdx,
      size,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamBytesFixPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Size, ffi.Pointer<TWData>)>>(
      'TWEthereumAbiFunctionAddInArrayParamBytesFix');
  late final _TWEthereumAbiFunctionAddInArrayParamBytesFix =
      _TWEthereumAbiFunctionAddInArrayParamBytesFixPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int,
              ffi.Pointer<TWData>)>();

  /// Generate a layer 2 eip2645 derivation path from eth address, layer, application and given index.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param ethAddress non-null Ethereum address
  /// \param layer  non-null layer 2 name (E.G starkex)
  /// \param application non-null layer 2 application (E.G immutablex)
  /// \param index non-null layer 2 index (E.G 1)
  /// \return a valid eip2645 layer 2 derivation path as a string
  ffi.Pointer<TWString1> TWEthereumEip2645GetPath(
    ffi.Pointer<TWString1> ethAddress,
    ffi.Pointer<TWString1> layer,
    ffi.Pointer<TWString1> application,
    ffi.Pointer<TWString1> index,
  ) {
    return _TWEthereumEip2645GetPath(
      ethAddress,
      layer,
      application,
      index,
    );
  }

  late final _TWEthereumEip2645GetPathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWEthereumEip2645GetPath');
  late final _TWEthereumEip2645GetPath =
      _TWEthereumEip2645GetPathPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>();

  /// Encrypts a block of Data using AES in Cipher Block Chaining (CBC) mode.
  ///
  /// \param key encryption key Data, must be 16, 24, or 32 bytes long.
  /// \param data Data to encrypt.
  /// \param iv initialization vector.
  /// \param mode padding mode.
  /// \return encrypted Data.
  ffi.Pointer<TWData> TWAESEncryptCBC(
    ffi.Pointer<TWData> key,
    ffi.Pointer<TWData> data,
    ffi.Pointer<TWData> iv,
    TWAESPaddingMode mode,
  ) {
    return _TWAESEncryptCBC(
      key,
      data,
      iv,
      mode.value,
    );
  }

  late final _TWAESEncryptCBCPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>,
              ffi.Pointer<TWData>, ffi.UnsignedInt)>>('TWAESEncryptCBC');
  late final _TWAESEncryptCBC = _TWAESEncryptCBCPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>,
          ffi.Pointer<TWData>, int)>();

  /// Decrypts a block of data using AES in Cipher Block Chaining (CBC) mode.
  ///
  /// \param key decryption key Data, must be 16, 24, or 32 bytes long.
  /// \param data Data to decrypt.
  /// \param iv initialization vector Data.
  /// \param mode padding mode.
  /// \return decrypted Data.
  ffi.Pointer<TWData> TWAESDecryptCBC(
    ffi.Pointer<TWData> key,
    ffi.Pointer<TWData> data,
    ffi.Pointer<TWData> iv,
    TWAESPaddingMode mode,
  ) {
    return _TWAESDecryptCBC(
      key,
      data,
      iv,
      mode.value,
    );
  }

  late final _TWAESDecryptCBCPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>,
              ffi.Pointer<TWData>, ffi.UnsignedInt)>>('TWAESDecryptCBC');
  late final _TWAESDecryptCBC = _TWAESDecryptCBCPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>,
          ffi.Pointer<TWData>, int)>();

  /// Encrypts a block of data using AES in Counter (CTR) mode.
  ///
  /// \param key encryption key Data, must be 16, 24, or 32 bytes long.
  /// \param data Data to encrypt.
  /// \param iv initialization vector Data.
  /// \return encrypted Data.
  ffi.Pointer<TWData> TWAESEncryptCTR(
    ffi.Pointer<TWData> key,
    ffi.Pointer<TWData> data,
    ffi.Pointer<TWData> iv,
  ) {
    return _TWAESEncryptCTR(
      key,
      data,
      iv,
    );
  }

  late final _TWAESEncryptCTRPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>,
              ffi.Pointer<TWData>)>>('TWAESEncryptCTR');
  late final _TWAESEncryptCTR = _TWAESEncryptCTRPtr.asFunction<
      ffi.Pointer<TWData> Function(
          ffi.Pointer<TWData>, ffi.Pointer<TWData>, ffi.Pointer<TWData>)>();

  /// Decrypts a block of data using AES in Counter (CTR) mode.
  ///
  /// \param key decryption key Data, must be 16, 24, or 32 bytes long.
  /// \param data Data to decrypt.
  /// \param iv initialization vector Data.
  /// \return decrypted Data.
  ffi.Pointer<TWData> TWAESDecryptCTR(
    ffi.Pointer<TWData> key,
    ffi.Pointer<TWData> data,
    ffi.Pointer<TWData> iv,
  ) {
    return _TWAESDecryptCTR(
      key,
      data,
      iv,
    );
  }

  late final _TWAESDecryptCTRPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>,
              ffi.Pointer<TWData>)>>('TWAESDecryptCTR');
  late final _TWAESDecryptCTR = _TWAESDecryptCTRPtr.asFunction<
      ffi.Pointer<TWData> Function(
          ffi.Pointer<TWData>, ffi.Pointer<TWData>, ffi.Pointer<TWData>)>();

  /// Decode Solana transaction, update the recent blockhash and re-sign the transaction.
  ///
  /// # Warning
  ///
  /// This is a temporary solution. It will be removed when `Solana.proto` supports
  /// direct transaction signing.
  ///
  /// \param encodedTx base64 encoded Solana transaction.
  /// \param recentBlockhash base58 encoded recent blockhash.
  /// \param privateKeys list of private keys that should be used to re-sign the transaction.
  /// \return serialized `Solana::Proto::SigningOutput`.
  ffi.Pointer<TWData> TWSolanaTransactionUpdateBlockhashAndSign(
    ffi.Pointer<TWString> encodedTx,
    ffi.Pointer<TWString> recentBlockhash,
    ffi.Pointer<TWDataVector> privateKeys,
  ) {
    return _TWSolanaTransactionUpdateBlockhashAndSign(
      encodedTx,
      recentBlockhash,
      privateKeys,
    );
  }

  late final _TWSolanaTransactionUpdateBlockhashAndSignPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData> Function(ffi.Pointer<TWString>,
                  ffi.Pointer<TWString>, ffi.Pointer<TWDataVector>)>>(
      'TWSolanaTransactionUpdateBlockhashAndSign');
  late final _TWSolanaTransactionUpdateBlockhashAndSign =
      _TWSolanaTransactionUpdateBlockhashAndSignPtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>, ffi.Pointer<TWDataVector>)>();

  /// Create a NEAR Account
  ///
  /// \param string Account name
  /// \note Account should be deleted by calling \TWNEARAccountDelete
  /// \return Pointer to a nullable NEAR Account.
  ffi.Pointer<TWNEARAccount> TWNEARAccountCreateWithString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWNEARAccountCreateWithString(
      string,
    );
  }

  late final _TWNEARAccountCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWNEARAccount> Function(
              ffi.Pointer<TWString1>)>>('TWNEARAccountCreateWithString');
  late final _TWNEARAccountCreateWithString =
      _TWNEARAccountCreateWithStringPtr.asFunction<
          ffi.Pointer<TWNEARAccount> Function(ffi.Pointer<TWString1>)>();

  /// Delete the given Near Account
  ///
  /// \param account Pointer to a non-null NEAR Account
  void TWNEARAccountDelete(
    ffi.Pointer<TWNEARAccount> account,
  ) {
    return _TWNEARAccountDelete(
      account,
    );
  }

  late final _TWNEARAccountDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWNEARAccount>)>>(
      'TWNEARAccountDelete');
  late final _TWNEARAccountDelete = _TWNEARAccountDeletePtr.asFunction<
      void Function(ffi.Pointer<TWNEARAccount>)>();

  /// Returns the user friendly string representation.
  ///
  /// \param account Pointer to a non-null NEAR Account
  /// \return Non-null string account description
  ffi.Pointer<TWString1> TWNEARAccountDescription(
    ffi.Pointer<TWNEARAccount> account,
  ) {
    return _TWNEARAccountDescription(
      account,
    );
  }

  late final _TWNEARAccountDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWNEARAccount>)>>('TWNEARAccountDescription');
  late final _TWNEARAccountDescription =
      _TWNEARAccountDescriptionPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWNEARAccount>)>();

  /// Sign a message.
  ///
  /// \param privateKey: the private key used for signing
  /// \param address: the address that matches the privateKey, must be a legacy address (P2PKH)
  /// \param message: A custom message which is input to the signing.
  /// \note Address is derived assuming compressed public key format.
  /// \returns the signature, Base64-encoded.  On invalid input empty string is returned. Returned object needs to be deleteed after use.
  ffi.Pointer<TWString> TWBitcoinMessageSignerSignMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString> address,
    ffi.Pointer<TWString> message,
  ) {
    return _TWBitcoinMessageSignerSignMessage(
      privateKey,
      address,
      message,
    );
  }

  late final _TWBitcoinMessageSignerSignMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWBitcoinMessageSignerSignMessage');
  late final _TWBitcoinMessageSignerSignMessage =
      _TWBitcoinMessageSignerSignMessagePtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString>, ffi.Pointer<TWString>)>();

  /// Verify signature for a message.
  ///
  /// \param address: address to use, only legacy is supported
  /// \param message: the message signed (without prefix)
  /// \param signature: in Base64-encoded form.
  /// \returns false on any invalid input (does not throw).
  bool TWBitcoinMessageSignerVerifyMessage(
    ffi.Pointer<TWString> address,
    ffi.Pointer<TWString> message,
    ffi.Pointer<TWString> signature,
  ) {
    return _TWBitcoinMessageSignerVerifyMessage(
      address,
      message,
      signature,
    );
  }

  late final _TWBitcoinMessageSignerVerifyMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWString>, ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWBitcoinMessageSignerVerifyMessage');
  late final _TWBitcoinMessageSignerVerifyMessage =
      _TWBitcoinMessageSignerVerifyMessagePtr.asFunction<
          bool Function(ffi.Pointer<TWString>, ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>();

  /// Creates a new Account with an address, a coin type, derivation enum, derivationPath, publicKey,
  /// and extendedPublicKey. Must be deleted with TWAccountDelete after use.
  ///
  /// \param address The address of the Account.
  /// \param coin The coin type of the Account.
  /// \param derivation The derivation of the Account.
  /// \param derivationPath The derivation path of the Account.
  /// \param publicKey hex encoded public key.
  /// \param extendedPublicKey Base58 encoded extended public key.
  /// \return A new Account.
  ffi.Pointer<TWAccount> TWAccountCreate(
    ffi.Pointer<TWString1> address,
    TWCoinType coin,
    TWDerivation derivation,
    ffi.Pointer<TWString1> derivationPath,
    ffi.Pointer<TWString1> publicKey,
    ffi.Pointer<TWString1> extendedPublicKey,
  ) {
    return _TWAccountCreate(
      address,
      coin.value,
      derivation.value,
      derivationPath,
      publicKey,
      extendedPublicKey,
    );
  }

  late final _TWAccountCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWString1>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWAccountCreate');
  late final _TWAccountCreate = _TWAccountCreatePtr.asFunction<
      ffi.Pointer<TWAccount> Function(
          ffi.Pointer<TWString1>,
          int,
          int,
          ffi.Pointer<TWString1>,
          ffi.Pointer<TWString1>,
          ffi.Pointer<TWString1>)>();

  /// Deletes an account.
  ///
  /// \param account Account to delete.
  void TWAccountDelete(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountDelete(
      account,
    );
  }

  late final _TWAccountDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWAccount>)>>(
          'TWAccountDelete');
  late final _TWAccountDelete =
      _TWAccountDeletePtr.asFunction<void Function(ffi.Pointer<TWAccount>)>();

  /// Returns the address of an account.
  ///
  /// \param account Account to get the address of.
  ffi.Pointer<TWString1> TWAccountAddress(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountAddress(
      account,
    );
  }

  late final _TWAccountAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWAccount>)>>('TWAccountAddress');
  late final _TWAccountAddress = _TWAccountAddressPtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWAccount>)>();

  /// Return CoinType enum of an account.
  ///
  /// \param account Account to get the coin type of.
  TWCoinType TWAccountCoin(
    ffi.Pointer<TWAccount> account,
  ) {
    return TWCoinType.fromValue(_TWAccountCoin(
      account,
    ));
  }

  late final _TWAccountCoinPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<TWAccount>)>>(
      'TWAccountCoin');
  late final _TWAccountCoin =
      _TWAccountCoinPtr.asFunction<int Function(ffi.Pointer<TWAccount>)>();

  /// Returns the derivation enum of an account.
  ///
  /// \param account Account to get the derivation enum of.
  TWDerivation TWAccountDerivation(
    ffi.Pointer<TWAccount> account,
  ) {
    return TWDerivation.fromValue(_TWAccountDerivation(
      account,
    ));
  }

  late final _TWAccountDerivationPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<TWAccount>)>>(
      'TWAccountDerivation');
  late final _TWAccountDerivation = _TWAccountDerivationPtr.asFunction<
      int Function(ffi.Pointer<TWAccount>)>();

  /// Returns derivationPath of an account.
  ///
  /// \param account Account to get the derivation path of.
  ffi.Pointer<TWString1> TWAccountDerivationPath(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountDerivationPath(
      account,
    );
  }

  late final _TWAccountDerivationPathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWAccount>)>>('TWAccountDerivationPath');
  late final _TWAccountDerivationPath = _TWAccountDerivationPathPtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWAccount>)>();

  /// Returns hex encoded publicKey of an account.
  ///
  /// \param account Account to get the public key of.
  ffi.Pointer<TWString1> TWAccountPublicKey(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountPublicKey(
      account,
    );
  }

  late final _TWAccountPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWAccount>)>>('TWAccountPublicKey');
  late final _TWAccountPublicKey = _TWAccountPublicKeyPtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWAccount>)>();

  /// Returns Base58 encoded extendedPublicKey of an account.
  ///
  /// \param account Account to get the extended public key of.
  ffi.Pointer<TWString1> TWAccountExtendedPublicKey(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountExtendedPublicKey(
      account,
    );
  }

  late final _TWAccountExtendedPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWAccount>)>>('TWAccountExtendedPublicKey');
  late final _TWAccountExtendedPublicKey = _TWAccountExtendedPublicKeyPtr
      .asFunction<ffi.Pointer<TWString1> Function(ffi.Pointer<TWAccount>)>();

  /// Sign a message.
  ///
  /// \param privateKey: the private key used for signing
  /// \param message: A custom hex message which is input to the signing.
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString> TWStarkExMessageSignerSignMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString> message,
  ) {
    return _TWStarkExMessageSignerSignMessage(
      privateKey,
      message,
    );
  }

  late final _TWStarkExMessageSignerSignMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString>)>>('TWStarkExMessageSignerSignMessage');
  late final _TWStarkExMessageSignerSignMessage =
      _TWStarkExMessageSignerSignMessagePtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString>)>();

  /// Verify signature for a message.
  ///
  /// \param pubKey: pubKey that will verify and recover the message from the signature
  /// \param message: the message signed (without prefix) in hex
  /// \param signature: in Hex-encoded form.
  /// \returns false on any invalid input (does not throw), true if the message can be recovered from the signature
  bool TWStarkExMessageSignerVerifyMessage(
    ffi.Pointer<TWPublicKey> pubKey,
    ffi.Pointer<TWString> message,
    ffi.Pointer<TWString> signature,
  ) {
    return _TWStarkExMessageSignerVerifyMessage(
      pubKey,
      message,
      signature,
    );
  }

  late final _TWStarkExMessageSignerVerifyMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWStarkExMessageSignerVerifyMessage');
  late final _TWStarkExMessageSignerVerifyMessage =
      _TWStarkExMessageSignerVerifyMessagePtr.asFunction<
          bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>();

  /// Creates an address from a string representation.
  ///
  /// \param string Non-null pointer to a solana address string
  /// \note Should be deleted with \TWSolanaAddressDelete
  /// \return Non-null pointer to a Solana address data structure
  ffi.Pointer<TWSolanaAddress> TWSolanaAddressCreateWithString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWSolanaAddressCreateWithString(
      string,
    );
  }

  late final _TWSolanaAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWSolanaAddress> Function(
              ffi.Pointer<TWString1>)>>('TWSolanaAddressCreateWithString');
  late final _TWSolanaAddressCreateWithString =
      _TWSolanaAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWSolanaAddress> Function(ffi.Pointer<TWString1>)>();

  /// Delete the given Solana address
  ///
  /// \param address Non-null pointer to a Solana Address
  void TWSolanaAddressDelete(
    ffi.Pointer<TWSolanaAddress> address,
  ) {
    return _TWSolanaAddressDelete(
      address,
    );
  }

  late final _TWSolanaAddressDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWSolanaAddress>)>>(
      'TWSolanaAddressDelete');
  late final _TWSolanaAddressDelete = _TWSolanaAddressDeletePtr.asFunction<
      void Function(ffi.Pointer<TWSolanaAddress>)>();

  /// Derive default token address for token
  ///
  /// \param address Non-null pointer to a Solana Address
  /// \param tokenMintAddress Non-null pointer to a token mint address as a string
  /// \return Null pointer if the Default token address for a token is not found, valid pointer otherwise
  ffi.Pointer<TWString1> TWSolanaAddressDefaultTokenAddress(
    ffi.Pointer<TWSolanaAddress> address,
    ffi.Pointer<TWString1> tokenMintAddress,
  ) {
    return _TWSolanaAddressDefaultTokenAddress(
      address,
      tokenMintAddress,
    );
  }

  late final _TWSolanaAddressDefaultTokenAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWSolanaAddress>,
              ffi.Pointer<TWString1>)>>('TWSolanaAddressDefaultTokenAddress');
  late final _TWSolanaAddressDefaultTokenAddress =
      _TWSolanaAddressDefaultTokenAddressPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWSolanaAddress>, ffi.Pointer<TWString1>)>();

  /// Returns the address string representation.
  ///
  /// \param address Non-null pointer to a Solana Address
  /// \return Non-null pointer to the Solana address string representation
  ffi.Pointer<TWString1> TWSolanaAddressDescription(
    ffi.Pointer<TWSolanaAddress> address,
  ) {
    return _TWSolanaAddressDescription(
      address,
    );
  }

  late final _TWSolanaAddressDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWSolanaAddress>)>>('TWSolanaAddressDescription');
  late final _TWSolanaAddressDescription =
      _TWSolanaAddressDescriptionPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWSolanaAddress>)>();

  /// Calculate a counterfactual address for the smart contract wallet
  ///
  /// \param input The serialized data of ContractAddressInput.
  /// \return The address.
  ffi.Pointer<TWString> TWBarzGetCounterfactualAddress(
    ffi.Pointer<TWData> input,
  ) {
    return _TWBarzGetCounterfactualAddress(
      input,
    );
  }

  late final _TWBarzGetCounterfactualAddressPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>>(
      'TWBarzGetCounterfactualAddress');
  late final _TWBarzGetCounterfactualAddress =
      _TWBarzGetCounterfactualAddressPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>();

  /// Returns the init code parameter of ERC-4337 User Operation
  ///
  /// \param factory Wallet factory address (BarzFactory)
  /// \param publicKey Public key for the verification facet
  /// \param verificationFacet Verification facet address
  /// \return The address.
  ffi.Pointer<TWData> TWBarzGetInitCode(
    ffi.Pointer<TWString> factory1,
    ffi.Pointer<TWPublicKey> publicKey,
    ffi.Pointer<TWString> verificationFacet,
    int salt,
  ) {
    return _TWBarzGetInitCode(
      factory1,
      publicKey,
      verificationFacet,
      salt,
    );
  }

  late final _TWBarzGetInitCodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWPublicKey>,
              ffi.Pointer<TWString>,
              ffi.Uint32)>>('TWBarzGetInitCode');
  late final _TWBarzGetInitCode = _TWBarzGetInitCodePtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWString>,
          ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString>, int)>();

  /// Converts the original ASN-encoded signature from webauthn to the format accepted by Barz
  ///
  /// \param signature Original signature
  /// \param challenge The original challenge that was signed
  /// \param authenticatorData Returned from Webauthn API
  /// \param clientDataJSON Returned from Webauthn API
  /// \return Bytes of the formatted signature
  ffi.Pointer<TWData> TWBarzGetFormattedSignature(
    ffi.Pointer<TWData> signature,
    ffi.Pointer<TWData> challenge,
    ffi.Pointer<TWData> authenticatorData,
    ffi.Pointer<TWString> clientDataJSON,
  ) {
    return _TWBarzGetFormattedSignature(
      signature,
      challenge,
      authenticatorData,
      clientDataJSON,
    );
  }

  late final _TWBarzGetFormattedSignaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWData>,
              ffi.Pointer<TWData>,
              ffi.Pointer<TWData>,
              ffi.Pointer<TWString>)>>('TWBarzGetFormattedSignature');
  late final _TWBarzGetFormattedSignature =
      _TWBarzGetFormattedSignaturePtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>,
              ffi.Pointer<TWData>, ffi.Pointer<TWString>)>();

  /// Returns the final hash to be signed by Barz for signing messages & typed data
  ///
  /// \param msgHash Original msgHash
  /// \param barzAddress The address of Barz wallet signing the message
  /// \param chainId The chainId of the network the verification will happen
  /// \return The final hash to be signed
  ffi.Pointer<TWData> TWBarzGetPrefixedMsgHash(
    ffi.Pointer<TWData> msgHash,
    ffi.Pointer<TWString> barzAddress,
    int chainId,
  ) {
    return _TWBarzGetPrefixedMsgHash(
      msgHash,
      barzAddress,
      chainId,
    );
  }

  late final _TWBarzGetPrefixedMsgHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWString>, ffi.Uint32)>>('TWBarzGetPrefixedMsgHash');
  late final _TWBarzGetPrefixedMsgHash =
      _TWBarzGetPrefixedMsgHashPtr.asFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWString>, int)>();

  /// Returns the encoded diamondCut function call for Barz contract upgrades
  ///
  /// \param input The serialized data of DiamondCutInput
  /// \return The encoded bytes of diamondCut function call
  ffi.Pointer<TWData> TWBarzGetDiamondCutCode(
    ffi.Pointer<TWData> input,
  ) {
    return _TWBarzGetDiamondCutCode(
      input,
    );
  }

  late final _TWBarzGetDiamondCutCodePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWBarzGetDiamondCutCode');
  late final _TWBarzGetDiamondCutCode = _TWBarzGetDiamondCutCodePtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();
}

final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

final class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

enum idtype_t {
  P_ALL(0),
  P_PID(1),
  P_PGID(2);

  final int value;
  const idtype_t(this.value);

  static idtype_t fromValue(int value) => switch (value) {
        0 => P_ALL,
        1 => P_PID,
        2 => P_PGID,
        _ => throw ArgumentError("Unknown value for idtype_t: $value"),
      };
}

final class __darwin_arm_exception_state extends ffi.Struct {
  @__uint32_t()
  external int __exception;

  @__uint32_t()
  external int __fsr;

  @__uint32_t()
  external int __far;
}

typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;

final class __darwin_arm_exception_state64 extends ffi.Struct {
  @__uint64_t()
  external int __far;

  @__uint32_t()
  external int __esr;

  @__uint32_t()
  external int __exception;
}

typedef __uint64_t = ffi.UnsignedLongLong;
typedef Dart__uint64_t = int;

final class __darwin_arm_thread_state extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __sp;

  @__uint32_t()
  external int __lr;

  @__uint32_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;
}

final class __darwin_arm_thread_state64 extends ffi.Struct {
  @ffi.Array.multi([29])
  external ffi.Array<__uint64_t> __x;

  @__uint64_t()
  external int __fp;

  @__uint64_t()
  external int __lr;

  @__uint64_t()
  external int __sp;

  @__uint64_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;

  @__uint32_t()
  external int __pad;
}

final class __darwin_arm_vfp_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __fpscr;
}

final class __darwin_arm_neon_state64 extends ffi.Opaque {}

final class __darwin_arm_neon_state extends ffi.Opaque {}

final class __arm_pagein_state extends ffi.Struct {
  @ffi.Int()
  external int __pagein_error;
}

final class __arm_legacy_debug_state extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;
}

final class __darwin_arm_debug_state32 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_debug_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_cpmu_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __ctrs;
}

final class __darwin_mcontext32 extends ffi.Struct {
  external __darwin_arm_exception_state __es;

  external __darwin_arm_thread_state __ss;

  external __darwin_arm_vfp_state __fs;
}

final class __darwin_mcontext64 extends ffi.Opaque {}

final class __darwin_sigaltstack extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ss_sp;

  @__darwin_size_t()
  external int ss_size;

  @ffi.Int()
  external int ss_flags;
}

typedef __darwin_size_t = ffi.UnsignedLong;
typedef Dart__darwin_size_t = int;

final class __darwin_ucontext extends ffi.Struct {
  @ffi.Int()
  external int uc_onstack;

  @__darwin_sigset_t()
  external int uc_sigmask;

  external __darwin_sigaltstack uc_stack;

  external ffi.Pointer<__darwin_ucontext> uc_link;

  @__darwin_size_t()
  external int uc_mcsize;

  external ffi.Pointer<__darwin_mcontext64> uc_mcontext;
}

typedef __darwin_sigset_t = __uint32_t;

final class sigval extends ffi.Union {
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

final class sigevent extends ffi.Struct {
  @ffi.Int()
  external int sigev_notify;

  @ffi.Int()
  external int sigev_signo;

  external sigval sigev_value;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sigval)>>
      sigev_notify_function;

  external ffi.Pointer<pthread_attr_t> sigev_notify_attributes;
}

typedef pthread_attr_t = __darwin_pthread_attr_t;
typedef __darwin_pthread_attr_t = _opaque_pthread_attr_t;

final class __siginfo extends ffi.Struct {
  @ffi.Int()
  external int si_signo;

  @ffi.Int()
  external int si_errno;

  @ffi.Int()
  external int si_code;

  @pid_t()
  external int si_pid;

  @uid_t()
  external int si_uid;

  @ffi.Int()
  external int si_status;

  external ffi.Pointer<ffi.Void> si_addr;

  external sigval si_value;

  @ffi.Long()
  external int si_band;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedLong> __pad;
}

typedef pid_t = __darwin_pid_t;
typedef __darwin_pid_t = __int32_t;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef uid_t = __darwin_uid_t;
typedef __darwin_uid_t = __uint32_t;

final class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      __sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)>>
      __sa_sigaction;
}

final class __sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u1;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Void>)>> sa_tramp;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

typedef siginfo_t = __siginfo;
typedef sigset_t = __darwin_sigset_t;

final class sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u1;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

final class sigvec extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      sv_handler;

  @ffi.Int()
  external int sv_mask;

  @ffi.Int()
  external int sv_flags;
}

final class sigstack extends ffi.Struct {
  external ffi.Pointer<ffi.Char> ss_sp;

  @ffi.Int()
  external int ss_onstack;
}

final class timeval extends ffi.Struct {
  @__darwin_time_t()
  external int tv_sec;

  @__darwin_suseconds_t()
  external int tv_usec;
}

typedef __darwin_time_t = ffi.Long;
typedef Dart__darwin_time_t = int;
typedef __darwin_suseconds_t = __int32_t;

final class rusage extends ffi.Struct {
  external timeval ru_utime;

  external timeval ru_stime;

  @ffi.Long()
  external int ru_maxrss;

  @ffi.Long()
  external int ru_ixrss;

  @ffi.Long()
  external int ru_idrss;

  @ffi.Long()
  external int ru_isrss;

  @ffi.Long()
  external int ru_minflt;

  @ffi.Long()
  external int ru_majflt;

  @ffi.Long()
  external int ru_nswap;

  @ffi.Long()
  external int ru_inblock;

  @ffi.Long()
  external int ru_oublock;

  @ffi.Long()
  external int ru_msgsnd;

  @ffi.Long()
  external int ru_msgrcv;

  @ffi.Long()
  external int ru_nsignals;

  @ffi.Long()
  external int ru_nvcsw;

  @ffi.Long()
  external int ru_nivcsw;
}

final class rusage_info_v0 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;
}

final class rusage_info_v1 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;
}

final class rusage_info_v2 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;
}

final class rusage_info_v3 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;
}

final class rusage_info_v4 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;
}

final class rusage_info_v5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;
}

final class rusage_info_v6 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;

  @ffi.Uint64()
  external int ri_user_ptime;

  @ffi.Uint64()
  external int ri_system_ptime;

  @ffi.Uint64()
  external int ri_pinstructions;

  @ffi.Uint64()
  external int ri_pcycles;

  @ffi.Uint64()
  external int ri_energy_nj;

  @ffi.Uint64()
  external int ri_penergy_nj;

  @ffi.Uint64()
  external int ri_secure_time_in_system;

  @ffi.Uint64()
  external int ri_secure_ptime_in_system;

  @ffi.Array.multi([12])
  external ffi.Array<ffi.Uint64> ri_reserved;
}

final class rlimit extends ffi.Struct {
  @rlim_t()
  external int rlim_cur;

  @rlim_t()
  external int rlim_max;
}

typedef rlim_t = __uint64_t;

final class proc_rlimit_control_wakeupmon extends ffi.Struct {
  @ffi.Uint32()
  external int wm_flags;

  @ffi.Int32()
  external int wm_rate;
}

typedef id_t = __darwin_id_t;
typedef __darwin_id_t = __uint32_t;

@ffi.Packed(1)
final class _OSUnalignedU16 extends ffi.Struct {
  @ffi.Uint16()
  external int __val;
}

@ffi.Packed(1)
final class _OSUnalignedU32 extends ffi.Struct {
  @ffi.Uint32()
  external int __val;
}

@ffi.Packed(1)
final class _OSUnalignedU64 extends ffi.Struct {
  @ffi.Uint64()
  external int __val;
}

final class wait extends ffi.Opaque {}

final class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

typedef malloc_type_id_t = ffi.UnsignedLongLong;
typedef Dartmalloc_type_id_t = int;

final class _malloc_zone_t extends ffi.Opaque {}

typedef malloc_zone_t = _malloc_zone_t;
typedef dev_t = __darwin_dev_t;
typedef __darwin_dev_t = __int32_t;
typedef mode_t = __darwin_mode_t;
typedef __darwin_mode_t = __uint16_t;
typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;

/// HD wallet purpose
///
/// \see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
/// \see https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki
/// \see https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki
enum TWPurpose {
  TWPurposeBIP44(44),
  TWPurposeBIP49(49),
  TWPurposeBIP84(84),
  TWPurposeBIP1852(1852);

  final int value;
  const TWPurpose(this.value);

  static TWPurpose fromValue(int value) => switch (value) {
        44 => TWPurposeBIP44,
        49 => TWPurposeBIP49,
        84 => TWPurposeBIP84,
        1852 => TWPurposeBIP1852,
        _ => throw ArgumentError("Unknown value for TWPurpose: $value"),
      };
}

/// Filecoin address type.
enum TWFilecoinAddressType {
  TWFilecoinAddressTypeDefault(0),
  TWFilecoinAddressTypeDelegated(1);

  final int value;
  const TWFilecoinAddressType(this.value);

  static TWFilecoinAddressType fromValue(int value) => switch (value) {
        0 => TWFilecoinAddressTypeDefault,
        1 => TWFilecoinAddressTypeDelegated,
        _ => throw ArgumentError(
            "Unknown value for TWFilecoinAddressType: $value"),
      };
}

/// Defines a resizable block of data.
///
/// The implementantion of these methods should be language-specific to minimize translation overhead. For instance it
/// should be a `jbyteArray` for Java and an `NSData` for Swift.
typedef TWData = ffi.Void;
typedef DartTWData = void;
typedef TWString = ffi.Void;
typedef DartTWString = void;

/// Blockchain enum type
enum TWBlockchain {
  TWBlockchainBitcoin(0),
  TWBlockchainEthereum(1),
  TWBlockchainVechain(3),
  TWBlockchainTron(4),
  TWBlockchainIcon(5),
  TWBlockchainBinance(6),
  TWBlockchainRipple(7),
  TWBlockchainTezos(8),
  TWBlockchainNimiq(9),
  TWBlockchainStellar(10),
  TWBlockchainAion(11),
  TWBlockchainCosmos(12),
  TWBlockchainTheta(13),
  TWBlockchainOntology(14),
  TWBlockchainZilliqa(15),
  TWBlockchainIoTeX(16),
  TWBlockchainEOS(17),
  TWBlockchainNano(18),
  TWBlockchainNULS(19),
  TWBlockchainWaves(20),
  TWBlockchainAeternity(21),
  TWBlockchainNebulas(22),
  TWBlockchainFIO(23),
  TWBlockchainSolana(24),
  TWBlockchainHarmony(25),
  TWBlockchainNEAR(26),
  TWBlockchainAlgorand(27),
  TWBlockchainIOST(28),
  TWBlockchainPolkadot(29),
  TWBlockchainCardano(30),
  TWBlockchainNEO(31),
  TWBlockchainFilecoin(32),
  TWBlockchainMultiversX(33),
  TWBlockchainOasisNetwork(34),
  TWBlockchainDecred(35),
  TWBlockchainZcash(36),
  TWBlockchainGroestlcoin(37),
  TWBlockchainThorchain(38),
  TWBlockchainRonin(39),
  TWBlockchainKusama(40),
  TWBlockchainZen(41),
  TWBlockchainBitcoinDiamond(42),
  TWBlockchainVerge(43),
  TWBlockchainNervos(44),
  TWBlockchainEverscale(45),
  TWBlockchainAptos(46),
  TWBlockchainNebl(47),
  TWBlockchainHedera(48),
  TWBlockchainTheOpenNetwork(49),
  TWBlockchainSui(50),
  TWBlockchainGreenfield(51),
  TWBlockchainInternetComputer(52),
  TWBlockchainNativeEvmos(53),
  TWBlockchainNativeInjective(54);

  final int value;
  const TWBlockchain(this.value);

  static TWBlockchain fromValue(int value) => switch (value) {
        0 => TWBlockchainBitcoin,
        1 => TWBlockchainEthereum,
        3 => TWBlockchainVechain,
        4 => TWBlockchainTron,
        5 => TWBlockchainIcon,
        6 => TWBlockchainBinance,
        7 => TWBlockchainRipple,
        8 => TWBlockchainTezos,
        9 => TWBlockchainNimiq,
        10 => TWBlockchainStellar,
        11 => TWBlockchainAion,
        12 => TWBlockchainCosmos,
        13 => TWBlockchainTheta,
        14 => TWBlockchainOntology,
        15 => TWBlockchainZilliqa,
        16 => TWBlockchainIoTeX,
        17 => TWBlockchainEOS,
        18 => TWBlockchainNano,
        19 => TWBlockchainNULS,
        20 => TWBlockchainWaves,
        21 => TWBlockchainAeternity,
        22 => TWBlockchainNebulas,
        23 => TWBlockchainFIO,
        24 => TWBlockchainSolana,
        25 => TWBlockchainHarmony,
        26 => TWBlockchainNEAR,
        27 => TWBlockchainAlgorand,
        28 => TWBlockchainIOST,
        29 => TWBlockchainPolkadot,
        30 => TWBlockchainCardano,
        31 => TWBlockchainNEO,
        32 => TWBlockchainFilecoin,
        33 => TWBlockchainMultiversX,
        34 => TWBlockchainOasisNetwork,
        35 => TWBlockchainDecred,
        36 => TWBlockchainZcash,
        37 => TWBlockchainGroestlcoin,
        38 => TWBlockchainThorchain,
        39 => TWBlockchainRonin,
        40 => TWBlockchainKusama,
        41 => TWBlockchainZen,
        42 => TWBlockchainBitcoinDiamond,
        43 => TWBlockchainVerge,
        44 => TWBlockchainNervos,
        45 => TWBlockchainEverscale,
        46 => TWBlockchainAptos,
        47 => TWBlockchainNebl,
        48 => TWBlockchainHedera,
        49 => TWBlockchainTheOpenNetwork,
        50 => TWBlockchainSui,
        51 => TWBlockchainGreenfield,
        52 => TWBlockchainInternetComputer,
        53 => TWBlockchainNativeEvmos,
        54 => TWBlockchainNativeInjective,
        _ => throw ArgumentError("Unknown value for TWBlockchain: $value"),
      };
}

/// Elliptic cruves
enum TWCurve {
  TWCurveSECP256k1(0),
  TWCurveED25519(1),
  TWCurveED25519Blake2bNano(2),
  TWCurveCurve25519(3),
  TWCurveNIST256p1(4),
  TWCurveED25519ExtendedCardano(5),
  TWCurveStarkex(6),
  TWCurveNone(7);

  final int value;
  const TWCurve(this.value);

  static TWCurve fromValue(int value) => switch (value) {
        0 => TWCurveSECP256k1,
        1 => TWCurveED25519,
        2 => TWCurveED25519Blake2bNano,
        3 => TWCurveCurve25519,
        4 => TWCurveNIST256p1,
        5 => TWCurveED25519ExtendedCardano,
        6 => TWCurveStarkex,
        7 => TWCurveNone,
        _ => throw ArgumentError("Unknown value for TWCurve: $value"),
      };
}

/// Non-default coin address derivation names (default, unnamed derivations are not included).
enum TWDerivation {
  TWDerivationDefault(0),
  TWDerivationCustom(1),
  TWDerivationBitcoinSegwit(2),
  TWDerivationBitcoinLegacy(3),
  TWDerivationBitcoinTestnet(4),
  TWDerivationLitecoinLegacy(5),
  TWDerivationSolanaSolana(6),
  TWDerivationStratisSegwit(7);

  final int value;
  const TWDerivation(this.value);

  static TWDerivation fromValue(int value) => switch (value) {
        0 => TWDerivationDefault,
        1 => TWDerivationCustom,
        2 => TWDerivationBitcoinSegwit,
        3 => TWDerivationBitcoinLegacy,
        4 => TWDerivationBitcoinTestnet,
        5 => TWDerivationLitecoinLegacy,
        6 => TWDerivationSolanaSolana,
        7 => TWDerivationStratisSegwit,
        _ => throw ArgumentError("Unknown value for TWDerivation: $value"),
      };
}

/// Registered HD version bytes
///
/// \see https://github.com/satoshilabs/slips/blob/master/slip-0132.md
enum TWHDVersion {
  TWHDVersionNone(0),
  TWHDVersionXPUB(76067358),
  TWHDVersionXPRV(76066276),
  TWHDVersionYPUB(77429938),
  TWHDVersionYPRV(77428856),
  TWHDVersionZPUB(78792518),
  TWHDVersionZPRV(78791436),
  TWHDVersionVPUB(73342198),
  TWHDVersionVPRV(73341116),
  TWHDVersionTPUB(70617039),
  TWHDVersionTPRV(70615956),
  TWHDVersionLTUB(27108450),
  TWHDVersionLTPV(27106558),
  TWHDVersionMTUB(28471030),
  TWHDVersionMTPV(28469138),
  TWHDVersionTTUB(70711009),
  TWHDVersionTTPV(70709117),
  TWHDVersionDPUB(50178342),
  TWHDVersionDPRV(50177256),
  TWHDVersionDGUB(49990397),
  TWHDVersionDGPV(49988504);

  final int value;
  const TWHDVersion(this.value);

  static TWHDVersion fromValue(int value) => switch (value) {
        0 => TWHDVersionNone,
        76067358 => TWHDVersionXPUB,
        76066276 => TWHDVersionXPRV,
        77429938 => TWHDVersionYPUB,
        77428856 => TWHDVersionYPRV,
        78792518 => TWHDVersionZPUB,
        78791436 => TWHDVersionZPRV,
        73342198 => TWHDVersionVPUB,
        73341116 => TWHDVersionVPRV,
        70617039 => TWHDVersionTPUB,
        70615956 => TWHDVersionTPRV,
        27108450 => TWHDVersionLTUB,
        27106558 => TWHDVersionLTPV,
        28471030 => TWHDVersionMTUB,
        28469138 => TWHDVersionMTPV,
        70711009 => TWHDVersionTTUB,
        70709117 => TWHDVersionTTPV,
        50178342 => TWHDVersionDPUB,
        50177256 => TWHDVersionDPRV,
        49990397 => TWHDVersionDGUB,
        49988504 => TWHDVersionDGPV,
        _ => throw ArgumentError("Unknown value for TWHDVersion: $value"),
      };
}

/// Registered human-readable parts for BIP-0173
///
/// - SeeAlso: https://github.com/satoshilabs/slips/blob/master/slip-0173.md
enum TWHRP {
  TWHRPUnknown(0),
  TWHRPBitcoin(1),
  TWHRPLitecoin(2),
  TWHRPViacoin(3),
  TWHRPGroestlcoin(4),
  TWHRPDigiByte(5),
  TWHRPMonacoin(6),
  TWHRPSyscoin(7),
  TWHRPVerge(8),
  TWHRPCosmos(9),
  TWHRPBitcoinCash(10),
  TWHRPBitcoinGold(11),
  TWHRPIoTeX(12),
  TWHRPNervos(13),
  TWHRPZilliqa(14),
  TWHRPTerra(15),
  TWHRPCryptoOrg(16),
  TWHRPKava(17),
  TWHRPOasis(18),
  TWHRPBluzelle(19),
  TWHRPBandChain(20),
  TWHRPMultiversX(21),
  TWHRPSecret(22),
  TWHRPAgoric(23),
  TWHRPBinance(24),
  TWHRPECash(25),
  TWHRPTHORChain(26),
  TWHRPBitcoinDiamond(27),
  TWHRPHarmony(28),
  TWHRPCardano(29),
  TWHRPQtum(30),
  TWHRPStratis(31),
  TWHRPNativeInjective(32),
  TWHRPOsmosis(33),
  TWHRPTerraV2(34),
  TWHRPCoreum(35),
  TWHRPNativeZetaChain(36),
  TWHRPNativeCanto(37),
  TWHRPSommelier(38),
  TWHRPFetchAI(39),
  TWHRPMars(40),
  TWHRPUmee(41),
  TWHRPQuasar(42),
  TWHRPPersistence(43),
  TWHRPAkash(44),
  TWHRPNoble(45),
  TWHRPSei(46),
  TWHRPStargaze(47),
  TWHRPNativeEvmos(48),
  TWHRPTia(49),
  TWHRPDydx(50),
  TWHRPJuno(51),
  TWHRPTBinance(52),
  TWHRPStride(53),
  TWHRPAxelar(54),
  TWHRPCrescent(55),
  TWHRPKujira(56),
  TWHRPComdex(57),
  TWHRPNeutron(58);

  final int value;
  const TWHRP(this.value);

  static TWHRP fromValue(int value) => switch (value) {
        0 => TWHRPUnknown,
        1 => TWHRPBitcoin,
        2 => TWHRPLitecoin,
        3 => TWHRPViacoin,
        4 => TWHRPGroestlcoin,
        5 => TWHRPDigiByte,
        6 => TWHRPMonacoin,
        7 => TWHRPSyscoin,
        8 => TWHRPVerge,
        9 => TWHRPCosmos,
        10 => TWHRPBitcoinCash,
        11 => TWHRPBitcoinGold,
        12 => TWHRPIoTeX,
        13 => TWHRPNervos,
        14 => TWHRPZilliqa,
        15 => TWHRPTerra,
        16 => TWHRPCryptoOrg,
        17 => TWHRPKava,
        18 => TWHRPOasis,
        19 => TWHRPBluzelle,
        20 => TWHRPBandChain,
        21 => TWHRPMultiversX,
        22 => TWHRPSecret,
        23 => TWHRPAgoric,
        24 => TWHRPBinance,
        25 => TWHRPECash,
        26 => TWHRPTHORChain,
        27 => TWHRPBitcoinDiamond,
        28 => TWHRPHarmony,
        29 => TWHRPCardano,
        30 => TWHRPQtum,
        31 => TWHRPStratis,
        32 => TWHRPNativeInjective,
        33 => TWHRPOsmosis,
        34 => TWHRPTerraV2,
        35 => TWHRPCoreum,
        36 => TWHRPNativeZetaChain,
        37 => TWHRPNativeCanto,
        38 => TWHRPSommelier,
        39 => TWHRPFetchAI,
        40 => TWHRPMars,
        41 => TWHRPUmee,
        42 => TWHRPQuasar,
        43 => TWHRPPersistence,
        44 => TWHRPAkash,
        45 => TWHRPNoble,
        46 => TWHRPSei,
        47 => TWHRPStargaze,
        48 => TWHRPNativeEvmos,
        49 => TWHRPTia,
        50 => TWHRPDydx,
        51 => TWHRPJuno,
        52 => TWHRPTBinance,
        53 => TWHRPStride,
        54 => TWHRPAxelar,
        55 => TWHRPCrescent,
        56 => TWHRPKujira,
        57 => TWHRPComdex,
        58 => TWHRPNeutron,
        _ => throw ArgumentError("Unknown value for TWHRP: $value"),
      };
}

/// Defines a resizable string.
///
/// The implementantion of these methods should be language-specific to minimize translation
/// overhead. For instance it should be a `jstring` for Java and an `NSString` for Swift. Create
/// allocates memory, the delete call should be called at the end to release memory.
typedef TWString1 = ffi.Void;
typedef DartTWString1 = void;
typedef TWData1 = ffi.Void;
typedef DartTWData1 = void;

/// Public key types
enum TWPublicKeyType {
  TWPublicKeyTypeSECP256k1(0),
  TWPublicKeyTypeSECP256k1Extended(1),
  TWPublicKeyTypeNIST256p1(2),
  TWPublicKeyTypeNIST256p1Extended(3),
  TWPublicKeyTypeED25519(4),
  TWPublicKeyTypeED25519Blake2b(5),
  TWPublicKeyTypeCURVE25519(6),
  TWPublicKeyTypeED25519Cardano(7),
  TWPublicKeyTypeStarkex(8);

  final int value;
  const TWPublicKeyType(this.value);

  static TWPublicKeyType fromValue(int value) => switch (value) {
        0 => TWPublicKeyTypeSECP256k1,
        1 => TWPublicKeyTypeSECP256k1Extended,
        2 => TWPublicKeyTypeNIST256p1,
        3 => TWPublicKeyTypeNIST256p1Extended,
        4 => TWPublicKeyTypeED25519,
        5 => TWPublicKeyTypeED25519Blake2b,
        6 => TWPublicKeyTypeCURVE25519,
        7 => TWPublicKeyTypeED25519Cardano,
        8 => TWPublicKeyTypeStarkex,
        _ => throw ArgumentError("Unknown value for TWPublicKeyType: $value"),
      };
}

/// Represents a private key.
final class TWPrivateKey extends ffi.Opaque {}

/// Represents a public key.
final class TWPublicKey extends ffi.Opaque {}

/// Coin type for Level 2 of BIP44.
///
/// \see https://github.com/satoshilabs/slips/blob/master/slip-0044.md
enum TWCoinType {
  TWCoinTypeAeternity(457),
  TWCoinTypeAion(425),
  TWCoinTypeBinance(714),
  TWCoinTypeBitcoin(0),
  TWCoinTypeBitcoinCash(145),
  TWCoinTypeBitcoinGold(156),
  TWCoinTypeCallisto(820),
  TWCoinTypeCardano(1815),
  TWCoinTypeCosmos(118),
  TWCoinTypePivx(119),
  TWCoinTypeDash(5),
  TWCoinTypeDecred(42),
  TWCoinTypeDigiByte(20),
  TWCoinTypeDogecoin(3),
  TWCoinTypeEOS(194),
  TWCoinTypeWAX(14001),
  TWCoinTypeEthereum(60),
  TWCoinTypeEthereumClassic(61),
  TWCoinTypeFIO(235),
  TWCoinTypeGoChain(6060),
  TWCoinTypeGroestlcoin(17),
  TWCoinTypeICON(74),
  TWCoinTypeIoTeX(304),
  TWCoinTypeKava(459),
  TWCoinTypeKin(2017),
  TWCoinTypeLitecoin(2),
  TWCoinTypeMonacoin(22),
  TWCoinTypeNebulas(2718),
  TWCoinTypeNULS(8964),
  TWCoinTypeNano(165),
  TWCoinTypeNEAR(397),
  TWCoinTypeNimiq(242),
  TWCoinTypeOntology(1024),
  TWCoinTypePOANetwork(178),
  TWCoinTypeQtum(2301),
  TWCoinTypeXRP(144),
  TWCoinTypeSolana(501),
  TWCoinTypeStellar(148),
  TWCoinTypeTezos(1729),
  TWCoinTypeTheta(500),
  TWCoinTypeThunderCore(1001),
  TWCoinTypeNEO(888),
  TWCoinTypeViction(889),
  TWCoinTypeTron(195),
  TWCoinTypeVeChain(818),
  TWCoinTypeViacoin(14),
  TWCoinTypeWanchain(5718350),
  TWCoinTypeZcash(133),
  TWCoinTypeFiro(136),
  TWCoinTypeZilliqa(313),
  TWCoinTypeZelcash(19167),
  TWCoinTypeRavencoin(175),
  TWCoinTypeWaves(5741564),
  TWCoinTypeTerra(330),
  TWCoinTypeTerraV2(10000330),
  TWCoinTypeHarmony(1023),
  TWCoinTypeAlgorand(283),
  TWCoinTypeKusama(434),
  TWCoinTypePolkadot(354),
  TWCoinTypeFilecoin(461),
  TWCoinTypeMultiversX(508),
  TWCoinTypeBandChain(494),
  TWCoinTypeSmartChainLegacy(10000714),
  TWCoinTypeSmartChain(20000714),
  TWCoinTypeTBinance(30000714),
  TWCoinTypeOasis(474),
  TWCoinTypePolygon(966),
  TWCoinTypeTHORChain(931),
  TWCoinTypeBluzelle(483),
  TWCoinTypeOptimism(10000070),
  TWCoinTypeZksync(10000324),
  TWCoinTypeArbitrum(10042221),
  TWCoinTypeECOChain(10000553),
  TWCoinTypeAvalancheCChain(10009000),
  TWCoinTypeXDai(10000100),
  TWCoinTypeFantom(10000250),
  TWCoinTypeCryptoOrg(394),
  TWCoinTypeCelo(52752),
  TWCoinTypeRonin(10002020),
  TWCoinTypeOsmosis(10000118),
  TWCoinTypeECash(899),
  TWCoinTypeIOST(291),
  TWCoinTypeCronosChain(10000025),
  TWCoinTypeSmartBitcoinCash(10000145),
  TWCoinTypeKuCoinCommunityChain(10000321),
  TWCoinTypeBitcoinDiamond(999),
  TWCoinTypeBoba(10000288),
  TWCoinTypeSyscoin(57),
  TWCoinTypeVerge(77),
  TWCoinTypeZen(121),
  TWCoinTypeMetis(10001088),
  TWCoinTypeAurora(1323161554),
  TWCoinTypeEvmos(10009001),
  TWCoinTypeNativeEvmos(20009001),
  TWCoinTypeMoonriver(10001285),
  TWCoinTypeMoonbeam(10001284),
  TWCoinTypeKavaEvm(10002222),
  TWCoinTypeKlaytn(10008217),
  TWCoinTypeMeter(18000),
  TWCoinTypeOKXChain(996),
  TWCoinTypeStratis(105105),
  TWCoinTypeKomodo(141),
  TWCoinTypeNervos(309),
  TWCoinTypeEverscale(396),
  TWCoinTypeAptos(637),
  TWCoinTypeNebl(146),
  TWCoinTypeHedera(3030),
  TWCoinTypeSecret(529),
  TWCoinTypeNativeInjective(10000060),
  TWCoinTypeAgoric(564),
  TWCoinTypeTON(607),
  TWCoinTypeSui(784),
  TWCoinTypeStargaze(20000118),
  TWCoinTypePolygonzkEVM(10001101),
  TWCoinTypeJuno(30000118),
  TWCoinTypeStride(40000118),
  TWCoinTypeAxelar(50000118),
  TWCoinTypeCrescent(60000118),
  TWCoinTypeKujira(70000118),
  TWCoinTypeIoTeXEVM(10004689),
  TWCoinTypeNativeCanto(10007700),
  TWCoinTypeComdex(80000118),
  TWCoinTypeNeutron(90000118),
  TWCoinTypeSommelier(11000118),
  TWCoinTypeFetchAI(12000118),
  TWCoinTypeMars(13000118),
  TWCoinTypeUmee(14000118),
  TWCoinTypeCoreum(10000990),
  TWCoinTypeQuasar(15000118),
  TWCoinTypePersistence(16000118),
  TWCoinTypeAkash(17000118),
  TWCoinTypeNoble(18000118),
  TWCoinTypeScroll(534352),
  TWCoinTypeRootstock(137),
  TWCoinTypeThetaFuel(361),
  TWCoinTypeConfluxeSpace(1030),
  TWCoinTypeAcala(787),
  TWCoinTypeAcalaEVM(10000787),
  TWCoinTypeOpBNB(204),
  TWCoinTypeNeon(245022934),
  TWCoinTypeBase(8453),
  TWCoinTypeSei(19000118),
  TWCoinTypeArbitrumNova(10042170),
  TWCoinTypeLinea(59144),
  TWCoinTypeGreenfield(5600),
  TWCoinTypeMantle(5000),
  TWCoinTypeZenEON(7332),
  TWCoinTypeInternetComputer(223),
  TWCoinTypeTia(21000118),
  TWCoinTypeMantaPacific(169),
  TWCoinTypeNativeZetaChain(10007000),
  TWCoinTypeZetaEVM(20007000),
  TWCoinTypeDydx(22000118),
  TWCoinTypeMerlin(4200),
  TWCoinTypeLightlink(1890),
  TWCoinTypeBlast(81457),
  TWCoinTypeBounceBit(6001),
  TWCoinTypeZkLinkNova(810180);

  final int value;
  const TWCoinType(this.value);

  static TWCoinType fromValue(int value) => switch (value) {
        457 => TWCoinTypeAeternity,
        425 => TWCoinTypeAion,
        714 => TWCoinTypeBinance,
        0 => TWCoinTypeBitcoin,
        145 => TWCoinTypeBitcoinCash,
        156 => TWCoinTypeBitcoinGold,
        820 => TWCoinTypeCallisto,
        1815 => TWCoinTypeCardano,
        118 => TWCoinTypeCosmos,
        119 => TWCoinTypePivx,
        5 => TWCoinTypeDash,
        42 => TWCoinTypeDecred,
        20 => TWCoinTypeDigiByte,
        3 => TWCoinTypeDogecoin,
        194 => TWCoinTypeEOS,
        14001 => TWCoinTypeWAX,
        60 => TWCoinTypeEthereum,
        61 => TWCoinTypeEthereumClassic,
        235 => TWCoinTypeFIO,
        6060 => TWCoinTypeGoChain,
        17 => TWCoinTypeGroestlcoin,
        74 => TWCoinTypeICON,
        304 => TWCoinTypeIoTeX,
        459 => TWCoinTypeKava,
        2017 => TWCoinTypeKin,
        2 => TWCoinTypeLitecoin,
        22 => TWCoinTypeMonacoin,
        2718 => TWCoinTypeNebulas,
        8964 => TWCoinTypeNULS,
        165 => TWCoinTypeNano,
        397 => TWCoinTypeNEAR,
        242 => TWCoinTypeNimiq,
        1024 => TWCoinTypeOntology,
        178 => TWCoinTypePOANetwork,
        2301 => TWCoinTypeQtum,
        144 => TWCoinTypeXRP,
        501 => TWCoinTypeSolana,
        148 => TWCoinTypeStellar,
        1729 => TWCoinTypeTezos,
        500 => TWCoinTypeTheta,
        1001 => TWCoinTypeThunderCore,
        888 => TWCoinTypeNEO,
        889 => TWCoinTypeViction,
        195 => TWCoinTypeTron,
        818 => TWCoinTypeVeChain,
        14 => TWCoinTypeViacoin,
        5718350 => TWCoinTypeWanchain,
        133 => TWCoinTypeZcash,
        136 => TWCoinTypeFiro,
        313 => TWCoinTypeZilliqa,
        19167 => TWCoinTypeZelcash,
        175 => TWCoinTypeRavencoin,
        5741564 => TWCoinTypeWaves,
        330 => TWCoinTypeTerra,
        10000330 => TWCoinTypeTerraV2,
        1023 => TWCoinTypeHarmony,
        283 => TWCoinTypeAlgorand,
        434 => TWCoinTypeKusama,
        354 => TWCoinTypePolkadot,
        461 => TWCoinTypeFilecoin,
        508 => TWCoinTypeMultiversX,
        494 => TWCoinTypeBandChain,
        10000714 => TWCoinTypeSmartChainLegacy,
        20000714 => TWCoinTypeSmartChain,
        30000714 => TWCoinTypeTBinance,
        474 => TWCoinTypeOasis,
        966 => TWCoinTypePolygon,
        931 => TWCoinTypeTHORChain,
        483 => TWCoinTypeBluzelle,
        10000070 => TWCoinTypeOptimism,
        10000324 => TWCoinTypeZksync,
        10042221 => TWCoinTypeArbitrum,
        10000553 => TWCoinTypeECOChain,
        10009000 => TWCoinTypeAvalancheCChain,
        10000100 => TWCoinTypeXDai,
        10000250 => TWCoinTypeFantom,
        394 => TWCoinTypeCryptoOrg,
        52752 => TWCoinTypeCelo,
        10002020 => TWCoinTypeRonin,
        10000118 => TWCoinTypeOsmosis,
        899 => TWCoinTypeECash,
        291 => TWCoinTypeIOST,
        10000025 => TWCoinTypeCronosChain,
        10000145 => TWCoinTypeSmartBitcoinCash,
        10000321 => TWCoinTypeKuCoinCommunityChain,
        999 => TWCoinTypeBitcoinDiamond,
        10000288 => TWCoinTypeBoba,
        57 => TWCoinTypeSyscoin,
        77 => TWCoinTypeVerge,
        121 => TWCoinTypeZen,
        10001088 => TWCoinTypeMetis,
        1323161554 => TWCoinTypeAurora,
        10009001 => TWCoinTypeEvmos,
        20009001 => TWCoinTypeNativeEvmos,
        10001285 => TWCoinTypeMoonriver,
        10001284 => TWCoinTypeMoonbeam,
        10002222 => TWCoinTypeKavaEvm,
        10008217 => TWCoinTypeKlaytn,
        18000 => TWCoinTypeMeter,
        996 => TWCoinTypeOKXChain,
        105105 => TWCoinTypeStratis,
        141 => TWCoinTypeKomodo,
        309 => TWCoinTypeNervos,
        396 => TWCoinTypeEverscale,
        637 => TWCoinTypeAptos,
        146 => TWCoinTypeNebl,
        3030 => TWCoinTypeHedera,
        529 => TWCoinTypeSecret,
        10000060 => TWCoinTypeNativeInjective,
        564 => TWCoinTypeAgoric,
        607 => TWCoinTypeTON,
        784 => TWCoinTypeSui,
        20000118 => TWCoinTypeStargaze,
        10001101 => TWCoinTypePolygonzkEVM,
        30000118 => TWCoinTypeJuno,
        40000118 => TWCoinTypeStride,
        50000118 => TWCoinTypeAxelar,
        60000118 => TWCoinTypeCrescent,
        70000118 => TWCoinTypeKujira,
        10004689 => TWCoinTypeIoTeXEVM,
        10007700 => TWCoinTypeNativeCanto,
        80000118 => TWCoinTypeComdex,
        90000118 => TWCoinTypeNeutron,
        11000118 => TWCoinTypeSommelier,
        12000118 => TWCoinTypeFetchAI,
        13000118 => TWCoinTypeMars,
        14000118 => TWCoinTypeUmee,
        10000990 => TWCoinTypeCoreum,
        15000118 => TWCoinTypeQuasar,
        16000118 => TWCoinTypePersistence,
        17000118 => TWCoinTypeAkash,
        18000118 => TWCoinTypeNoble,
        534352 => TWCoinTypeScroll,
        137 => TWCoinTypeRootstock,
        361 => TWCoinTypeThetaFuel,
        1030 => TWCoinTypeConfluxeSpace,
        787 => TWCoinTypeAcala,
        10000787 => TWCoinTypeAcalaEVM,
        204 => TWCoinTypeOpBNB,
        245022934 => TWCoinTypeNeon,
        8453 => TWCoinTypeBase,
        19000118 => TWCoinTypeSei,
        10042170 => TWCoinTypeArbitrumNova,
        59144 => TWCoinTypeLinea,
        5600 => TWCoinTypeGreenfield,
        5000 => TWCoinTypeMantle,
        7332 => TWCoinTypeZenEON,
        223 => TWCoinTypeInternetComputer,
        21000118 => TWCoinTypeTia,
        169 => TWCoinTypeMantaPacific,
        10007000 => TWCoinTypeNativeZetaChain,
        20007000 => TWCoinTypeZetaEVM,
        22000118 => TWCoinTypeDydx,
        4200 => TWCoinTypeMerlin,
        1890 => TWCoinTypeLightlink,
        81457 => TWCoinTypeBlast,
        6001 => TWCoinTypeBounceBit,
        810180 => TWCoinTypeZkLinkNova,
        _ => throw ArgumentError("Unknown value for TWCoinType: $value"),
      };
}

/// CoinTypeConfiguration functions
final class TWCoinTypeConfiguration extends ffi.Struct {
  @ffi.Uint8()
  external int unused;
}

/// Represents a BIP44 DerivationPath in C++.
final class TWDerivationPath extends ffi.Opaque {}

final class TWDerivationPathIndex extends ffi.Opaque {}

/// Hierarchical Deterministic (HD) Wallet
final class TWHDWallet extends ffi.Opaque {}

final class TWEthereumRlp extends ffi.Opaque {}

/// A vector of TWData byte arrays
final class TWDataVector extends ffi.Opaque {}

/// Non-core transaction utility methods, like building a transaction using an external signature.
final class TWTransactionCompiler extends ffi.Opaque {}

final class TWStarkWare extends ffi.Opaque {}

/// Bitcoin SIGHASH type.
enum TWBitcoinSigHashType {
  TWBitcoinSigHashTypeAll(1),
  TWBitcoinSigHashTypeNone(2),
  TWBitcoinSigHashTypeSingle(3),
  TWBitcoinSigHashTypeFork(64),
  TWBitcoinSigHashTypeForkBTG(20288),
  TWBitcoinSigHashTypeAnyoneCanPay(128);

  final int value;
  const TWBitcoinSigHashType(this.value);

  static TWBitcoinSigHashType fromValue(int value) => switch (value) {
        1 => TWBitcoinSigHashTypeAll,
        2 => TWBitcoinSigHashTypeNone,
        3 => TWBitcoinSigHashTypeSingle,
        64 => TWBitcoinSigHashTypeFork,
        20288 => TWBitcoinSigHashTypeForkBTG,
        128 => TWBitcoinSigHashTypeAnyoneCanPay,
        _ =>
          throw ArgumentError("Unknown value for TWBitcoinSigHashType: $value"),
      };
}

/// Represents Ethereum ABI value
final class TWEthereumAbiValue extends ffi.Opaque {}

/// Represents a signer to sign transactions for any blockchain.
final class TWAnySigner extends ffi.Opaque {}

/// Represents a Nervos address.
final class TWNervosAddress extends ffi.Opaque {}

/// Preset encryption kind
enum TWStoredKeyEncryption {
  TWStoredKeyEncryptionAes128Ctr(0),
  TWStoredKeyEncryptionAes128Cbc(1),
  TWStoredKeyEncryptionAes192Ctr(2),
  TWStoredKeyEncryptionAes256Ctr(3);

  final int value;
  const TWStoredKeyEncryption(this.value);

  static TWStoredKeyEncryption fromValue(int value) => switch (value) {
        0 => TWStoredKeyEncryptionAes128Ctr,
        1 => TWStoredKeyEncryptionAes128Cbc,
        2 => TWStoredKeyEncryptionAes192Ctr,
        3 => TWStoredKeyEncryptionAes256Ctr,
        _ => throw ArgumentError(
            "Unknown value for TWStoredKeyEncryption: $value"),
      };
}

/// Base64 encode / decode functions
final class TWBase64 extends ffi.Opaque {}

/// Represents a BIP 0173 address.
final class TWSegwitAddress extends ffi.Opaque {}

/// Ethereum message signing and verification.
///
/// Ethereum and some other wallets support a message signing & verification format, to create a proof (a signature)
/// that someone has access to the private keys of a specific address.
final class TWEthereumMessageSigner extends ffi.Opaque {}

/// Stellar memo type.
enum TWStellarMemoType {
  TWStellarMemoTypeNone(0),
  TWStellarMemoTypeText(1),
  TWStellarMemoTypeId(2),
  TWStellarMemoTypeHash(3),
  TWStellarMemoTypeReturn(4);

  final int value;
  const TWStellarMemoType(this.value);

  static TWStellarMemoType fromValue(int value) => switch (value) {
        0 => TWStellarMemoTypeNone,
        1 => TWStellarMemoTypeText,
        2 => TWStellarMemoTypeId,
        3 => TWStellarMemoTypeHash,
        4 => TWStellarMemoTypeReturn,
        _ => throw ArgumentError("Unknown value for TWStellarMemoType: $value"),
      };
}

final class TWTransactionDecoder extends ffi.Opaque {}

/// Represents a legacy Bitcoin address in C++.
final class TWBitcoinAddress extends ffi.Opaque {}

/// Firo address type.
enum TWFiroAddressType {
  TWFiroAddressTypeDefault(0),
  TWFiroAddressTypeExchange(1);

  final int value;
  const TWFiroAddressType(this.value);

  static TWFiroAddressType fromValue(int value) => switch (value) {
        0 => TWFiroAddressTypeDefault,
        1 => TWFiroAddressTypeExchange,
        _ => throw ArgumentError("Unknown value for TWFiroAddressType: $value"),
      };
}

/// Represents an address in C++ for almost any blockchain.
final class TWAnyAddress extends ffi.Opaque {}

/// Represents an ASN.1 DER parser.
final class TWAsnParser extends ffi.Opaque {}

/// THORChain swap functions
final class TWTHORChainSwap extends ffi.Opaque {}

/// Base58 encode / decode functions
final class TWBase58 extends ffi.Opaque {}

/// Cardano helper functions
final class TWCardano extends ffi.Opaque {}

/// Substrate based chains Address Type
///
/// \see https://github.com/paritytech/substrate/wiki/External-Address-Format-(SS58)#address-type
enum TWSS58AddressType {
  TWSS58AddressTypePolkadot(0),
  TWSS58AddressTypeKusama(2);

  final int value;
  const TWSS58AddressType(this.value);

  static TWSS58AddressType fromValue(int value) => switch (value) {
        0 => TWSS58AddressTypePolkadot,
        2 => TWSS58AddressTypeKusama,
        _ => throw ArgumentError("Unknown value for TWSS58AddressType: $value"),
      };
}

/// Represents a Ripple X-address.
final class TWRippleXAddress extends ffi.Opaque {}

/// THORChain swap functions
final class TWLiquidStaking extends ffi.Opaque {}

/// TON address operations.
final class TWTONAddressConverter extends ffi.Opaque {}

/// Represents a WalletConnect signing request.
final class TWWalletConnectRequest extends ffi.Opaque {}

/// Tron message signing and verification.
///
/// Tron and some other wallets support a message signing & verification format, to create a proof (a signature)
/// that someone has access to the private keys of a specific address.
final class TWTronMessageSigner extends ffi.Opaque {}

final class TWWebAuthn extends ffi.Opaque {}

/// Password-Based Key Derivation Function 2
final class TWPBKDF2 extends ffi.Opaque {}

/// Filecoin-Ethereum address converter.
final class TWFilecoinAddressConverter extends ffi.Opaque {}

/// Public key used in `crypto_box` cryptography.
final class TWCryptoBoxPublicKey extends ffi.Opaque {}

/// Secret key used in `crypto_box` cryptography.
final class TWCryptoBoxSecretKey extends ffi.Opaque {}

/// Base32 encode / decode functions
final class TWBase32 extends ffi.Opaque {}

/// Wrapper class for Ethereum ABI encoding & decoding.
final class TWEthereumAbiFunction extends ffi.Opaque {}

final class TWEthereumAbi extends ffi.Opaque {}

/// Tezos message signing, verification and utilities.
final class TWTezosMessageSigner extends ffi.Opaque {}

/// Stellar network passphrase string.
enum TWStellarPassphrase {
  TWStellarPassphraseStellar(0),
  TWStellarPassphraseKin(1);

  final int value;
  const TWStellarPassphrase(this.value);

  static TWStellarPassphrase fromValue(int value) => switch (value) {
        0 => TWStellarPassphraseStellar,
        1 => TWStellarPassphraseKin,
        _ =>
          throw ArgumentError("Unknown value for TWStellarPassphrase: $value"),
      };
}

/// Hash functions
final class TWHash extends ffi.Struct {
  @ffi.Uint8()
  external int unused;
}

/// Preset encryption parameter with different security strength, for key store
enum TWStoredKeyEncryptionLevel {
  /// Default, which is one of the below values, determined by the implementation.
  TWStoredKeyEncryptionLevelDefault(0),

  /// Minimal sufficient level of encryption strength (scrypt 4096)
  TWStoredKeyEncryptionLevelMinimal(1),

  /// Weak encryption strength (scrypt 16k)
  TWStoredKeyEncryptionLevelWeak(2),

  /// Standard level of encryption strength (scrypt 262k)
  TWStoredKeyEncryptionLevelStandard(3);

  final int value;
  const TWStoredKeyEncryptionLevel(this.value);

  static TWStoredKeyEncryptionLevel fromValue(int value) => switch (value) {
        0 => TWStoredKeyEncryptionLevelDefault,
        1 => TWStoredKeyEncryptionLevelMinimal,
        2 => TWStoredKeyEncryptionLevelWeak,
        3 => TWStoredKeyEncryptionLevelStandard,
        _ => throw ArgumentError(
            "Unknown value for TWStoredKeyEncryptionLevel: $value"),
      };
}

/// Represents a key stored as an encrypted file.
final class TWStoredKey extends ffi.Opaque {}

final class TWAccount extends ffi.Opaque {}

/// Private key types, the vast majority of chains use the default, 32-byte key.
enum TWPrivateKeyType {
  TWPrivateKeyTypeDefault(0),
  TWPrivateKeyTypeCardano(1);

  final int value;
  const TWPrivateKeyType(this.value);

  static TWPrivateKeyType fromValue(int value) => switch (value) {
        0 => TWPrivateKeyTypeDefault,
        1 => TWPrivateKeyTypeCardano,
        _ => throw ArgumentError("Unknown value for TWPrivateKeyType: $value"),
      };
}

/// Bitcoin script manipulating functions
final class TWBitcoinScript extends ffi.Opaque {}

/// Represents a FIO Account name
final class TWFIOAccount extends ffi.Opaque {}

/// Represents a legacy Groestlcoin address.
final class TWGroestlcoinAddress extends ffi.Opaque {}

/// `crypto_box` encryption algorithms.
final class TWCryptoBox extends ffi.Opaque {}

/// Mnemonic validate / lookup functions
final class TWMnemonic extends ffi.Opaque {}

/// Stellar address version byte.
enum TWStellarVersionByte {
  TWStellarVersionByteAccountID(48),
  TWStellarVersionByteSeed(192),
  TWStellarVersionBytePreAuthTX(200),
  TWStellarVersionByteSHA256Hash(280);

  final int value;
  const TWStellarVersionByte(this.value);

  static TWStellarVersionByte fromValue(int value) => switch (value) {
        48 => TWStellarVersionByteAccountID,
        192 => TWStellarVersionByteSeed,
        200 => TWStellarVersionBytePreAuthTX,
        280 => TWStellarVersionByteSHA256Hash,
        _ =>
          throw ArgumentError("Unknown value for TWStellarVersionByte: $value"),
      };
}

final class TWEthereum extends ffi.Opaque {}

/// Padding mode used in AES encryption.
enum TWAESPaddingMode {
  TWAESPaddingModeZero(0),
  TWAESPaddingModePKCS7(1);

  final int value;
  const TWAESPaddingMode(this.value);

  static TWAESPaddingMode fromValue(int value) => switch (value) {
        0 => TWAESPaddingModeZero,
        1 => TWAESPaddingModePKCS7,
        _ => throw ArgumentError("Unknown value for TWAESPaddingMode: $value"),
      };
}

/// AES encryption/decryption methods.
final class TWAES extends ffi.Struct {
  @ffi.Uint8()
  external int unused;
}

final class TWSolanaTransaction extends ffi.Opaque {}

/// Represents a NEAR Account name
final class TWNEARAccount extends ffi.Opaque {}

/// Bitcoin message signing and verification.
///
/// Bitcoin Core and some other wallets support a message signing & verification format, to create a proof (a signature)
/// that someone has access to the private keys of a specific address.
/// This feature currently works on old legacy addresses only.
final class TWBitcoinMessageSigner extends ffi.Opaque {}

/// StarkEx message signing and verification.
///
/// StarkEx and some other wallets support a message signing & verification format, to create a proof (a signature)
/// that someone has access to the private keys of a specific address.
final class TWStarkExMessageSigner extends ffi.Opaque {}

/// Chain identifiers for Ethereum-based blockchains, for convenience. Recommended to use the dynamic CoinType.ChainId() instead.
/// See also TWChainId.
enum TWEthereumChainID {
  TWEthereumChainIDEthereum(1),
  TWEthereumChainIDClassic(61),
  TWEthereumChainIDRootstock(30),
  TWEthereumChainIDManta(169),
  TWEthereumChainIDPoa(99),
  TWEthereumChainIDOpbnb(204),
  TWEthereumChainIDTfuelevm(361),
  TWEthereumChainIDVechain(74),
  TWEthereumChainIDCallisto(820),
  TWEthereumChainIDViction(88),
  TWEthereumChainIDPolygon(137),
  TWEthereumChainIDOkc(66),
  TWEthereumChainIDThundertoken(108),
  TWEthereumChainIDCfxevm(1030),
  TWEthereumChainIDLightlink(1890),
  TWEthereumChainIDMerlin(4200),
  TWEthereumChainIDMantle(5000),
  TWEthereumChainIDBouncebit(6001),
  TWEthereumChainIDGochain(60),
  TWEthereumChainIDZeneon(7332),
  TWEthereumChainIDBase(8453),
  TWEthereumChainIDMeter(82),
  TWEthereumChainIDCelo(42220),
  TWEthereumChainIDLinea(59144),
  TWEthereumChainIDBlast(81457),
  TWEthereumChainIDScroll(534352),
  TWEthereumChainIDZklinknova(810180),
  TWEthereumChainIDWanchain(888),
  TWEthereumChainIDCronos(25),
  TWEthereumChainIDOptimism(10),
  TWEthereumChainIDXdai(100),
  TWEthereumChainIDSmartbch(10000),
  TWEthereumChainIDFantom(250),
  TWEthereumChainIDBoba(288),
  TWEthereumChainIDKcc(321),
  TWEthereumChainIDZksync(324),
  TWEthereumChainIDHeco(128),
  TWEthereumChainIDAcalaevm(787),
  TWEthereumChainIDMetis(1088),
  TWEthereumChainIDPolygonzkevm(1101),
  TWEthereumChainIDMoonbeam(1284),
  TWEthereumChainIDMoonriver(1285),
  TWEthereumChainIDRonin(2020),
  TWEthereumChainIDKavaevm(2222),
  TWEthereumChainIDIotexevm(4689),
  TWEthereumChainIDKlaytn(8217),
  TWEthereumChainIDAvalanchec(43114),
  TWEthereumChainIDEvmos(9001),
  TWEthereumChainIDArbitrumnova(42170),
  TWEthereumChainIDArbitrum(42161),
  TWEthereumChainIDSmartchain(56),
  TWEthereumChainIDZetaevm(7000),
  TWEthereumChainIDNeon(245022934),
  TWEthereumChainIDAurora(1313161554);

  final int value;
  const TWEthereumChainID(this.value);

  static TWEthereumChainID fromValue(int value) => switch (value) {
        1 => TWEthereumChainIDEthereum,
        61 => TWEthereumChainIDClassic,
        30 => TWEthereumChainIDRootstock,
        169 => TWEthereumChainIDManta,
        99 => TWEthereumChainIDPoa,
        204 => TWEthereumChainIDOpbnb,
        361 => TWEthereumChainIDTfuelevm,
        74 => TWEthereumChainIDVechain,
        820 => TWEthereumChainIDCallisto,
        88 => TWEthereumChainIDViction,
        137 => TWEthereumChainIDPolygon,
        66 => TWEthereumChainIDOkc,
        108 => TWEthereumChainIDThundertoken,
        1030 => TWEthereumChainIDCfxevm,
        1890 => TWEthereumChainIDLightlink,
        4200 => TWEthereumChainIDMerlin,
        5000 => TWEthereumChainIDMantle,
        6001 => TWEthereumChainIDBouncebit,
        60 => TWEthereumChainIDGochain,
        7332 => TWEthereumChainIDZeneon,
        8453 => TWEthereumChainIDBase,
        82 => TWEthereumChainIDMeter,
        42220 => TWEthereumChainIDCelo,
        59144 => TWEthereumChainIDLinea,
        81457 => TWEthereumChainIDBlast,
        534352 => TWEthereumChainIDScroll,
        810180 => TWEthereumChainIDZklinknova,
        888 => TWEthereumChainIDWanchain,
        25 => TWEthereumChainIDCronos,
        10 => TWEthereumChainIDOptimism,
        100 => TWEthereumChainIDXdai,
        10000 => TWEthereumChainIDSmartbch,
        250 => TWEthereumChainIDFantom,
        288 => TWEthereumChainIDBoba,
        321 => TWEthereumChainIDKcc,
        324 => TWEthereumChainIDZksync,
        128 => TWEthereumChainIDHeco,
        787 => TWEthereumChainIDAcalaevm,
        1088 => TWEthereumChainIDMetis,
        1101 => TWEthereumChainIDPolygonzkevm,
        1284 => TWEthereumChainIDMoonbeam,
        1285 => TWEthereumChainIDMoonriver,
        2020 => TWEthereumChainIDRonin,
        2222 => TWEthereumChainIDKavaevm,
        4689 => TWEthereumChainIDIotexevm,
        8217 => TWEthereumChainIDKlaytn,
        43114 => TWEthereumChainIDAvalanchec,
        9001 => TWEthereumChainIDEvmos,
        42170 => TWEthereumChainIDArbitrumnova,
        42161 => TWEthereumChainIDArbitrum,
        56 => TWEthereumChainIDSmartchain,
        7000 => TWEthereumChainIDZetaevm,
        245022934 => TWEthereumChainIDNeon,
        1313161554 => TWEthereumChainIDAurora,
        _ => throw ArgumentError("Unknown value for TWEthereumChainID: $value"),
      };
}

/// Solana address helper functions
final class TWSolanaAddress extends ffi.Opaque {}

/// Barz functions
final class TWBarz extends ffi.Opaque {}

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;

const int __has_safe_buffers = 1;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int USER_ADDR_NULL = 0;

const int __WORDSIZE = 64;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOS = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_5 = 101405;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_12_4 = 120400;

const int __MAC_12_5 = 120500;

const int __MAC_12_6 = 120600;

const int __MAC_12_7 = 120700;

const int __MAC_13_0 = 130000;

const int __MAC_13_1 = 130100;

const int __MAC_13_2 = 130200;

const int __MAC_13_3 = 130300;

const int __MAC_13_4 = 130400;

const int __MAC_13_5 = 130500;

const int __MAC_13_6 = 130600;

const int __MAC_14_0 = 140000;

const int __MAC_14_1 = 140100;

const int __MAC_14_2 = 140200;

const int __MAC_14_3 = 140300;

const int __MAC_14_4 = 140400;

const int __MAC_14_5 = 140500;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_4 = 140400;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_15_5 = 150500;

const int __IPHONE_15_6 = 150600;

const int __IPHONE_15_7 = 150700;

const int __IPHONE_15_8 = 150800;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __IPHONE_16_2 = 160200;

const int __IPHONE_16_3 = 160300;

const int __IPHONE_16_4 = 160400;

const int __IPHONE_16_5 = 160500;

const int __IPHONE_16_6 = 160600;

const int __IPHONE_16_7 = 160700;

const int __IPHONE_17_0 = 170000;

const int __IPHONE_17_1 = 170100;

const int __IPHONE_17_2 = 170200;

const int __IPHONE_17_3 = 170300;

const int __IPHONE_17_4 = 170400;

const int __IPHONE_17_5 = 170500;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_8_6 = 80600;

const int __WATCHOS_8_7 = 80700;

const int __WATCHOS_8_8 = 80800;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __WATCHOS_9_2 = 90200;

const int __WATCHOS_9_3 = 90300;

const int __WATCHOS_9_4 = 90400;

const int __WATCHOS_9_5 = 90500;

const int __WATCHOS_9_6 = 90600;

const int __WATCHOS_10_0 = 100000;

const int __WATCHOS_10_1 = 100100;

const int __WATCHOS_10_2 = 100200;

const int __WATCHOS_10_3 = 100300;

const int __WATCHOS_10_4 = 100400;

const int __WATCHOS_10_5 = 100500;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_15_5 = 150500;

const int __TVOS_15_6 = 150600;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __TVOS_16_2 = 160200;

const int __TVOS_16_3 = 160300;

const int __TVOS_16_4 = 160400;

const int __TVOS_16_5 = 160500;

const int __TVOS_16_6 = 160600;

const int __TVOS_17_0 = 170000;

const int __TVOS_17_1 = 170100;

const int __TVOS_17_2 = 170200;

const int __TVOS_17_3 = 170300;

const int __TVOS_17_4 = 170400;

const int __TVOS_17_5 = 170500;

const int __BRIDGEOS_2_0 = 20000;

const int __BRIDGEOS_3_0 = 30000;

const int __BRIDGEOS_3_1 = 30100;

const int __BRIDGEOS_3_4 = 30400;

const int __BRIDGEOS_4_0 = 40000;

const int __BRIDGEOS_4_1 = 40100;

const int __BRIDGEOS_5_0 = 50000;

const int __BRIDGEOS_5_1 = 50100;

const int __BRIDGEOS_5_3 = 50300;

const int __BRIDGEOS_6_0 = 60000;

const int __BRIDGEOS_6_2 = 60200;

const int __BRIDGEOS_6_4 = 60400;

const int __BRIDGEOS_6_5 = 60500;

const int __BRIDGEOS_6_6 = 60600;

const int __BRIDGEOS_7_0 = 70000;

const int __BRIDGEOS_7_1 = 70100;

const int __BRIDGEOS_7_2 = 70200;

const int __BRIDGEOS_7_3 = 70300;

const int __BRIDGEOS_7_4 = 70400;

const int __BRIDGEOS_7_6 = 70600;

const int __BRIDGEOS_8_0 = 80000;

const int __BRIDGEOS_8_1 = 80100;

const int __BRIDGEOS_8_2 = 80200;

const int __BRIDGEOS_8_3 = 80300;

const int __BRIDGEOS_8_4 = 80400;

const int __BRIDGEOS_8_5 = 80500;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __DRIVERKIT_22_0 = 220000;

const int __DRIVERKIT_22_4 = 220400;

const int __DRIVERKIT_22_5 = 220500;

const int __DRIVERKIT_22_6 = 220600;

const int __DRIVERKIT_23_0 = 230000;

const int __DRIVERKIT_23_1 = 230100;

const int __DRIVERKIT_23_2 = 230200;

const int __DRIVERKIT_23_3 = 230300;

const int __DRIVERKIT_23_4 = 230400;

const int __DRIVERKIT_23_5 = 230500;

const int __VISIONOS_1_0 = 10000;

const int __VISIONOS_1_1 = 10100;

const int __VISIONOS_1_2 = 10200;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_5 = 101405;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_15_4 = 101504;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_11_1 = 110100;

const int MAC_OS_VERSION_11_3 = 110300;

const int MAC_OS_VERSION_11_4 = 110400;

const int MAC_OS_VERSION_11_5 = 110500;

const int MAC_OS_VERSION_11_6 = 110600;

const int MAC_OS_VERSION_12_0 = 120000;

const int MAC_OS_VERSION_12_1 = 120100;

const int MAC_OS_VERSION_12_2 = 120200;

const int MAC_OS_VERSION_12_3 = 120300;

const int MAC_OS_VERSION_12_4 = 120400;

const int MAC_OS_VERSION_12_5 = 120500;

const int MAC_OS_VERSION_12_6 = 120600;

const int MAC_OS_VERSION_12_7 = 120700;

const int MAC_OS_VERSION_13_0 = 130000;

const int MAC_OS_VERSION_13_1 = 130100;

const int MAC_OS_VERSION_13_2 = 130200;

const int MAC_OS_VERSION_13_3 = 130300;

const int MAC_OS_VERSION_13_4 = 130400;

const int MAC_OS_VERSION_13_5 = 130500;

const int MAC_OS_VERSION_13_6 = 130600;

const int MAC_OS_VERSION_14_0 = 140000;

const int MAC_OS_VERSION_14_1 = 140100;

const int MAC_OS_VERSION_14_2 = 140200;

const int MAC_OS_VERSION_14_3 = 140300;

const int MAC_OS_VERSION_14_4 = 140400;

const int MAC_OS_VERSION_14_5 = 140500;

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 140000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 140500;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int __DARWIN_NSIG = 32;

const int NSIG = 32;

const int _ARM_SIGNAL_ = 1;

const int SIGHUP = 1;

const int SIGINT = 2;

const int SIGQUIT = 3;

const int SIGILL = 4;

const int SIGTRAP = 5;

const int SIGABRT = 6;

const int SIGIOT = 6;

const int SIGEMT = 7;

const int SIGFPE = 8;

const int SIGKILL = 9;

const int SIGBUS = 10;

const int SIGSEGV = 11;

const int SIGSYS = 12;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGTERM = 15;

const int SIGURG = 16;

const int SIGSTOP = 17;

const int SIGTSTP = 18;

const int SIGCONT = 19;

const int SIGCHLD = 20;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGIO = 23;

const int SIGXCPU = 24;

const int SIGXFSZ = 25;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGWINCH = 28;

const int SIGINFO = 29;

const int SIGUSR1 = 30;

const int SIGUSR2 = 31;

const int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = 0;

const int SIGEV_NONE = 0;

const int SIGEV_SIGNAL = 1;

const int SIGEV_THREAD = 3;

const int ILL_NOOP = 0;

const int ILL_ILLOPC = 1;

const int ILL_ILLTRP = 2;

const int ILL_PRVOPC = 3;

const int ILL_ILLOPN = 4;

const int ILL_ILLADR = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int FPE_NOOP = 0;

const int FPE_FLTDIV = 1;

const int FPE_FLTOVF = 2;

const int FPE_FLTUND = 3;

const int FPE_FLTRES = 4;

const int FPE_FLTINV = 5;

const int FPE_FLTSUB = 6;

const int FPE_INTDIV = 7;

const int FPE_INTOVF = 8;

const int SEGV_NOOP = 0;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int BUS_NOOP = 0;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int TRAP_BRKPT = 1;

const int TRAP_TRACE = 2;

const int CLD_NOOP = 0;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SA_ONSTACK = 1;

const int SA_RESTART = 2;

const int SA_RESETHAND = 4;

const int SA_NOCLDSTOP = 8;

const int SA_NODEFER = 16;

const int SA_NOCLDWAIT = 32;

const int SA_SIGINFO = 64;

const int SA_USERTRAMP = 256;

const int SA_64REGSET = 512;

const int SA_USERSPACE_MASK = 127;

const int SIG_BLOCK = 1;

const int SIG_UNBLOCK = 2;

const int SIG_SETMASK = 3;

const int SI_USER = 65537;

const int SI_QUEUE = 65538;

const int SI_TIMER = 65539;

const int SI_ASYNCIO = 65540;

const int SI_MESGQ = 65541;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 4;

const int MINSIGSTKSZ = 32768;

const int SIGSTKSZ = 131072;

const int SV_ONSTACK = 1;

const int SV_INTERRUPT = 2;

const int SV_RESETHAND = 4;

const int SV_NODEFER = 16;

const int SV_NOCLDSTOP = 8;

const int SV_SIGINFO = 64;

const int PRIO_PROCESS = 0;

const int PRIO_PGRP = 1;

const int PRIO_USER = 2;

const int PRIO_DARWIN_THREAD = 3;

const int PRIO_DARWIN_PROCESS = 4;

const int PRIO_MIN = -20;

const int PRIO_MAX = 20;

const int PRIO_DARWIN_BG = 4096;

const int PRIO_DARWIN_NONUI = 4097;

const int RUSAGE_SELF = 0;

const int RUSAGE_CHILDREN = -1;

const int RUSAGE_INFO_V0 = 0;

const int RUSAGE_INFO_V1 = 1;

const int RUSAGE_INFO_V2 = 2;

const int RUSAGE_INFO_V3 = 3;

const int RUSAGE_INFO_V4 = 4;

const int RUSAGE_INFO_V5 = 5;

const int RUSAGE_INFO_V6 = 6;

const int RUSAGE_INFO_CURRENT = 6;

const int RU_PROC_RUNS_RESLIDE = 1;

const int RLIM_INFINITY = 9223372036854775807;

const int RLIM_SAVED_MAX = 9223372036854775807;

const int RLIM_SAVED_CUR = 9223372036854775807;

const int RLIMIT_CPU = 0;

const int RLIMIT_FSIZE = 1;

const int RLIMIT_DATA = 2;

const int RLIMIT_STACK = 3;

const int RLIMIT_CORE = 4;

const int RLIMIT_AS = 5;

const int RLIMIT_RSS = 5;

const int RLIMIT_MEMLOCK = 6;

const int RLIMIT_NPROC = 7;

const int RLIMIT_NOFILE = 8;

const int RLIM_NLIMITS = 9;

const int _RLIMIT_POSIX_FLAG = 4096;

const int RLIMIT_WAKEUPS_MONITOR = 1;

const int RLIMIT_CPU_USAGE_MONITOR = 2;

const int RLIMIT_THREAD_CPULIMITS = 3;

const int RLIMIT_FOOTPRINT_INTERVAL = 4;

const int WAKEMON_ENABLE = 1;

const int WAKEMON_DISABLE = 2;

const int WAKEMON_GET_PARAMS = 4;

const int WAKEMON_SET_DEFAULTS = 8;

const int WAKEMON_MAKE_FATAL = 16;

const int CPUMON_MAKE_FATAL = 4096;

const int FOOTPRINT_INTERVAL_RESET = 1;

const int IOPOL_TYPE_DISK = 0;

const int IOPOL_TYPE_VFS_ATIME_UPDATES = 2;

const int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3;

const int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4;

const int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5;

const int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6;

const int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7;

const int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8;

const int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9;

const int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10;

const int IOPOL_SCOPE_PROCESS = 0;

const int IOPOL_SCOPE_THREAD = 1;

const int IOPOL_SCOPE_DARWIN_BG = 2;

const int IOPOL_DEFAULT = 0;

const int IOPOL_IMPORTANT = 1;

const int IOPOL_PASSIVE = 2;

const int IOPOL_THROTTLE = 3;

const int IOPOL_UTILITY = 4;

const int IOPOL_STANDARD = 5;

const int IOPOL_APPLICATION = 5;

const int IOPOL_NORMAL = 1;

const int IOPOL_ATIME_UPDATES_DEFAULT = 0;

const int IOPOL_ATIME_UPDATES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0;

const int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2;

const int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0;

const int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1;

const int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0;

const int IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1;

const int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0;

const int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1;

const int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0;

const int IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = 0;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WCOREFLAG = 128;

const int _WSTOPPED = 127;

const int WEXITED = 4;

const int WSTOPPED = 8;

const int WCONTINUED = 16;

const int WNOWAIT = 32;

const int WAIT_ANY = -1;

const int WAIT_MYPGRP = 0;

const int _QUAD_HIGHWORD = 1;

const int _QUAD_LOWWORD = 0;

const int __DARWIN_LITTLE_ENDIAN = 1234;

const int __DARWIN_BIG_ENDIAN = 4321;

const int __DARWIN_PDP_ENDIAN = 3412;

const int __DARWIN_BYTE_ORDER = 1234;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int RAND_MAX = 2147483647;
