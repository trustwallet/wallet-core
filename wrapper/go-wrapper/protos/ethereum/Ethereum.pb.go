// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.20.3
// source: Ethereum.proto

package ethereum

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	common "tw/protos/common"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Transaction type
type TransactionMode int32

const (
	// Legacy transaction, pre-EIP2718/EIP1559; for fee gasPrice/gasLimit is used
	TransactionMode_Legacy TransactionMode = 0
	// Enveloped transaction EIP2718 (with type 0x2), fee is according to EIP1559 (base fee, inclusion fee, ...)
	TransactionMode_Enveloped TransactionMode = 1
	// EIP4337-compatible UserOperation
	TransactionMode_UserOp TransactionMode = 2
	// EIP-7702 transaction (with type 0x4); allows to set the code of a contract for an EOA.
	// Note that `SetCode` transaction extends `Enveloped` transaction.
	// https://eips.ethereum.org/EIPS/eip-7702
	TransactionMode_SetCode TransactionMode = 4
)

// Enum value maps for TransactionMode.
var (
	TransactionMode_name = map[int32]string{
		0: "Legacy",
		1: "Enveloped",
		2: "UserOp",
		4: "SetCode",
	}
	TransactionMode_value = map[string]int32{
		"Legacy":    0,
		"Enveloped": 1,
		"UserOp":    2,
		"SetCode":   4,
	}
)

func (x TransactionMode) Enum() *TransactionMode {
	p := new(TransactionMode)
	*p = x
	return p
}

func (x TransactionMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TransactionMode) Descriptor() protoreflect.EnumDescriptor {
	return file_Ethereum_proto_enumTypes[0].Descriptor()
}

func (TransactionMode) Type() protoreflect.EnumType {
	return &file_Ethereum_proto_enumTypes[0]
}

func (x TransactionMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TransactionMode.Descriptor instead.
func (TransactionMode) EnumDescriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{0}
}

// Smart Contract Wallet type.
type SCWalletType int32

const (
	// ERC-4337 compatible smart contract wallet.
	// https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/accounts/SimpleAccount.sol
	SCWalletType_SimpleAccount SCWalletType = 0
	// Biz smart contract (Trust Wallet specific) through ERC-4337 EntryPoint.
	SCWalletType_Biz4337 SCWalletType = 1
	// Biz smart contract (Trust Wallet specific) directly through ERC-7702.
	SCWalletType_Biz SCWalletType = 2
)

// Enum value maps for SCWalletType.
var (
	SCWalletType_name = map[int32]string{
		0: "SimpleAccount",
		1: "Biz4337",
		2: "Biz",
	}
	SCWalletType_value = map[string]int32{
		"SimpleAccount": 0,
		"Biz4337":       1,
		"Biz":           2,
	}
)

func (x SCWalletType) Enum() *SCWalletType {
	p := new(SCWalletType)
	*p = x
	return p
}

func (x SCWalletType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SCWalletType) Descriptor() protoreflect.EnumDescriptor {
	return file_Ethereum_proto_enumTypes[1].Descriptor()
}

func (SCWalletType) Type() protoreflect.EnumType {
	return &file_Ethereum_proto_enumTypes[1]
}

func (x SCWalletType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SCWalletType.Descriptor instead.
func (SCWalletType) EnumDescriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{1}
}

type MessageType int32

const (
	// Sign a message following EIP-191.
	MessageType_MessageType_legacy MessageType = 0
	// Sign a message following EIP-191 with EIP-155 replay attack protection.
	MessageType_MessageType_eip155 MessageType = 1
	// Sign a typed message EIP-712 V4.
	MessageType_MessageType_typed MessageType = 2
	// Sign a typed message EIP-712 V4 with EIP-155 replay attack protection.
	MessageType_MessageType_typed_eip155 MessageType = 3
	// Sign a message with Immutable X msg type.
	MessageType_MessageType_immutable_x MessageType = 4
	// Sign a EIP-7702 authorization tuple.
	MessageType_MessageType_eip7702_authorization MessageType = 5
)

// Enum value maps for MessageType.
var (
	MessageType_name = map[int32]string{
		0: "MessageType_legacy",
		1: "MessageType_eip155",
		2: "MessageType_typed",
		3: "MessageType_typed_eip155",
		4: "MessageType_immutable_x",
		5: "MessageType_eip7702_authorization",
	}
	MessageType_value = map[string]int32{
		"MessageType_legacy":                0,
		"MessageType_eip155":                1,
		"MessageType_typed":                 2,
		"MessageType_typed_eip155":          3,
		"MessageType_immutable_x":           4,
		"MessageType_eip7702_authorization": 5,
	}
)

func (x MessageType) Enum() *MessageType {
	p := new(MessageType)
	*p = x
	return p
}

func (x MessageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MessageType) Descriptor() protoreflect.EnumDescriptor {
	return file_Ethereum_proto_enumTypes[2].Descriptor()
}

func (MessageType) Type() protoreflect.EnumType {
	return &file_Ethereum_proto_enumTypes[2]
}

func (x MessageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MessageType.Descriptor instead.
func (MessageType) EnumDescriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{2}
}

// Transaction (transfer, smart contract call, ...)
type Transaction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Payload transfer
	//
	// Types that are valid to be assigned to TransactionOneof:
	//
	//	*Transaction_Transfer_
	//	*Transaction_Erc20Transfer
	//	*Transaction_Erc20Approve
	//	*Transaction_Erc721Transfer
	//	*Transaction_Erc1155Transfer
	//	*Transaction_ContractGeneric_
	//	*Transaction_ScwBatch
	//	*Transaction_ScwExecute
	TransactionOneof isTransaction_TransactionOneof `protobuf_oneof:"transaction_oneof"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Transaction) Reset() {
	*x = Transaction{}
	mi := &file_Ethereum_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction) ProtoMessage() {}

func (x *Transaction) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction.ProtoReflect.Descriptor instead.
func (*Transaction) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{0}
}

func (x *Transaction) GetTransactionOneof() isTransaction_TransactionOneof {
	if x != nil {
		return x.TransactionOneof
	}
	return nil
}

func (x *Transaction) GetTransfer() *Transaction_Transfer {
	if x != nil {
		if x, ok := x.TransactionOneof.(*Transaction_Transfer_); ok {
			return x.Transfer
		}
	}
	return nil
}

func (x *Transaction) GetErc20Transfer() *Transaction_ERC20Transfer {
	if x != nil {
		if x, ok := x.TransactionOneof.(*Transaction_Erc20Transfer); ok {
			return x.Erc20Transfer
		}
	}
	return nil
}

func (x *Transaction) GetErc20Approve() *Transaction_ERC20Approve {
	if x != nil {
		if x, ok := x.TransactionOneof.(*Transaction_Erc20Approve); ok {
			return x.Erc20Approve
		}
	}
	return nil
}

func (x *Transaction) GetErc721Transfer() *Transaction_ERC721Transfer {
	if x != nil {
		if x, ok := x.TransactionOneof.(*Transaction_Erc721Transfer); ok {
			return x.Erc721Transfer
		}
	}
	return nil
}

func (x *Transaction) GetErc1155Transfer() *Transaction_ERC1155Transfer {
	if x != nil {
		if x, ok := x.TransactionOneof.(*Transaction_Erc1155Transfer); ok {
			return x.Erc1155Transfer
		}
	}
	return nil
}

func (x *Transaction) GetContractGeneric() *Transaction_ContractGeneric {
	if x != nil {
		if x, ok := x.TransactionOneof.(*Transaction_ContractGeneric_); ok {
			return x.ContractGeneric
		}
	}
	return nil
}

func (x *Transaction) GetScwBatch() *Transaction_SCWalletBatch {
	if x != nil {
		if x, ok := x.TransactionOneof.(*Transaction_ScwBatch); ok {
			return x.ScwBatch
		}
	}
	return nil
}

func (x *Transaction) GetScwExecute() *Transaction_SCWalletExecute {
	if x != nil {
		if x, ok := x.TransactionOneof.(*Transaction_ScwExecute); ok {
			return x.ScwExecute
		}
	}
	return nil
}

type isTransaction_TransactionOneof interface {
	isTransaction_TransactionOneof()
}

type Transaction_Transfer_ struct {
	Transfer *Transaction_Transfer `protobuf:"bytes,1,opt,name=transfer,proto3,oneof"`
}

type Transaction_Erc20Transfer struct {
	Erc20Transfer *Transaction_ERC20Transfer `protobuf:"bytes,2,opt,name=erc20_transfer,json=erc20Transfer,proto3,oneof"`
}

type Transaction_Erc20Approve struct {
	Erc20Approve *Transaction_ERC20Approve `protobuf:"bytes,3,opt,name=erc20_approve,json=erc20Approve,proto3,oneof"`
}

type Transaction_Erc721Transfer struct {
	Erc721Transfer *Transaction_ERC721Transfer `protobuf:"bytes,4,opt,name=erc721_transfer,json=erc721Transfer,proto3,oneof"`
}

type Transaction_Erc1155Transfer struct {
	Erc1155Transfer *Transaction_ERC1155Transfer `protobuf:"bytes,5,opt,name=erc1155_transfer,json=erc1155Transfer,proto3,oneof"`
}

type Transaction_ContractGeneric_ struct {
	ContractGeneric *Transaction_ContractGeneric `protobuf:"bytes,6,opt,name=contract_generic,json=contractGeneric,proto3,oneof"`
}

type Transaction_ScwBatch struct {
	// Batch transaction to a Smart Contract Wallet (ERC-4337 and ERC-7702).
	ScwBatch *Transaction_SCWalletBatch `protobuf:"bytes,7,opt,name=scw_batch,json=scwBatch,proto3,oneof"`
}

type Transaction_ScwExecute struct {
	// Execute transaction to a Smart Contract Wallet (ERC-4337 and ERC-7702).
	ScwExecute *Transaction_SCWalletExecute `protobuf:"bytes,8,opt,name=scw_execute,json=scwExecute,proto3,oneof"`
}

func (*Transaction_Transfer_) isTransaction_TransactionOneof() {}

func (*Transaction_Erc20Transfer) isTransaction_TransactionOneof() {}

func (*Transaction_Erc20Approve) isTransaction_TransactionOneof() {}

func (*Transaction_Erc721Transfer) isTransaction_TransactionOneof() {}

func (*Transaction_Erc1155Transfer) isTransaction_TransactionOneof() {}

func (*Transaction_ContractGeneric_) isTransaction_TransactionOneof() {}

func (*Transaction_ScwBatch) isTransaction_TransactionOneof() {}

func (*Transaction_ScwExecute) isTransaction_TransactionOneof() {}

// ERC-4337 structure that describes a transaction to be sent on behalf of a user
type UserOperation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Entry point contract address
	EntryPoint string `protobuf:"bytes,1,opt,name=entry_point,json=entryPoint,proto3" json:"entry_point,omitempty"`
	// Account factory contract address
	InitCode []byte `protobuf:"bytes,2,opt,name=init_code,json=initCode,proto3" json:"init_code,omitempty"`
	// Account logic contract address
	Sender string `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	// The amount of gas to pay for to compensate the bundler for pre-verification execution and calldata
	PreVerificationGas []byte `protobuf:"bytes,4,opt,name=pre_verification_gas,json=preVerificationGas,proto3" json:"pre_verification_gas,omitempty"`
	// The amount of gas to allocate for the verification step
	VerificationGasLimit []byte `protobuf:"bytes,5,opt,name=verification_gas_limit,json=verificationGasLimit,proto3" json:"verification_gas_limit,omitempty"`
	// Address of paymaster sponsoring the transaction, followed by extra data to send to the paymaster (empty for self-sponsored transaction)
	PaymasterAndData []byte `protobuf:"bytes,6,opt,name=paymaster_and_data,json=paymasterAndData,proto3" json:"paymaster_and_data,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *UserOperation) Reset() {
	*x = UserOperation{}
	mi := &file_Ethereum_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserOperation) ProtoMessage() {}

func (x *UserOperation) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserOperation.ProtoReflect.Descriptor instead.
func (*UserOperation) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{1}
}

func (x *UserOperation) GetEntryPoint() string {
	if x != nil {
		return x.EntryPoint
	}
	return ""
}

func (x *UserOperation) GetInitCode() []byte {
	if x != nil {
		return x.InitCode
	}
	return nil
}

func (x *UserOperation) GetSender() string {
	if x != nil {
		return x.Sender
	}
	return ""
}

func (x *UserOperation) GetPreVerificationGas() []byte {
	if x != nil {
		return x.PreVerificationGas
	}
	return nil
}

func (x *UserOperation) GetVerificationGasLimit() []byte {
	if x != nil {
		return x.VerificationGasLimit
	}
	return nil
}

func (x *UserOperation) GetPaymasterAndData() []byte {
	if x != nil {
		return x.PaymasterAndData
	}
	return nil
}

// EIP-7702 compatible ERC-4337 structure that describes a transaction to be sent on behalf of a user
type UserOperationV0_7 struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Entry point contract address
	EntryPoint string `protobuf:"bytes,1,opt,name=entry_point,json=entryPoint,proto3" json:"entry_point,omitempty"`
	// Account factory contract address
	Factory string `protobuf:"bytes,2,opt,name=factory,proto3" json:"factory,omitempty"`
	// Account factory data
	FactoryData []byte `protobuf:"bytes,3,opt,name=factory_data,json=factoryData,proto3" json:"factory_data,omitempty"`
	// Account logic contract address
	Sender string `protobuf:"bytes,4,opt,name=sender,proto3" json:"sender,omitempty"`
	// The amount of gas to pay for to compensate the bundler for pre-verification execution and calldata
	PreVerificationGas []byte `protobuf:"bytes,5,opt,name=pre_verification_gas,json=preVerificationGas,proto3" json:"pre_verification_gas,omitempty"`
	// The amount of gas to allocate for the verification step
	VerificationGasLimit []byte `protobuf:"bytes,6,opt,name=verification_gas_limit,json=verificationGasLimit,proto3" json:"verification_gas_limit,omitempty"`
	// Address of paymaster
	Paymaster string `protobuf:"bytes,7,opt,name=paymaster,proto3" json:"paymaster,omitempty"`
	// The amount of gas to allocate for the paymaster verification step
	PaymasterVerificationGasLimit []byte `protobuf:"bytes,8,opt,name=paymaster_verification_gas_limit,json=paymasterVerificationGasLimit,proto3" json:"paymaster_verification_gas_limit,omitempty"`
	// The amount of gas to allocate for paymaster post ops
	PaymasterPostOpGasLimit []byte `protobuf:"bytes,9,opt,name=paymaster_post_op_gas_limit,json=paymasterPostOpGasLimit,proto3" json:"paymaster_post_op_gas_limit,omitempty"`
	// Paymaster data
	PaymasterData []byte `protobuf:"bytes,10,opt,name=paymaster_data,json=paymasterData,proto3" json:"paymaster_data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserOperationV0_7) Reset() {
	*x = UserOperationV0_7{}
	mi := &file_Ethereum_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserOperationV0_7) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserOperationV0_7) ProtoMessage() {}

func (x *UserOperationV0_7) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserOperationV0_7.ProtoReflect.Descriptor instead.
func (*UserOperationV0_7) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{2}
}

func (x *UserOperationV0_7) GetEntryPoint() string {
	if x != nil {
		return x.EntryPoint
	}
	return ""
}

func (x *UserOperationV0_7) GetFactory() string {
	if x != nil {
		return x.Factory
	}
	return ""
}

func (x *UserOperationV0_7) GetFactoryData() []byte {
	if x != nil {
		return x.FactoryData
	}
	return nil
}

func (x *UserOperationV0_7) GetSender() string {
	if x != nil {
		return x.Sender
	}
	return ""
}

func (x *UserOperationV0_7) GetPreVerificationGas() []byte {
	if x != nil {
		return x.PreVerificationGas
	}
	return nil
}

func (x *UserOperationV0_7) GetVerificationGasLimit() []byte {
	if x != nil {
		return x.VerificationGasLimit
	}
	return nil
}

func (x *UserOperationV0_7) GetPaymaster() string {
	if x != nil {
		return x.Paymaster
	}
	return ""
}

func (x *UserOperationV0_7) GetPaymasterVerificationGasLimit() []byte {
	if x != nil {
		return x.PaymasterVerificationGasLimit
	}
	return nil
}

func (x *UserOperationV0_7) GetPaymasterPostOpGasLimit() []byte {
	if x != nil {
		return x.PaymasterPostOpGasLimit
	}
	return nil
}

func (x *UserOperationV0_7) GetPaymasterData() []byte {
	if x != nil {
		return x.PaymasterData
	}
	return nil
}

// An item of the [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) access list.
type Access struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Address to be accessed by the transaction.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Storage keys to be accessed by the transaction.
	StoredKeys    [][]byte `protobuf:"bytes,2,rep,name=stored_keys,json=storedKeys,proto3" json:"stored_keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Access) Reset() {
	*x = Access{}
	mi := &file_Ethereum_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Access) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Access) ProtoMessage() {}

func (x *Access) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Access.ProtoReflect.Descriptor instead.
func (*Access) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{3}
}

func (x *Access) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Access) GetStoredKeys() [][]byte {
	if x != nil {
		return x.StoredKeys
	}
	return nil
}

// [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) authorization.
type Authorization struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Address to be authorized, a smart contract address.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// If custom_signature isn't provided, the authorization will be signed with the provided private key, nonce and chainId
	CustomSignature *AuthorizationCustomSignature `protobuf:"bytes,3,opt,name=custom_signature,json=customSignature,proto3" json:"custom_signature,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Authorization) Reset() {
	*x = Authorization{}
	mi := &file_Ethereum_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Authorization) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Authorization) ProtoMessage() {}

func (x *Authorization) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Authorization.ProtoReflect.Descriptor instead.
func (*Authorization) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{4}
}

func (x *Authorization) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Authorization) GetCustomSignature() *AuthorizationCustomSignature {
	if x != nil {
		return x.CustomSignature
	}
	return nil
}

// [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) authorization.
type AuthorizationCustomSignature struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain id (uint256, serialized big endian).
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Nonce, the nonce of authority.
	Nonce []byte `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// The signature, Hex-encoded.
	Signature     string `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthorizationCustomSignature) Reset() {
	*x = AuthorizationCustomSignature{}
	mi := &file_Ethereum_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthorizationCustomSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthorizationCustomSignature) ProtoMessage() {}

func (x *AuthorizationCustomSignature) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthorizationCustomSignature.ProtoReflect.Descriptor instead.
func (*AuthorizationCustomSignature) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{5}
}

func (x *AuthorizationCustomSignature) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *AuthorizationCustomSignature) GetNonce() []byte {
	if x != nil {
		return x.Nonce
	}
	return nil
}

func (x *AuthorizationCustomSignature) GetSignature() string {
	if x != nil {
		return x.Signature
	}
	return ""
}

// Input data necessary to create a signed transaction.
// Legacy and EIP2718/EIP1559 transactions supported, see TransactionMode.
type SigningInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain identifier (uint256, serialized big endian)
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Nonce (uint256, serialized big endian)
	Nonce []byte `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Transaction version selector: Legacy or enveloped, has impact on fee structure.
	// Default is Legacy (value 0)
	TxMode TransactionMode `protobuf:"varint,3,opt,name=tx_mode,json=txMode,proto3,enum=TW.Ethereum.Proto.TransactionMode" json:"tx_mode,omitempty"`
	// Gas price (uint256, serialized big endian)
	// Relevant for legacy transactions only (disregarded for enveloped/EIP1559)
	GasPrice []byte `protobuf:"bytes,4,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	// Gas limit (uint256, serialized big endian)
	GasLimit []byte `protobuf:"bytes,5,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	// Maximum optional inclusion fee (aka tip) (uint256, serialized big endian)
	// Relevant for enveloped/EIP1559 transactions only, tx_mode=Enveloped, (disregarded for legacy)
	MaxInclusionFeePerGas []byte `protobuf:"bytes,6,opt,name=max_inclusion_fee_per_gas,json=maxInclusionFeePerGas,proto3" json:"max_inclusion_fee_per_gas,omitempty"`
	// Maximum fee (uint256, serialized big endian)
	// Relevant for enveloped/EIP1559 transactions only, tx_mode=Enveloped, (disregarded for legacy)
	MaxFeePerGas []byte `protobuf:"bytes,7,opt,name=max_fee_per_gas,json=maxFeePerGas,proto3" json:"max_fee_per_gas,omitempty"`
	// Recipient's address.
	// TODO currently, will be moved to each `Transaction` oneof soon.
	ToAddress string `protobuf:"bytes,8,opt,name=to_address,json=toAddress,proto3" json:"to_address,omitempty"`
	// The secret private key used for signing (32 bytes).
	PrivateKey []byte `protobuf:"bytes,9,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// The payload transaction
	Transaction *Transaction `protobuf:"bytes,10,opt,name=transaction,proto3" json:"transaction,omitempty"`
	// UserOperation for ERC-4337 wallets
	//
	// Types that are valid to be assigned to UserOperationOneof:
	//
	//	*SigningInput_UserOperation
	//	*SigningInput_UserOperationV0_7
	UserOperationOneof isSigningInput_UserOperationOneof `protobuf_oneof:"user_operation_oneof"`
	// Optional list of addresses and storage keys that the transaction plans to access.
	// Used in `TransactionMode::Enveloped` only.
	AccessList []*Access `protobuf:"bytes,12,rep,name=access_list,json=accessList,proto3" json:"access_list,omitempty"`
	// EIP7702 authorization.
	// Used in `TransactionMode::SetOp` or `TransactionMode::UserOp`.
	// Currently, we support delegation to only one authority at a time.
	Eip7702Authorization *Authorization `protobuf:"bytes,15,opt,name=eip7702_authorization,json=eip7702Authorization,proto3" json:"eip7702_authorization,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *SigningInput) Reset() {
	*x = SigningInput{}
	mi := &file_Ethereum_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningInput) ProtoMessage() {}

func (x *SigningInput) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningInput.ProtoReflect.Descriptor instead.
func (*SigningInput) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{6}
}

func (x *SigningInput) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *SigningInput) GetNonce() []byte {
	if x != nil {
		return x.Nonce
	}
	return nil
}

func (x *SigningInput) GetTxMode() TransactionMode {
	if x != nil {
		return x.TxMode
	}
	return TransactionMode_Legacy
}

func (x *SigningInput) GetGasPrice() []byte {
	if x != nil {
		return x.GasPrice
	}
	return nil
}

func (x *SigningInput) GetGasLimit() []byte {
	if x != nil {
		return x.GasLimit
	}
	return nil
}

func (x *SigningInput) GetMaxInclusionFeePerGas() []byte {
	if x != nil {
		return x.MaxInclusionFeePerGas
	}
	return nil
}

func (x *SigningInput) GetMaxFeePerGas() []byte {
	if x != nil {
		return x.MaxFeePerGas
	}
	return nil
}

func (x *SigningInput) GetToAddress() string {
	if x != nil {
		return x.ToAddress
	}
	return ""
}

func (x *SigningInput) GetPrivateKey() []byte {
	if x != nil {
		return x.PrivateKey
	}
	return nil
}

func (x *SigningInput) GetTransaction() *Transaction {
	if x != nil {
		return x.Transaction
	}
	return nil
}

func (x *SigningInput) GetUserOperationOneof() isSigningInput_UserOperationOneof {
	if x != nil {
		return x.UserOperationOneof
	}
	return nil
}

func (x *SigningInput) GetUserOperation() *UserOperation {
	if x != nil {
		if x, ok := x.UserOperationOneof.(*SigningInput_UserOperation); ok {
			return x.UserOperation
		}
	}
	return nil
}

func (x *SigningInput) GetUserOperationV0_7() *UserOperationV0_7 {
	if x != nil {
		if x, ok := x.UserOperationOneof.(*SigningInput_UserOperationV0_7); ok {
			return x.UserOperationV0_7
		}
	}
	return nil
}

func (x *SigningInput) GetAccessList() []*Access {
	if x != nil {
		return x.AccessList
	}
	return nil
}

func (x *SigningInput) GetEip7702Authorization() *Authorization {
	if x != nil {
		return x.Eip7702Authorization
	}
	return nil
}

type isSigningInput_UserOperationOneof interface {
	isSigningInput_UserOperationOneof()
}

type SigningInput_UserOperation struct {
	UserOperation *UserOperation `protobuf:"bytes,11,opt,name=user_operation,json=userOperation,proto3,oneof"`
}

type SigningInput_UserOperationV0_7 struct {
	// EIP-7702 compatible
	UserOperationV0_7 *UserOperationV0_7 `protobuf:"bytes,13,opt,name=user_operation_v0_7,json=userOperationV07,proto3,oneof"`
}

func (*SigningInput_UserOperation) isSigningInput_UserOperationOneof() {}

func (*SigningInput_UserOperationV0_7) isSigningInput_UserOperationOneof() {}

// Result containing the signed and encoded transaction.
type SigningOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Signed and encoded transaction bytes.
	Encoded []byte `protobuf:"bytes,1,opt,name=encoded,proto3" json:"encoded,omitempty"`
	// The V, R, S components of the resulting signature, (each uint256, serialized big endian)
	V []byte `protobuf:"bytes,2,opt,name=v,proto3" json:"v,omitempty"`
	R []byte `protobuf:"bytes,3,opt,name=r,proto3" json:"r,omitempty"`
	S []byte `protobuf:"bytes,4,opt,name=s,proto3" json:"s,omitempty"`
	// The payload part, supplied in the input or assembled from input parameters
	Data []byte `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	// error code, 0 is ok, other codes will be treated as errors
	Error common.SigningError `protobuf:"varint,6,opt,name=error,proto3,enum=TW.Common.Proto.SigningError" json:"error,omitempty"`
	// error code description
	ErrorMessage string `protobuf:"bytes,7,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Encoded transaction bytes.
	PreHash       []byte `protobuf:"bytes,8,opt,name=pre_hash,json=preHash,proto3" json:"pre_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SigningOutput) Reset() {
	*x = SigningOutput{}
	mi := &file_Ethereum_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningOutput) ProtoMessage() {}

func (x *SigningOutput) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningOutput.ProtoReflect.Descriptor instead.
func (*SigningOutput) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{7}
}

func (x *SigningOutput) GetEncoded() []byte {
	if x != nil {
		return x.Encoded
	}
	return nil
}

func (x *SigningOutput) GetV() []byte {
	if x != nil {
		return x.V
	}
	return nil
}

func (x *SigningOutput) GetR() []byte {
	if x != nil {
		return x.R
	}
	return nil
}

func (x *SigningOutput) GetS() []byte {
	if x != nil {
		return x.S
	}
	return nil
}

func (x *SigningOutput) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *SigningOutput) GetError() common.SigningError {
	if x != nil {
		return x.Error
	}
	return common.SigningError(0)
}

func (x *SigningOutput) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *SigningOutput) GetPreHash() []byte {
	if x != nil {
		return x.PreHash
	}
	return nil
}

type MaybeChainId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain ID.
	ChainId       uint64 `protobuf:"varint,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MaybeChainId) Reset() {
	*x = MaybeChainId{}
	mi := &file_Ethereum_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MaybeChainId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MaybeChainId) ProtoMessage() {}

func (x *MaybeChainId) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MaybeChainId.ProtoReflect.Descriptor instead.
func (*MaybeChainId) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{8}
}

func (x *MaybeChainId) GetChainId() uint64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

type MessageSigningInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The secret private key used for signing (32 bytes).
	PrivateKey []byte `protobuf:"bytes,1,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// Message to sign. Either a regular message or a typed data structured message in JSON format.
	// Message type should be declared at `message_type`.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// Optional. Used in replay protection and to check Typed Structured Data input.
	// Eg. should be set if `message_type` is `MessageType_eip155`, or MessageType_typed, or `MessageType_typed_eip155`.
	ChainId *MaybeChainId `protobuf:"bytes,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Message type.
	MessageType   MessageType `protobuf:"varint,4,opt,name=message_type,json=messageType,proto3,enum=TW.Ethereum.Proto.MessageType" json:"message_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MessageSigningInput) Reset() {
	*x = MessageSigningInput{}
	mi := &file_Ethereum_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MessageSigningInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageSigningInput) ProtoMessage() {}

func (x *MessageSigningInput) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MessageSigningInput.ProtoReflect.Descriptor instead.
func (*MessageSigningInput) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{9}
}

func (x *MessageSigningInput) GetPrivateKey() []byte {
	if x != nil {
		return x.PrivateKey
	}
	return nil
}

func (x *MessageSigningInput) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *MessageSigningInput) GetChainId() *MaybeChainId {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *MessageSigningInput) GetMessageType() MessageType {
	if x != nil {
		return x.MessageType
	}
	return MessageType_MessageType_legacy
}

type MessageSigningOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signature, Hex-encoded.
	Signature string `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	// error code, 0 is ok, other codes will be treated as errors
	Error common.SigningError `protobuf:"varint,2,opt,name=error,proto3,enum=TW.Common.Proto.SigningError" json:"error,omitempty"`
	// error code description
	ErrorMessage  string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MessageSigningOutput) Reset() {
	*x = MessageSigningOutput{}
	mi := &file_Ethereum_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MessageSigningOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageSigningOutput) ProtoMessage() {}

func (x *MessageSigningOutput) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MessageSigningOutput.ProtoReflect.Descriptor instead.
func (*MessageSigningOutput) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{10}
}

func (x *MessageSigningOutput) GetSignature() string {
	if x != nil {
		return x.Signature
	}
	return ""
}

func (x *MessageSigningOutput) GetError() common.SigningError {
	if x != nil {
		return x.Error
	}
	return common.SigningError(0)
}

func (x *MessageSigningOutput) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

type MessageVerifyingInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The message signed.
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// Public key that will verify and recover the message from the signature.
	PublicKey []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// The signature, Hex-encoded.
	Signature     string `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MessageVerifyingInput) Reset() {
	*x = MessageVerifyingInput{}
	mi := &file_Ethereum_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MessageVerifyingInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageVerifyingInput) ProtoMessage() {}

func (x *MessageVerifyingInput) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MessageVerifyingInput.ProtoReflect.Descriptor instead.
func (*MessageVerifyingInput) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{11}
}

func (x *MessageVerifyingInput) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *MessageVerifyingInput) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *MessageVerifyingInput) GetSignature() string {
	if x != nil {
		return x.Signature
	}
	return ""
}

// Native coin transfer transaction
type Transaction_Transfer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Amount to send in wei (uint256, serialized big endian)
	Amount []byte `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount,omitempty"`
	// Optional payload data
	Data          []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transaction_Transfer) Reset() {
	*x = Transaction_Transfer{}
	mi := &file_Ethereum_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction_Transfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction_Transfer) ProtoMessage() {}

func (x *Transaction_Transfer) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction_Transfer.ProtoReflect.Descriptor instead.
func (*Transaction_Transfer) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{0, 0}
}

func (x *Transaction_Transfer) GetAmount() []byte {
	if x != nil {
		return x.Amount
	}
	return nil
}

func (x *Transaction_Transfer) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// ERC20 token transfer transaction
type Transaction_ERC20Transfer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// destination address (string)
	To string `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	// Amount to send (uint256, serialized big endian)
	Amount        []byte `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transaction_ERC20Transfer) Reset() {
	*x = Transaction_ERC20Transfer{}
	mi := &file_Ethereum_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction_ERC20Transfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction_ERC20Transfer) ProtoMessage() {}

func (x *Transaction_ERC20Transfer) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction_ERC20Transfer.ProtoReflect.Descriptor instead.
func (*Transaction_ERC20Transfer) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{0, 1}
}

func (x *Transaction_ERC20Transfer) GetTo() string {
	if x != nil {
		return x.To
	}
	return ""
}

func (x *Transaction_ERC20Transfer) GetAmount() []byte {
	if x != nil {
		return x.Amount
	}
	return nil
}

// ERC20 approve transaction
type Transaction_ERC20Approve struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Target of the approval
	Spender string `protobuf:"bytes,1,opt,name=spender,proto3" json:"spender,omitempty"`
	// Amount to send (uint256, serialized big endian)
	Amount        []byte `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transaction_ERC20Approve) Reset() {
	*x = Transaction_ERC20Approve{}
	mi := &file_Ethereum_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction_ERC20Approve) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction_ERC20Approve) ProtoMessage() {}

func (x *Transaction_ERC20Approve) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction_ERC20Approve.ProtoReflect.Descriptor instead.
func (*Transaction_ERC20Approve) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{0, 2}
}

func (x *Transaction_ERC20Approve) GetSpender() string {
	if x != nil {
		return x.Spender
	}
	return ""
}

func (x *Transaction_ERC20Approve) GetAmount() []byte {
	if x != nil {
		return x.Amount
	}
	return nil
}

// ERC721 NFT transfer transaction
type Transaction_ERC721Transfer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source address
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// Destination address
	To string `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	// ID of the token (uint256, serialized big endian)
	TokenId       []byte `protobuf:"bytes,3,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transaction_ERC721Transfer) Reset() {
	*x = Transaction_ERC721Transfer{}
	mi := &file_Ethereum_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction_ERC721Transfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction_ERC721Transfer) ProtoMessage() {}

func (x *Transaction_ERC721Transfer) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction_ERC721Transfer.ProtoReflect.Descriptor instead.
func (*Transaction_ERC721Transfer) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{0, 3}
}

func (x *Transaction_ERC721Transfer) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *Transaction_ERC721Transfer) GetTo() string {
	if x != nil {
		return x.To
	}
	return ""
}

func (x *Transaction_ERC721Transfer) GetTokenId() []byte {
	if x != nil {
		return x.TokenId
	}
	return nil
}

// ERC1155 NFT transfer transaction
type Transaction_ERC1155Transfer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source address
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// Destination address
	To string `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	// ID of the token (uint256, serialized big endian)
	TokenId []byte `protobuf:"bytes,3,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	// The amount of tokens being transferred (uint256, serialized big endian)
	Value         []byte `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	Data          []byte `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transaction_ERC1155Transfer) Reset() {
	*x = Transaction_ERC1155Transfer{}
	mi := &file_Ethereum_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction_ERC1155Transfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction_ERC1155Transfer) ProtoMessage() {}

func (x *Transaction_ERC1155Transfer) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction_ERC1155Transfer.ProtoReflect.Descriptor instead.
func (*Transaction_ERC1155Transfer) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{0, 4}
}

func (x *Transaction_ERC1155Transfer) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *Transaction_ERC1155Transfer) GetTo() string {
	if x != nil {
		return x.To
	}
	return ""
}

func (x *Transaction_ERC1155Transfer) GetTokenId() []byte {
	if x != nil {
		return x.TokenId
	}
	return nil
}

func (x *Transaction_ERC1155Transfer) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *Transaction_ERC1155Transfer) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// Generic smart contract transaction
type Transaction_ContractGeneric struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Amount to send in wei (uint256, serialized big endian)
	Amount []byte `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount,omitempty"`
	// Contract call payload data
	Data          []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transaction_ContractGeneric) Reset() {
	*x = Transaction_ContractGeneric{}
	mi := &file_Ethereum_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction_ContractGeneric) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction_ContractGeneric) ProtoMessage() {}

func (x *Transaction_ContractGeneric) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction_ContractGeneric.ProtoReflect.Descriptor instead.
func (*Transaction_ContractGeneric) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{0, 5}
}

func (x *Transaction_ContractGeneric) GetAmount() []byte {
	if x != nil {
		return x.Amount
	}
	return nil
}

func (x *Transaction_ContractGeneric) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// Batch transaction to a Smart Contract Wallet (ERC-4337 and ERC-7702).
type Transaction_SCWalletBatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batched calls to be executed on the smart contract wallet.
	Calls []*Transaction_SCWalletBatch_BatchedCall `protobuf:"bytes,1,rep,name=calls,proto3" json:"calls,omitempty"`
	// Smart contract wallet type.
	WalletType    SCWalletType `protobuf:"varint,2,opt,name=wallet_type,json=walletType,proto3,enum=TW.Ethereum.Proto.SCWalletType" json:"wallet_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transaction_SCWalletBatch) Reset() {
	*x = Transaction_SCWalletBatch{}
	mi := &file_Ethereum_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction_SCWalletBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction_SCWalletBatch) ProtoMessage() {}

func (x *Transaction_SCWalletBatch) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction_SCWalletBatch.ProtoReflect.Descriptor instead.
func (*Transaction_SCWalletBatch) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{0, 6}
}

func (x *Transaction_SCWalletBatch) GetCalls() []*Transaction_SCWalletBatch_BatchedCall {
	if x != nil {
		return x.Calls
	}
	return nil
}

func (x *Transaction_SCWalletBatch) GetWalletType() SCWalletType {
	if x != nil {
		return x.WalletType
	}
	return SCWalletType_SimpleAccount
}

// Execute transaction to a Smart Contract Wallet (ERC-4337 and ERC-7702).
type Transaction_SCWalletExecute struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Transaction to be executed on the smart contract wallet.
	// TODO currently, smart contract wallet address is specified in `SigningInput.toAddress`, but it will be refactored soon.
	Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
	// Smart contract wallet type.
	WalletType    SCWalletType `protobuf:"varint,2,opt,name=wallet_type,json=walletType,proto3,enum=TW.Ethereum.Proto.SCWalletType" json:"wallet_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transaction_SCWalletExecute) Reset() {
	*x = Transaction_SCWalletExecute{}
	mi := &file_Ethereum_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction_SCWalletExecute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction_SCWalletExecute) ProtoMessage() {}

func (x *Transaction_SCWalletExecute) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction_SCWalletExecute.ProtoReflect.Descriptor instead.
func (*Transaction_SCWalletExecute) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{0, 7}
}

func (x *Transaction_SCWalletExecute) GetTransaction() *Transaction {
	if x != nil {
		return x.Transaction
	}
	return nil
}

func (x *Transaction_SCWalletExecute) GetWalletType() SCWalletType {
	if x != nil {
		return x.WalletType
	}
	return SCWalletType_SimpleAccount
}

type Transaction_SCWalletBatch_BatchedCall struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Recipient addresses.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Amounts to send in wei (uint256, serialized big endian)
	Amount []byte `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	// Contract call payloads data
	Payload       []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transaction_SCWalletBatch_BatchedCall) Reset() {
	*x = Transaction_SCWalletBatch_BatchedCall{}
	mi := &file_Ethereum_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transaction_SCWalletBatch_BatchedCall) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transaction_SCWalletBatch_BatchedCall) ProtoMessage() {}

func (x *Transaction_SCWalletBatch_BatchedCall) ProtoReflect() protoreflect.Message {
	mi := &file_Ethereum_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transaction_SCWalletBatch_BatchedCall.ProtoReflect.Descriptor instead.
func (*Transaction_SCWalletBatch_BatchedCall) Descriptor() ([]byte, []int) {
	return file_Ethereum_proto_rawDescGZIP(), []int{0, 6, 0}
}

func (x *Transaction_SCWalletBatch_BatchedCall) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Transaction_SCWalletBatch_BatchedCall) GetAmount() []byte {
	if x != nil {
		return x.Amount
	}
	return nil
}

func (x *Transaction_SCWalletBatch_BatchedCall) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

var File_Ethereum_proto protoreflect.FileDescriptor

const file_Ethereum_proto_rawDesc = "" +
	"\n" +
	"\x0eEthereum.proto\x12\x11TW.Ethereum.Proto\x1a\fCommon.proto\"\x9e\f\n" +
	"\vTransaction\x12E\n" +
	"\btransfer\x18\x01 \x01(\v2'.TW.Ethereum.Proto.Transaction.TransferH\x00R\btransfer\x12U\n" +
	"\x0eerc20_transfer\x18\x02 \x01(\v2,.TW.Ethereum.Proto.Transaction.ERC20TransferH\x00R\rerc20Transfer\x12R\n" +
	"\rerc20_approve\x18\x03 \x01(\v2+.TW.Ethereum.Proto.Transaction.ERC20ApproveH\x00R\ferc20Approve\x12X\n" +
	"\x0ferc721_transfer\x18\x04 \x01(\v2-.TW.Ethereum.Proto.Transaction.ERC721TransferH\x00R\x0eerc721Transfer\x12[\n" +
	"\x10erc1155_transfer\x18\x05 \x01(\v2..TW.Ethereum.Proto.Transaction.ERC1155TransferH\x00R\x0ferc1155Transfer\x12[\n" +
	"\x10contract_generic\x18\x06 \x01(\v2..TW.Ethereum.Proto.Transaction.ContractGenericH\x00R\x0fcontractGeneric\x12K\n" +
	"\tscw_batch\x18\a \x01(\v2,.TW.Ethereum.Proto.Transaction.SCWalletBatchH\x00R\bscwBatch\x12Q\n" +
	"\vscw_execute\x18\b \x01(\v2..TW.Ethereum.Proto.Transaction.SCWalletExecuteH\x00R\n" +
	"scwExecute\x1a6\n" +
	"\bTransfer\x12\x16\n" +
	"\x06amount\x18\x01 \x01(\fR\x06amount\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\x1a7\n" +
	"\rERC20Transfer\x12\x0e\n" +
	"\x02to\x18\x01 \x01(\tR\x02to\x12\x16\n" +
	"\x06amount\x18\x02 \x01(\fR\x06amount\x1a@\n" +
	"\fERC20Approve\x12\x18\n" +
	"\aspender\x18\x01 \x01(\tR\aspender\x12\x16\n" +
	"\x06amount\x18\x02 \x01(\fR\x06amount\x1aO\n" +
	"\x0eERC721Transfer\x12\x12\n" +
	"\x04from\x18\x01 \x01(\tR\x04from\x12\x0e\n" +
	"\x02to\x18\x02 \x01(\tR\x02to\x12\x19\n" +
	"\btoken_id\x18\x03 \x01(\fR\atokenId\x1az\n" +
	"\x0fERC1155Transfer\x12\x12\n" +
	"\x04from\x18\x01 \x01(\tR\x04from\x12\x0e\n" +
	"\x02to\x18\x02 \x01(\tR\x02to\x12\x19\n" +
	"\btoken_id\x18\x03 \x01(\fR\atokenId\x12\x14\n" +
	"\x05value\x18\x04 \x01(\fR\x05value\x12\x12\n" +
	"\x04data\x18\x05 \x01(\fR\x04data\x1a=\n" +
	"\x0fContractGeneric\x12\x16\n" +
	"\x06amount\x18\x01 \x01(\fR\x06amount\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\x1a\xfc\x01\n" +
	"\rSCWalletBatch\x12N\n" +
	"\x05calls\x18\x01 \x03(\v28.TW.Ethereum.Proto.Transaction.SCWalletBatch.BatchedCallR\x05calls\x12@\n" +
	"\vwallet_type\x18\x02 \x01(\x0e2\x1f.TW.Ethereum.Proto.SCWalletTypeR\n" +
	"walletType\x1aY\n" +
	"\vBatchedCall\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12\x16\n" +
	"\x06amount\x18\x02 \x01(\fR\x06amount\x12\x18\n" +
	"\apayload\x18\x03 \x01(\fR\apayload\x1a\x95\x01\n" +
	"\x0fSCWalletExecute\x12@\n" +
	"\vtransaction\x18\x01 \x01(\v2\x1e.TW.Ethereum.Proto.TransactionR\vtransaction\x12@\n" +
	"\vwallet_type\x18\x02 \x01(\x0e2\x1f.TW.Ethereum.Proto.SCWalletTypeR\n" +
	"walletTypeB\x13\n" +
	"\x11transaction_oneof\"\xfb\x01\n" +
	"\rUserOperation\x12\x1f\n" +
	"\ventry_point\x18\x01 \x01(\tR\n" +
	"entryPoint\x12\x1b\n" +
	"\tinit_code\x18\x02 \x01(\fR\binitCode\x12\x16\n" +
	"\x06sender\x18\x03 \x01(\tR\x06sender\x120\n" +
	"\x14pre_verification_gas\x18\x04 \x01(\fR\x12preVerificationGas\x124\n" +
	"\x16verification_gas_limit\x18\x05 \x01(\fR\x14verificationGasLimit\x12,\n" +
	"\x12paymaster_and_data\x18\x06 \x01(\fR\x10paymasterAndData\"\xbd\x03\n" +
	"\x11UserOperationV0_7\x12\x1f\n" +
	"\ventry_point\x18\x01 \x01(\tR\n" +
	"entryPoint\x12\x18\n" +
	"\afactory\x18\x02 \x01(\tR\afactory\x12!\n" +
	"\ffactory_data\x18\x03 \x01(\fR\vfactoryData\x12\x16\n" +
	"\x06sender\x18\x04 \x01(\tR\x06sender\x120\n" +
	"\x14pre_verification_gas\x18\x05 \x01(\fR\x12preVerificationGas\x124\n" +
	"\x16verification_gas_limit\x18\x06 \x01(\fR\x14verificationGasLimit\x12\x1c\n" +
	"\tpaymaster\x18\a \x01(\tR\tpaymaster\x12G\n" +
	" paymaster_verification_gas_limit\x18\b \x01(\fR\x1dpaymasterVerificationGasLimit\x12<\n" +
	"\x1bpaymaster_post_op_gas_limit\x18\t \x01(\fR\x17paymasterPostOpGasLimit\x12%\n" +
	"\x0epaymaster_data\x18\n" +
	" \x01(\fR\rpaymasterData\"C\n" +
	"\x06Access\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12\x1f\n" +
	"\vstored_keys\x18\x02 \x03(\fR\n" +
	"storedKeys\"\x85\x01\n" +
	"\rAuthorization\x12\x18\n" +
	"\aaddress\x18\x02 \x01(\tR\aaddress\x12Z\n" +
	"\x10custom_signature\x18\x03 \x01(\v2/.TW.Ethereum.Proto.AuthorizationCustomSignatureR\x0fcustomSignature\"m\n" +
	"\x1cAuthorizationCustomSignature\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x14\n" +
	"\x05nonce\x18\x02 \x01(\fR\x05nonce\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\tR\tsignature\"\xe6\x05\n" +
	"\fSigningInput\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x14\n" +
	"\x05nonce\x18\x02 \x01(\fR\x05nonce\x12;\n" +
	"\atx_mode\x18\x03 \x01(\x0e2\".TW.Ethereum.Proto.TransactionModeR\x06txMode\x12\x1b\n" +
	"\tgas_price\x18\x04 \x01(\fR\bgasPrice\x12\x1b\n" +
	"\tgas_limit\x18\x05 \x01(\fR\bgasLimit\x128\n" +
	"\x19max_inclusion_fee_per_gas\x18\x06 \x01(\fR\x15maxInclusionFeePerGas\x12%\n" +
	"\x0fmax_fee_per_gas\x18\a \x01(\fR\fmaxFeePerGas\x12\x1d\n" +
	"\n" +
	"to_address\x18\b \x01(\tR\ttoAddress\x12\x1f\n" +
	"\vprivate_key\x18\t \x01(\fR\n" +
	"privateKey\x12@\n" +
	"\vtransaction\x18\n" +
	" \x01(\v2\x1e.TW.Ethereum.Proto.TransactionR\vtransaction\x12I\n" +
	"\x0euser_operation\x18\v \x01(\v2 .TW.Ethereum.Proto.UserOperationH\x00R\ruserOperation\x12U\n" +
	"\x13user_operation_v0_7\x18\r \x01(\v2$.TW.Ethereum.Proto.UserOperationV0_7H\x00R\x10userOperationV07\x12:\n" +
	"\vaccess_list\x18\f \x03(\v2\x19.TW.Ethereum.Proto.AccessR\n" +
	"accessList\x12U\n" +
	"\x15eip7702_authorization\x18\x0f \x01(\v2 .TW.Ethereum.Proto.AuthorizationR\x14eip7702AuthorizationB\x16\n" +
	"\x14user_operation_oneof\"\xdc\x01\n" +
	"\rSigningOutput\x12\x18\n" +
	"\aencoded\x18\x01 \x01(\fR\aencoded\x12\f\n" +
	"\x01v\x18\x02 \x01(\fR\x01v\x12\f\n" +
	"\x01r\x18\x03 \x01(\fR\x01r\x12\f\n" +
	"\x01s\x18\x04 \x01(\fR\x01s\x12\x12\n" +
	"\x04data\x18\x05 \x01(\fR\x04data\x123\n" +
	"\x05error\x18\x06 \x01(\x0e2\x1d.TW.Common.Proto.SigningErrorR\x05error\x12#\n" +
	"\rerror_message\x18\a \x01(\tR\ferrorMessage\x12\x19\n" +
	"\bpre_hash\x18\b \x01(\fR\apreHash\")\n" +
	"\fMaybeChainId\x12\x19\n" +
	"\bchain_id\x18\x03 \x01(\x04R\achainId\"\xcf\x01\n" +
	"\x13MessageSigningInput\x12\x1f\n" +
	"\vprivate_key\x18\x01 \x01(\fR\n" +
	"privateKey\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12:\n" +
	"\bchain_id\x18\x03 \x01(\v2\x1f.TW.Ethereum.Proto.MaybeChainIdR\achainId\x12A\n" +
	"\fmessage_type\x18\x04 \x01(\x0e2\x1e.TW.Ethereum.Proto.MessageTypeR\vmessageType\"\x8e\x01\n" +
	"\x14MessageSigningOutput\x12\x1c\n" +
	"\tsignature\x18\x01 \x01(\tR\tsignature\x123\n" +
	"\x05error\x18\x02 \x01(\x0e2\x1d.TW.Common.Proto.SigningErrorR\x05error\x12#\n" +
	"\rerror_message\x18\x03 \x01(\tR\ferrorMessage\"n\n" +
	"\x15MessageVerifyingInput\x12\x18\n" +
	"\amessage\x18\x01 \x01(\tR\amessage\x12\x1d\n" +
	"\n" +
	"public_key\x18\x02 \x01(\fR\tpublicKey\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\tR\tsignature*E\n" +
	"\x0fTransactionMode\x12\n" +
	"\n" +
	"\x06Legacy\x10\x00\x12\r\n" +
	"\tEnveloped\x10\x01\x12\n" +
	"\n" +
	"\x06UserOp\x10\x02\x12\v\n" +
	"\aSetCode\x10\x04*7\n" +
	"\fSCWalletType\x12\x11\n" +
	"\rSimpleAccount\x10\x00\x12\v\n" +
	"\aBiz4337\x10\x01\x12\a\n" +
	"\x03Biz\x10\x02*\xb6\x01\n" +
	"\vMessageType\x12\x16\n" +
	"\x12MessageType_legacy\x10\x00\x12\x16\n" +
	"\x12MessageType_eip155\x10\x01\x12\x15\n" +
	"\x11MessageType_typed\x10\x02\x12\x1c\n" +
	"\x18MessageType_typed_eip155\x10\x03\x12\x1b\n" +
	"\x17MessageType_immutable_x\x10\x04\x12%\n" +
	"!MessageType_eip7702_authorization\x10\x05B\x17\n" +
	"\x15wallet.core.jni.protob\x06proto3"

var (
	file_Ethereum_proto_rawDescOnce sync.Once
	file_Ethereum_proto_rawDescData []byte
)

func file_Ethereum_proto_rawDescGZIP() []byte {
	file_Ethereum_proto_rawDescOnce.Do(func() {
		file_Ethereum_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_Ethereum_proto_rawDesc), len(file_Ethereum_proto_rawDesc)))
	})
	return file_Ethereum_proto_rawDescData
}

var file_Ethereum_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_Ethereum_proto_msgTypes = make([]protoimpl.MessageInfo, 21)
var file_Ethereum_proto_goTypes = []any{
	(TransactionMode)(0),                          // 0: TW.Ethereum.Proto.TransactionMode
	(SCWalletType)(0),                             // 1: TW.Ethereum.Proto.SCWalletType
	(MessageType)(0),                              // 2: TW.Ethereum.Proto.MessageType
	(*Transaction)(nil),                           // 3: TW.Ethereum.Proto.Transaction
	(*UserOperation)(nil),                         // 4: TW.Ethereum.Proto.UserOperation
	(*UserOperationV0_7)(nil),                     // 5: TW.Ethereum.Proto.UserOperationV0_7
	(*Access)(nil),                                // 6: TW.Ethereum.Proto.Access
	(*Authorization)(nil),                         // 7: TW.Ethereum.Proto.Authorization
	(*AuthorizationCustomSignature)(nil),          // 8: TW.Ethereum.Proto.AuthorizationCustomSignature
	(*SigningInput)(nil),                          // 9: TW.Ethereum.Proto.SigningInput
	(*SigningOutput)(nil),                         // 10: TW.Ethereum.Proto.SigningOutput
	(*MaybeChainId)(nil),                          // 11: TW.Ethereum.Proto.MaybeChainId
	(*MessageSigningInput)(nil),                   // 12: TW.Ethereum.Proto.MessageSigningInput
	(*MessageSigningOutput)(nil),                  // 13: TW.Ethereum.Proto.MessageSigningOutput
	(*MessageVerifyingInput)(nil),                 // 14: TW.Ethereum.Proto.MessageVerifyingInput
	(*Transaction_Transfer)(nil),                  // 15: TW.Ethereum.Proto.Transaction.Transfer
	(*Transaction_ERC20Transfer)(nil),             // 16: TW.Ethereum.Proto.Transaction.ERC20Transfer
	(*Transaction_ERC20Approve)(nil),              // 17: TW.Ethereum.Proto.Transaction.ERC20Approve
	(*Transaction_ERC721Transfer)(nil),            // 18: TW.Ethereum.Proto.Transaction.ERC721Transfer
	(*Transaction_ERC1155Transfer)(nil),           // 19: TW.Ethereum.Proto.Transaction.ERC1155Transfer
	(*Transaction_ContractGeneric)(nil),           // 20: TW.Ethereum.Proto.Transaction.ContractGeneric
	(*Transaction_SCWalletBatch)(nil),             // 21: TW.Ethereum.Proto.Transaction.SCWalletBatch
	(*Transaction_SCWalletExecute)(nil),           // 22: TW.Ethereum.Proto.Transaction.SCWalletExecute
	(*Transaction_SCWalletBatch_BatchedCall)(nil), // 23: TW.Ethereum.Proto.Transaction.SCWalletBatch.BatchedCall
	(common.SigningError)(0),                      // 24: TW.Common.Proto.SigningError
}
var file_Ethereum_proto_depIdxs = []int32{
	15, // 0: TW.Ethereum.Proto.Transaction.transfer:type_name -> TW.Ethereum.Proto.Transaction.Transfer
	16, // 1: TW.Ethereum.Proto.Transaction.erc20_transfer:type_name -> TW.Ethereum.Proto.Transaction.ERC20Transfer
	17, // 2: TW.Ethereum.Proto.Transaction.erc20_approve:type_name -> TW.Ethereum.Proto.Transaction.ERC20Approve
	18, // 3: TW.Ethereum.Proto.Transaction.erc721_transfer:type_name -> TW.Ethereum.Proto.Transaction.ERC721Transfer
	19, // 4: TW.Ethereum.Proto.Transaction.erc1155_transfer:type_name -> TW.Ethereum.Proto.Transaction.ERC1155Transfer
	20, // 5: TW.Ethereum.Proto.Transaction.contract_generic:type_name -> TW.Ethereum.Proto.Transaction.ContractGeneric
	21, // 6: TW.Ethereum.Proto.Transaction.scw_batch:type_name -> TW.Ethereum.Proto.Transaction.SCWalletBatch
	22, // 7: TW.Ethereum.Proto.Transaction.scw_execute:type_name -> TW.Ethereum.Proto.Transaction.SCWalletExecute
	8,  // 8: TW.Ethereum.Proto.Authorization.custom_signature:type_name -> TW.Ethereum.Proto.AuthorizationCustomSignature
	0,  // 9: TW.Ethereum.Proto.SigningInput.tx_mode:type_name -> TW.Ethereum.Proto.TransactionMode
	3,  // 10: TW.Ethereum.Proto.SigningInput.transaction:type_name -> TW.Ethereum.Proto.Transaction
	4,  // 11: TW.Ethereum.Proto.SigningInput.user_operation:type_name -> TW.Ethereum.Proto.UserOperation
	5,  // 12: TW.Ethereum.Proto.SigningInput.user_operation_v0_7:type_name -> TW.Ethereum.Proto.UserOperationV0_7
	6,  // 13: TW.Ethereum.Proto.SigningInput.access_list:type_name -> TW.Ethereum.Proto.Access
	7,  // 14: TW.Ethereum.Proto.SigningInput.eip7702_authorization:type_name -> TW.Ethereum.Proto.Authorization
	24, // 15: TW.Ethereum.Proto.SigningOutput.error:type_name -> TW.Common.Proto.SigningError
	11, // 16: TW.Ethereum.Proto.MessageSigningInput.chain_id:type_name -> TW.Ethereum.Proto.MaybeChainId
	2,  // 17: TW.Ethereum.Proto.MessageSigningInput.message_type:type_name -> TW.Ethereum.Proto.MessageType
	24, // 18: TW.Ethereum.Proto.MessageSigningOutput.error:type_name -> TW.Common.Proto.SigningError
	23, // 19: TW.Ethereum.Proto.Transaction.SCWalletBatch.calls:type_name -> TW.Ethereum.Proto.Transaction.SCWalletBatch.BatchedCall
	1,  // 20: TW.Ethereum.Proto.Transaction.SCWalletBatch.wallet_type:type_name -> TW.Ethereum.Proto.SCWalletType
	3,  // 21: TW.Ethereum.Proto.Transaction.SCWalletExecute.transaction:type_name -> TW.Ethereum.Proto.Transaction
	1,  // 22: TW.Ethereum.Proto.Transaction.SCWalletExecute.wallet_type:type_name -> TW.Ethereum.Proto.SCWalletType
	23, // [23:23] is the sub-list for method output_type
	23, // [23:23] is the sub-list for method input_type
	23, // [23:23] is the sub-list for extension type_name
	23, // [23:23] is the sub-list for extension extendee
	0,  // [0:23] is the sub-list for field type_name
}

func init() { file_Ethereum_proto_init() }
func file_Ethereum_proto_init() {
	if File_Ethereum_proto != nil {
		return
	}
	file_Ethereum_proto_msgTypes[0].OneofWrappers = []any{
		(*Transaction_Transfer_)(nil),
		(*Transaction_Erc20Transfer)(nil),
		(*Transaction_Erc20Approve)(nil),
		(*Transaction_Erc721Transfer)(nil),
		(*Transaction_Erc1155Transfer)(nil),
		(*Transaction_ContractGeneric_)(nil),
		(*Transaction_ScwBatch)(nil),
		(*Transaction_ScwExecute)(nil),
	}
	file_Ethereum_proto_msgTypes[6].OneofWrappers = []any{
		(*SigningInput_UserOperation)(nil),
		(*SigningInput_UserOperationV0_7)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_Ethereum_proto_rawDesc), len(file_Ethereum_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   21,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_Ethereum_proto_goTypes,
		DependencyIndexes: file_Ethereum_proto_depIdxs,
		EnumInfos:         file_Ethereum_proto_enumTypes,
		MessageInfos:      file_Ethereum_proto_msgTypes,
	}.Build()
	File_Ethereum_proto = out.File
	file_Ethereum_proto_goTypes = nil
	file_Ethereum_proto_depIdxs = nil
}
