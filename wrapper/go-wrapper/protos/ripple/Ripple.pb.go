// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.20.3
// source: Ripple.proto

package ripple

import (
	common "github.com/Cramiumlabs/wallet-core/wrapper/go-wrapper/protos/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// https://xrpl.org/currency-formats.html#token-amounts
type CurrencyAmount struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Currency code
	// https://xrpl.org/currency-formats.html#currency-codes
	Currency string `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	// String number
	// https://xrpl.org/currency-formats.html#string-numbers
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Account
	// https://xrpl.org/accounts.html
	Issuer        string `protobuf:"bytes,3,opt,name=issuer,proto3" json:"issuer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CurrencyAmount) Reset() {
	*x = CurrencyAmount{}
	mi := &file_Ripple_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CurrencyAmount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CurrencyAmount) ProtoMessage() {}

func (x *CurrencyAmount) ProtoReflect() protoreflect.Message {
	mi := &file_Ripple_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CurrencyAmount.ProtoReflect.Descriptor instead.
func (*CurrencyAmount) Descriptor() ([]byte, []int) {
	return file_Ripple_proto_rawDescGZIP(), []int{0}
}

func (x *CurrencyAmount) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

func (x *CurrencyAmount) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *CurrencyAmount) GetIssuer() string {
	if x != nil {
		return x.Issuer
	}
	return ""
}

// https://xrpl.org/trustset.html
type OperationTrustSet struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	LimitAmount   *CurrencyAmount        `protobuf:"bytes,1,opt,name=limit_amount,json=limitAmount,proto3" json:"limit_amount,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperationTrustSet) Reset() {
	*x = OperationTrustSet{}
	mi := &file_Ripple_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationTrustSet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationTrustSet) ProtoMessage() {}

func (x *OperationTrustSet) ProtoReflect() protoreflect.Message {
	mi := &file_Ripple_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationTrustSet.ProtoReflect.Descriptor instead.
func (*OperationTrustSet) Descriptor() ([]byte, []int) {
	return file_Ripple_proto_rawDescGZIP(), []int{1}
}

func (x *OperationTrustSet) GetLimitAmount() *CurrencyAmount {
	if x != nil {
		return x.LimitAmount
	}
	return nil
}

// https://xrpl.org/payment.html
type OperationPayment struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Transfer amount
	//
	// Types that are valid to be assigned to AmountOneof:
	//
	//	*OperationPayment_Amount
	//	*OperationPayment_CurrencyAmount
	AmountOneof isOperationPayment_AmountOneof `protobuf_oneof:"amount_oneof"`
	// Target account
	Destination string `protobuf:"bytes,3,opt,name=destination,proto3" json:"destination,omitempty"`
	// A Destination Tag
	// It must fit uint32
	DestinationTag uint64 `protobuf:"varint,4,opt,name=destination_tag,json=destinationTag,proto3" json:"destination_tag,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *OperationPayment) Reset() {
	*x = OperationPayment{}
	mi := &file_Ripple_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationPayment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationPayment) ProtoMessage() {}

func (x *OperationPayment) ProtoReflect() protoreflect.Message {
	mi := &file_Ripple_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationPayment.ProtoReflect.Descriptor instead.
func (*OperationPayment) Descriptor() ([]byte, []int) {
	return file_Ripple_proto_rawDescGZIP(), []int{2}
}

func (x *OperationPayment) GetAmountOneof() isOperationPayment_AmountOneof {
	if x != nil {
		return x.AmountOneof
	}
	return nil
}

func (x *OperationPayment) GetAmount() int64 {
	if x != nil {
		if x, ok := x.AmountOneof.(*OperationPayment_Amount); ok {
			return x.Amount
		}
	}
	return 0
}

func (x *OperationPayment) GetCurrencyAmount() *CurrencyAmount {
	if x != nil {
		if x, ok := x.AmountOneof.(*OperationPayment_CurrencyAmount); ok {
			return x.CurrencyAmount
		}
	}
	return nil
}

func (x *OperationPayment) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *OperationPayment) GetDestinationTag() uint64 {
	if x != nil {
		return x.DestinationTag
	}
	return 0
}

type isOperationPayment_AmountOneof interface {
	isOperationPayment_AmountOneof()
}

type OperationPayment_Amount struct {
	Amount int64 `protobuf:"varint,1,opt,name=amount,proto3,oneof"`
}

type OperationPayment_CurrencyAmount struct {
	CurrencyAmount *CurrencyAmount `protobuf:"bytes,2,opt,name=currency_amount,json=currencyAmount,proto3,oneof"`
}

func (*OperationPayment_Amount) isOperationPayment_AmountOneof() {}

func (*OperationPayment_CurrencyAmount) isOperationPayment_AmountOneof() {}

// https://xrpl.org/escrowcreate.html
type OperationEscrowCreate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Escrow amount
	Amount int64 `protobuf:"varint,1,opt,name=amount,proto3" json:"amount,omitempty"`
	// Beneficiary account
	Destination string `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	// Destination Tag
	// It must fit uint32
	DestinationTag uint64 `protobuf:"varint,3,opt,name=destination_tag,json=destinationTag,proto3" json:"destination_tag,omitempty"`
	// Escrow expire time
	// It must fit uint32
	CancelAfter uint64 `protobuf:"varint,4,opt,name=cancel_after,json=cancelAfter,proto3" json:"cancel_after,omitempty"`
	// Escrow release time
	// It must fit uint32
	FinishAfter uint64 `protobuf:"varint,5,opt,name=finish_after,json=finishAfter,proto3" json:"finish_after,omitempty"`
	// Hex-encoded crypto condition
	// https://datatracker.ietf.org/doc/html/draft-thomas-crypto-conditions-02#section-8.1
	Condition     string `protobuf:"bytes,6,opt,name=condition,proto3" json:"condition,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperationEscrowCreate) Reset() {
	*x = OperationEscrowCreate{}
	mi := &file_Ripple_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationEscrowCreate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationEscrowCreate) ProtoMessage() {}

func (x *OperationEscrowCreate) ProtoReflect() protoreflect.Message {
	mi := &file_Ripple_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationEscrowCreate.ProtoReflect.Descriptor instead.
func (*OperationEscrowCreate) Descriptor() ([]byte, []int) {
	return file_Ripple_proto_rawDescGZIP(), []int{3}
}

func (x *OperationEscrowCreate) GetAmount() int64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

func (x *OperationEscrowCreate) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *OperationEscrowCreate) GetDestinationTag() uint64 {
	if x != nil {
		return x.DestinationTag
	}
	return 0
}

func (x *OperationEscrowCreate) GetCancelAfter() uint64 {
	if x != nil {
		return x.CancelAfter
	}
	return 0
}

func (x *OperationEscrowCreate) GetFinishAfter() uint64 {
	if x != nil {
		return x.FinishAfter
	}
	return 0
}

func (x *OperationEscrowCreate) GetCondition() string {
	if x != nil {
		return x.Condition
	}
	return ""
}

// https://xrpl.org/escrowcancel.html
type OperationEscrowCancel struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Funding account
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// Escrow transaction sequence
	OfferSequence uint32 `protobuf:"varint,2,opt,name=offer_sequence,json=offerSequence,proto3" json:"offer_sequence,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperationEscrowCancel) Reset() {
	*x = OperationEscrowCancel{}
	mi := &file_Ripple_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationEscrowCancel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationEscrowCancel) ProtoMessage() {}

func (x *OperationEscrowCancel) ProtoReflect() protoreflect.Message {
	mi := &file_Ripple_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationEscrowCancel.ProtoReflect.Descriptor instead.
func (*OperationEscrowCancel) Descriptor() ([]byte, []int) {
	return file_Ripple_proto_rawDescGZIP(), []int{4}
}

func (x *OperationEscrowCancel) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *OperationEscrowCancel) GetOfferSequence() uint32 {
	if x != nil {
		return x.OfferSequence
	}
	return 0
}

// https://xrpl.org/escrowfinish.html
type OperationEscrowFinish struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Funding account
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// Escrow transaction sequence
	OfferSequence uint32 `protobuf:"varint,2,opt,name=offer_sequence,json=offerSequence,proto3" json:"offer_sequence,omitempty"`
	// Hex-encoded crypto condition
	Condition string `protobuf:"bytes,3,opt,name=condition,proto3" json:"condition,omitempty"`
	// Hex-encoded fulfillment matching condition
	Fulfillment   string `protobuf:"bytes,4,opt,name=fulfillment,proto3" json:"fulfillment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperationEscrowFinish) Reset() {
	*x = OperationEscrowFinish{}
	mi := &file_Ripple_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationEscrowFinish) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationEscrowFinish) ProtoMessage() {}

func (x *OperationEscrowFinish) ProtoReflect() protoreflect.Message {
	mi := &file_Ripple_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationEscrowFinish.ProtoReflect.Descriptor instead.
func (*OperationEscrowFinish) Descriptor() ([]byte, []int) {
	return file_Ripple_proto_rawDescGZIP(), []int{5}
}

func (x *OperationEscrowFinish) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *OperationEscrowFinish) GetOfferSequence() uint32 {
	if x != nil {
		return x.OfferSequence
	}
	return 0
}

func (x *OperationEscrowFinish) GetCondition() string {
	if x != nil {
		return x.Condition
	}
	return ""
}

func (x *OperationEscrowFinish) GetFulfillment() string {
	if x != nil {
		return x.Fulfillment
	}
	return ""
}

// https://xrpl.org/nftokenburn.html
type OperationNFTokenBurn struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Hex-encoded H256 NFTokenId
	NftokenId     string `protobuf:"bytes,1,opt,name=nftoken_id,json=nftokenId,proto3" json:"nftoken_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperationNFTokenBurn) Reset() {
	*x = OperationNFTokenBurn{}
	mi := &file_Ripple_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationNFTokenBurn) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationNFTokenBurn) ProtoMessage() {}

func (x *OperationNFTokenBurn) ProtoReflect() protoreflect.Message {
	mi := &file_Ripple_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationNFTokenBurn.ProtoReflect.Descriptor instead.
func (*OperationNFTokenBurn) Descriptor() ([]byte, []int) {
	return file_Ripple_proto_rawDescGZIP(), []int{6}
}

func (x *OperationNFTokenBurn) GetNftokenId() string {
	if x != nil {
		return x.NftokenId
	}
	return ""
}

// https://xrpl.org/nftokencreateoffer.html
type OperationNFTokenCreateOffer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Hex-encoded Hash256 NFTokenId
	NftokenId string `protobuf:"bytes,1,opt,name=nftoken_id,json=nftokenId,proto3" json:"nftoken_id,omitempty"`
	// Destination account
	Destination   string `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperationNFTokenCreateOffer) Reset() {
	*x = OperationNFTokenCreateOffer{}
	mi := &file_Ripple_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationNFTokenCreateOffer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationNFTokenCreateOffer) ProtoMessage() {}

func (x *OperationNFTokenCreateOffer) ProtoReflect() protoreflect.Message {
	mi := &file_Ripple_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationNFTokenCreateOffer.ProtoReflect.Descriptor instead.
func (*OperationNFTokenCreateOffer) Descriptor() ([]byte, []int) {
	return file_Ripple_proto_rawDescGZIP(), []int{7}
}

func (x *OperationNFTokenCreateOffer) GetNftokenId() string {
	if x != nil {
		return x.NftokenId
	}
	return ""
}

func (x *OperationNFTokenCreateOffer) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

// https://xrpl.org/nftokenacceptoffer.html
type OperationNFTokenAcceptOffer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Hex-encoded Hash256 NFTokenOffer
	SellOffer     string `protobuf:"bytes,1,opt,name=sell_offer,json=sellOffer,proto3" json:"sell_offer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperationNFTokenAcceptOffer) Reset() {
	*x = OperationNFTokenAcceptOffer{}
	mi := &file_Ripple_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationNFTokenAcceptOffer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationNFTokenAcceptOffer) ProtoMessage() {}

func (x *OperationNFTokenAcceptOffer) ProtoReflect() protoreflect.Message {
	mi := &file_Ripple_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationNFTokenAcceptOffer.ProtoReflect.Descriptor instead.
func (*OperationNFTokenAcceptOffer) Descriptor() ([]byte, []int) {
	return file_Ripple_proto_rawDescGZIP(), []int{8}
}

func (x *OperationNFTokenAcceptOffer) GetSellOffer() string {
	if x != nil {
		return x.SellOffer
	}
	return ""
}

// https://xrpl.org/nftokencanceloffer.html
type OperationNFTokenCancelOffer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Hex-encoded Vector256 NFTokenOffers
	TokenOffers   []string `protobuf:"bytes,1,rep,name=token_offers,json=tokenOffers,proto3" json:"token_offers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperationNFTokenCancelOffer) Reset() {
	*x = OperationNFTokenCancelOffer{}
	mi := &file_Ripple_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationNFTokenCancelOffer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationNFTokenCancelOffer) ProtoMessage() {}

func (x *OperationNFTokenCancelOffer) ProtoReflect() protoreflect.Message {
	mi := &file_Ripple_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationNFTokenCancelOffer.ProtoReflect.Descriptor instead.
func (*OperationNFTokenCancelOffer) Descriptor() ([]byte, []int) {
	return file_Ripple_proto_rawDescGZIP(), []int{9}
}

func (x *OperationNFTokenCancelOffer) GetTokenOffers() []string {
	if x != nil {
		return x.TokenOffers
	}
	return nil
}

// Input data necessary to create a signed transaction.
type SigningInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Transfer fee
	Fee int64 `protobuf:"varint,1,opt,name=fee,proto3" json:"fee,omitempty"`
	// Account sequence number
	Sequence uint32 `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// Ledger sequence number
	LastLedgerSequence uint32 `protobuf:"varint,3,opt,name=last_ledger_sequence,json=lastLedgerSequence,proto3" json:"last_ledger_sequence,omitempty"`
	// Source account
	Account string `protobuf:"bytes,4,opt,name=account,proto3" json:"account,omitempty"`
	// Transaction flags, optional
	// It must fit uint32
	Flags uint64 `protobuf:"varint,5,opt,name=flags,proto3" json:"flags,omitempty"`
	// The secret private key used for signing (32 bytes).
	PrivateKey []byte `protobuf:"bytes,6,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// Types that are valid to be assigned to OperationOneof:
	//
	//	*SigningInput_OpTrustSet
	//	*SigningInput_OpPayment
	//	*SigningInput_OpNftokenBurn
	//	*SigningInput_OpNftokenCreateOffer
	//	*SigningInput_OpNftokenAcceptOffer
	//	*SigningInput_OpNftokenCancelOffer
	//	*SigningInput_OpEscrowCreate
	//	*SigningInput_OpEscrowCancel
	//	*SigningInput_OpEscrowFinish
	OperationOneof isSigningInput_OperationOneof `protobuf_oneof:"operation_oneof"`
	// Only used by tss chain-integration.
	PublicKey []byte `protobuf:"bytes,15,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Generate a transaction from its JSON representation.
	// The following parameters can be replaced from the `SigningInput` Protobuf:
	// * Account
	// * SigningPubKey
	// * Fee
	// * Sequence
	// * LastLedgerSequence
	RawJson string `protobuf:"bytes,20,opt,name=raw_json,json=rawJson,proto3" json:"raw_json,omitempty"`
	// Arbitrary integer used to identify the reason for this payment, or a sender on whose behalf this transaction is made.
	// Conventionally, a refund should specify the initial payment's SourceTag as the refund payment's DestinationTag.
	// It must fit uint32.
	SourceTag     uint64 `protobuf:"varint,25,opt,name=source_tag,json=sourceTag,proto3" json:"source_tag,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SigningInput) Reset() {
	*x = SigningInput{}
	mi := &file_Ripple_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningInput) ProtoMessage() {}

func (x *SigningInput) ProtoReflect() protoreflect.Message {
	mi := &file_Ripple_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningInput.ProtoReflect.Descriptor instead.
func (*SigningInput) Descriptor() ([]byte, []int) {
	return file_Ripple_proto_rawDescGZIP(), []int{10}
}

func (x *SigningInput) GetFee() int64 {
	if x != nil {
		return x.Fee
	}
	return 0
}

func (x *SigningInput) GetSequence() uint32 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *SigningInput) GetLastLedgerSequence() uint32 {
	if x != nil {
		return x.LastLedgerSequence
	}
	return 0
}

func (x *SigningInput) GetAccount() string {
	if x != nil {
		return x.Account
	}
	return ""
}

func (x *SigningInput) GetFlags() uint64 {
	if x != nil {
		return x.Flags
	}
	return 0
}

func (x *SigningInput) GetPrivateKey() []byte {
	if x != nil {
		return x.PrivateKey
	}
	return nil
}

func (x *SigningInput) GetOperationOneof() isSigningInput_OperationOneof {
	if x != nil {
		return x.OperationOneof
	}
	return nil
}

func (x *SigningInput) GetOpTrustSet() *OperationTrustSet {
	if x != nil {
		if x, ok := x.OperationOneof.(*SigningInput_OpTrustSet); ok {
			return x.OpTrustSet
		}
	}
	return nil
}

func (x *SigningInput) GetOpPayment() *OperationPayment {
	if x != nil {
		if x, ok := x.OperationOneof.(*SigningInput_OpPayment); ok {
			return x.OpPayment
		}
	}
	return nil
}

func (x *SigningInput) GetOpNftokenBurn() *OperationNFTokenBurn {
	if x != nil {
		if x, ok := x.OperationOneof.(*SigningInput_OpNftokenBurn); ok {
			return x.OpNftokenBurn
		}
	}
	return nil
}

func (x *SigningInput) GetOpNftokenCreateOffer() *OperationNFTokenCreateOffer {
	if x != nil {
		if x, ok := x.OperationOneof.(*SigningInput_OpNftokenCreateOffer); ok {
			return x.OpNftokenCreateOffer
		}
	}
	return nil
}

func (x *SigningInput) GetOpNftokenAcceptOffer() *OperationNFTokenAcceptOffer {
	if x != nil {
		if x, ok := x.OperationOneof.(*SigningInput_OpNftokenAcceptOffer); ok {
			return x.OpNftokenAcceptOffer
		}
	}
	return nil
}

func (x *SigningInput) GetOpNftokenCancelOffer() *OperationNFTokenCancelOffer {
	if x != nil {
		if x, ok := x.OperationOneof.(*SigningInput_OpNftokenCancelOffer); ok {
			return x.OpNftokenCancelOffer
		}
	}
	return nil
}

func (x *SigningInput) GetOpEscrowCreate() *OperationEscrowCreate {
	if x != nil {
		if x, ok := x.OperationOneof.(*SigningInput_OpEscrowCreate); ok {
			return x.OpEscrowCreate
		}
	}
	return nil
}

func (x *SigningInput) GetOpEscrowCancel() *OperationEscrowCancel {
	if x != nil {
		if x, ok := x.OperationOneof.(*SigningInput_OpEscrowCancel); ok {
			return x.OpEscrowCancel
		}
	}
	return nil
}

func (x *SigningInput) GetOpEscrowFinish() *OperationEscrowFinish {
	if x != nil {
		if x, ok := x.OperationOneof.(*SigningInput_OpEscrowFinish); ok {
			return x.OpEscrowFinish
		}
	}
	return nil
}

func (x *SigningInput) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *SigningInput) GetRawJson() string {
	if x != nil {
		return x.RawJson
	}
	return ""
}

func (x *SigningInput) GetSourceTag() uint64 {
	if x != nil {
		return x.SourceTag
	}
	return 0
}

type isSigningInput_OperationOneof interface {
	isSigningInput_OperationOneof()
}

type SigningInput_OpTrustSet struct {
	OpTrustSet *OperationTrustSet `protobuf:"bytes,7,opt,name=op_trust_set,json=opTrustSet,proto3,oneof"`
}

type SigningInput_OpPayment struct {
	OpPayment *OperationPayment `protobuf:"bytes,8,opt,name=op_payment,json=opPayment,proto3,oneof"`
}

type SigningInput_OpNftokenBurn struct {
	OpNftokenBurn *OperationNFTokenBurn `protobuf:"bytes,9,opt,name=op_nftoken_burn,json=opNftokenBurn,proto3,oneof"`
}

type SigningInput_OpNftokenCreateOffer struct {
	OpNftokenCreateOffer *OperationNFTokenCreateOffer `protobuf:"bytes,10,opt,name=op_nftoken_create_offer,json=opNftokenCreateOffer,proto3,oneof"`
}

type SigningInput_OpNftokenAcceptOffer struct {
	OpNftokenAcceptOffer *OperationNFTokenAcceptOffer `protobuf:"bytes,11,opt,name=op_nftoken_accept_offer,json=opNftokenAcceptOffer,proto3,oneof"`
}

type SigningInput_OpNftokenCancelOffer struct {
	OpNftokenCancelOffer *OperationNFTokenCancelOffer `protobuf:"bytes,12,opt,name=op_nftoken_cancel_offer,json=opNftokenCancelOffer,proto3,oneof"`
}

type SigningInput_OpEscrowCreate struct {
	OpEscrowCreate *OperationEscrowCreate `protobuf:"bytes,16,opt,name=op_escrow_create,json=opEscrowCreate,proto3,oneof"`
}

type SigningInput_OpEscrowCancel struct {
	OpEscrowCancel *OperationEscrowCancel `protobuf:"bytes,17,opt,name=op_escrow_cancel,json=opEscrowCancel,proto3,oneof"`
}

type SigningInput_OpEscrowFinish struct {
	OpEscrowFinish *OperationEscrowFinish `protobuf:"bytes,18,opt,name=op_escrow_finish,json=opEscrowFinish,proto3,oneof"`
}

func (*SigningInput_OpTrustSet) isSigningInput_OperationOneof() {}

func (*SigningInput_OpPayment) isSigningInput_OperationOneof() {}

func (*SigningInput_OpNftokenBurn) isSigningInput_OperationOneof() {}

func (*SigningInput_OpNftokenCreateOffer) isSigningInput_OperationOneof() {}

func (*SigningInput_OpNftokenAcceptOffer) isSigningInput_OperationOneof() {}

func (*SigningInput_OpNftokenCancelOffer) isSigningInput_OperationOneof() {}

func (*SigningInput_OpEscrowCreate) isSigningInput_OperationOneof() {}

func (*SigningInput_OpEscrowCancel) isSigningInput_OperationOneof() {}

func (*SigningInput_OpEscrowFinish) isSigningInput_OperationOneof() {}

// Result containing the signed and encoded transaction.
type SigningOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Encoded transaction
	Encoded []byte `protobuf:"bytes,1,opt,name=encoded,proto3" json:"encoded,omitempty"`
	// Optional error
	Error common.SigningError `protobuf:"varint,2,opt,name=error,proto3,enum=TW.Common.Proto.SigningError" json:"error,omitempty"`
	// error code description
	ErrorMessage  string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SigningOutput) Reset() {
	*x = SigningOutput{}
	mi := &file_Ripple_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningOutput) ProtoMessage() {}

func (x *SigningOutput) ProtoReflect() protoreflect.Message {
	mi := &file_Ripple_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningOutput.ProtoReflect.Descriptor instead.
func (*SigningOutput) Descriptor() ([]byte, []int) {
	return file_Ripple_proto_rawDescGZIP(), []int{11}
}

func (x *SigningOutput) GetEncoded() []byte {
	if x != nil {
		return x.Encoded
	}
	return nil
}

func (x *SigningOutput) GetError() common.SigningError {
	if x != nil {
		return x.Error
	}
	return common.SigningError(0)
}

func (x *SigningOutput) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

var File_Ripple_proto protoreflect.FileDescriptor

const file_Ripple_proto_rawDesc = "" +
	"\n" +
	"\fRipple.proto\x12\x0fTW.Ripple.Proto\x1a\fCommon.proto\"Z\n" +
	"\x0eCurrencyAmount\x12\x1a\n" +
	"\bcurrency\x18\x01 \x01(\tR\bcurrency\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x12\x16\n" +
	"\x06issuer\x18\x03 \x01(\tR\x06issuer\"W\n" +
	"\x11OperationTrustSet\x12B\n" +
	"\flimit_amount\x18\x01 \x01(\v2\x1f.TW.Ripple.Proto.CurrencyAmountR\vlimitAmount\"\xd3\x01\n" +
	"\x10OperationPayment\x12\x18\n" +
	"\x06amount\x18\x01 \x01(\x03H\x00R\x06amount\x12J\n" +
	"\x0fcurrency_amount\x18\x02 \x01(\v2\x1f.TW.Ripple.Proto.CurrencyAmountH\x00R\x0ecurrencyAmount\x12 \n" +
	"\vdestination\x18\x03 \x01(\tR\vdestination\x12'\n" +
	"\x0fdestination_tag\x18\x04 \x01(\x04R\x0edestinationTagB\x0e\n" +
	"\famount_oneof\"\xde\x01\n" +
	"\x15OperationEscrowCreate\x12\x16\n" +
	"\x06amount\x18\x01 \x01(\x03R\x06amount\x12 \n" +
	"\vdestination\x18\x02 \x01(\tR\vdestination\x12'\n" +
	"\x0fdestination_tag\x18\x03 \x01(\x04R\x0edestinationTag\x12!\n" +
	"\fcancel_after\x18\x04 \x01(\x04R\vcancelAfter\x12!\n" +
	"\ffinish_after\x18\x05 \x01(\x04R\vfinishAfter\x12\x1c\n" +
	"\tcondition\x18\x06 \x01(\tR\tcondition\"T\n" +
	"\x15OperationEscrowCancel\x12\x14\n" +
	"\x05owner\x18\x01 \x01(\tR\x05owner\x12%\n" +
	"\x0eoffer_sequence\x18\x02 \x01(\rR\rofferSequence\"\x94\x01\n" +
	"\x15OperationEscrowFinish\x12\x14\n" +
	"\x05owner\x18\x01 \x01(\tR\x05owner\x12%\n" +
	"\x0eoffer_sequence\x18\x02 \x01(\rR\rofferSequence\x12\x1c\n" +
	"\tcondition\x18\x03 \x01(\tR\tcondition\x12 \n" +
	"\vfulfillment\x18\x04 \x01(\tR\vfulfillment\"5\n" +
	"\x14OperationNFTokenBurn\x12\x1d\n" +
	"\n" +
	"nftoken_id\x18\x01 \x01(\tR\tnftokenId\"^\n" +
	"\x1bOperationNFTokenCreateOffer\x12\x1d\n" +
	"\n" +
	"nftoken_id\x18\x01 \x01(\tR\tnftokenId\x12 \n" +
	"\vdestination\x18\x02 \x01(\tR\vdestination\"<\n" +
	"\x1bOperationNFTokenAcceptOffer\x12\x1d\n" +
	"\n" +
	"sell_offer\x18\x01 \x01(\tR\tsellOffer\"@\n" +
	"\x1bOperationNFTokenCancelOffer\x12!\n" +
	"\ftoken_offers\x18\x01 \x03(\tR\vtokenOffers\"\xb9\b\n" +
	"\fSigningInput\x12\x10\n" +
	"\x03fee\x18\x01 \x01(\x03R\x03fee\x12\x1a\n" +
	"\bsequence\x18\x02 \x01(\rR\bsequence\x120\n" +
	"\x14last_ledger_sequence\x18\x03 \x01(\rR\x12lastLedgerSequence\x12\x18\n" +
	"\aaccount\x18\x04 \x01(\tR\aaccount\x12\x14\n" +
	"\x05flags\x18\x05 \x01(\x04R\x05flags\x12\x1f\n" +
	"\vprivate_key\x18\x06 \x01(\fR\n" +
	"privateKey\x12F\n" +
	"\fop_trust_set\x18\a \x01(\v2\".TW.Ripple.Proto.OperationTrustSetH\x00R\n" +
	"opTrustSet\x12B\n" +
	"\n" +
	"op_payment\x18\b \x01(\v2!.TW.Ripple.Proto.OperationPaymentH\x00R\topPayment\x12O\n" +
	"\x0fop_nftoken_burn\x18\t \x01(\v2%.TW.Ripple.Proto.OperationNFTokenBurnH\x00R\ropNftokenBurn\x12e\n" +
	"\x17op_nftoken_create_offer\x18\n" +
	" \x01(\v2,.TW.Ripple.Proto.OperationNFTokenCreateOfferH\x00R\x14opNftokenCreateOffer\x12e\n" +
	"\x17op_nftoken_accept_offer\x18\v \x01(\v2,.TW.Ripple.Proto.OperationNFTokenAcceptOfferH\x00R\x14opNftokenAcceptOffer\x12e\n" +
	"\x17op_nftoken_cancel_offer\x18\f \x01(\v2,.TW.Ripple.Proto.OperationNFTokenCancelOfferH\x00R\x14opNftokenCancelOffer\x12R\n" +
	"\x10op_escrow_create\x18\x10 \x01(\v2&.TW.Ripple.Proto.OperationEscrowCreateH\x00R\x0eopEscrowCreate\x12R\n" +
	"\x10op_escrow_cancel\x18\x11 \x01(\v2&.TW.Ripple.Proto.OperationEscrowCancelH\x00R\x0eopEscrowCancel\x12R\n" +
	"\x10op_escrow_finish\x18\x12 \x01(\v2&.TW.Ripple.Proto.OperationEscrowFinishH\x00R\x0eopEscrowFinish\x12\x1d\n" +
	"\n" +
	"public_key\x18\x0f \x01(\fR\tpublicKey\x12\x19\n" +
	"\braw_json\x18\x14 \x01(\tR\arawJson\x12\x1d\n" +
	"\n" +
	"source_tag\x18\x19 \x01(\x04R\tsourceTagB\x11\n" +
	"\x0foperation_oneof\"\x83\x01\n" +
	"\rSigningOutput\x12\x18\n" +
	"\aencoded\x18\x01 \x01(\fR\aencoded\x123\n" +
	"\x05error\x18\x02 \x01(\x0e2\x1d.TW.Common.Proto.SigningErrorR\x05error\x12#\n" +
	"\rerror_message\x18\x03 \x01(\tR\ferrorMessageB\x17\n" +
	"\x15wallet.core.jni.protob\x06proto3"

var (
	file_Ripple_proto_rawDescOnce sync.Once
	file_Ripple_proto_rawDescData []byte
)

func file_Ripple_proto_rawDescGZIP() []byte {
	file_Ripple_proto_rawDescOnce.Do(func() {
		file_Ripple_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_Ripple_proto_rawDesc), len(file_Ripple_proto_rawDesc)))
	})
	return file_Ripple_proto_rawDescData
}

var file_Ripple_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_Ripple_proto_goTypes = []any{
	(*CurrencyAmount)(nil),              // 0: TW.Ripple.Proto.CurrencyAmount
	(*OperationTrustSet)(nil),           // 1: TW.Ripple.Proto.OperationTrustSet
	(*OperationPayment)(nil),            // 2: TW.Ripple.Proto.OperationPayment
	(*OperationEscrowCreate)(nil),       // 3: TW.Ripple.Proto.OperationEscrowCreate
	(*OperationEscrowCancel)(nil),       // 4: TW.Ripple.Proto.OperationEscrowCancel
	(*OperationEscrowFinish)(nil),       // 5: TW.Ripple.Proto.OperationEscrowFinish
	(*OperationNFTokenBurn)(nil),        // 6: TW.Ripple.Proto.OperationNFTokenBurn
	(*OperationNFTokenCreateOffer)(nil), // 7: TW.Ripple.Proto.OperationNFTokenCreateOffer
	(*OperationNFTokenAcceptOffer)(nil), // 8: TW.Ripple.Proto.OperationNFTokenAcceptOffer
	(*OperationNFTokenCancelOffer)(nil), // 9: TW.Ripple.Proto.OperationNFTokenCancelOffer
	(*SigningInput)(nil),                // 10: TW.Ripple.Proto.SigningInput
	(*SigningOutput)(nil),               // 11: TW.Ripple.Proto.SigningOutput
	(common.SigningError)(0),            // 12: TW.Common.Proto.SigningError
}
var file_Ripple_proto_depIdxs = []int32{
	0,  // 0: TW.Ripple.Proto.OperationTrustSet.limit_amount:type_name -> TW.Ripple.Proto.CurrencyAmount
	0,  // 1: TW.Ripple.Proto.OperationPayment.currency_amount:type_name -> TW.Ripple.Proto.CurrencyAmount
	1,  // 2: TW.Ripple.Proto.SigningInput.op_trust_set:type_name -> TW.Ripple.Proto.OperationTrustSet
	2,  // 3: TW.Ripple.Proto.SigningInput.op_payment:type_name -> TW.Ripple.Proto.OperationPayment
	6,  // 4: TW.Ripple.Proto.SigningInput.op_nftoken_burn:type_name -> TW.Ripple.Proto.OperationNFTokenBurn
	7,  // 5: TW.Ripple.Proto.SigningInput.op_nftoken_create_offer:type_name -> TW.Ripple.Proto.OperationNFTokenCreateOffer
	8,  // 6: TW.Ripple.Proto.SigningInput.op_nftoken_accept_offer:type_name -> TW.Ripple.Proto.OperationNFTokenAcceptOffer
	9,  // 7: TW.Ripple.Proto.SigningInput.op_nftoken_cancel_offer:type_name -> TW.Ripple.Proto.OperationNFTokenCancelOffer
	3,  // 8: TW.Ripple.Proto.SigningInput.op_escrow_create:type_name -> TW.Ripple.Proto.OperationEscrowCreate
	4,  // 9: TW.Ripple.Proto.SigningInput.op_escrow_cancel:type_name -> TW.Ripple.Proto.OperationEscrowCancel
	5,  // 10: TW.Ripple.Proto.SigningInput.op_escrow_finish:type_name -> TW.Ripple.Proto.OperationEscrowFinish
	12, // 11: TW.Ripple.Proto.SigningOutput.error:type_name -> TW.Common.Proto.SigningError
	12, // [12:12] is the sub-list for method output_type
	12, // [12:12] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_Ripple_proto_init() }
func file_Ripple_proto_init() {
	if File_Ripple_proto != nil {
		return
	}
	file_Ripple_proto_msgTypes[2].OneofWrappers = []any{
		(*OperationPayment_Amount)(nil),
		(*OperationPayment_CurrencyAmount)(nil),
	}
	file_Ripple_proto_msgTypes[10].OneofWrappers = []any{
		(*SigningInput_OpTrustSet)(nil),
		(*SigningInput_OpPayment)(nil),
		(*SigningInput_OpNftokenBurn)(nil),
		(*SigningInput_OpNftokenCreateOffer)(nil),
		(*SigningInput_OpNftokenAcceptOffer)(nil),
		(*SigningInput_OpNftokenCancelOffer)(nil),
		(*SigningInput_OpEscrowCreate)(nil),
		(*SigningInput_OpEscrowCancel)(nil),
		(*SigningInput_OpEscrowFinish)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_Ripple_proto_rawDesc), len(file_Ripple_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_Ripple_proto_goTypes,
		DependencyIndexes: file_Ripple_proto_depIdxs,
		MessageInfos:      file_Ripple_proto_msgTypes,
	}.Build()
	File_Ripple_proto = out.File
	file_Ripple_proto_goTypes = nil
	file_Ripple_proto_depIdxs = nil
}
