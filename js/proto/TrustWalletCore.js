/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.TW = (function() {
    
        /**
         * Namespace TW.
         * @exports TW
         * @namespace
         */
        var TW = {};
    
        TW.ARK = (function() {
    
            /**
             * Namespace ARK.
             * @memberof TW
             * @namespace
             */
            var ARK = {};
    
            ARK.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.ARK
                 * @namespace
                 */
                var Proto = {};
    
                /**
                 * TransactionType enum.
                 * @name TW.ARK.Proto.TransactionType
                 * @enum {string}
                 * @property {number} Transfer=0 Transfer value
                 */
                Proto.TransactionType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "Transfer"] = 0;
                    return values;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.ARK.Proto
                     * @interface ISigningInput
                     * @property {TW.ARK.Proto.TransactionType|null} [type] SigningInput type
                     * @property {Long|null} [amount] SigningInput amount
                     * @property {Long|null} [fee] SigningInput fee
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {number|null} [timestamp] SigningInput timestamp
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.ARK.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.ARK.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput type.
                     * @member {TW.ARK.Proto.TransactionType} type
                     * @memberof TW.ARK.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.type = 0;
    
                    /**
                     * SigningInput amount.
                     * @member {Long} amount
                     * @memberof TW.ARK.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput fee.
                     * @member {Long} fee
                     * @memberof TW.ARK.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.ARK.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput timestamp.
                     * @member {number} timestamp
                     * @memberof TW.ARK.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timestamp = 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.ARK.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.ARK.Proto.SigningInput
                     * @static
                     * @param {TW.ARK.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.ARK.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.ARK.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.ARK.Proto.SigningInput
                     * @static
                     * @param {TW.ARK.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && message.hasOwnProperty("type"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.fee);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.toAddress);
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.timestamp);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.ARK.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.ARK.Proto.SigningInput
                     * @static
                     * @param {TW.ARK.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.ARK.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.ARK.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.ARK.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.type = reader.int32();
                                break;
                            case 2:
                                message.amount = reader.uint64();
                                break;
                            case 3:
                                message.fee = reader.uint64();
                                break;
                            case 4:
                                message.toAddress = reader.string();
                                break;
                            case 5:
                                message.timestamp = reader.uint32();
                                break;
                            case 6:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.ARK.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.ARK.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.ARK.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            switch (message.type) {
                            default:
                                return "type: enum value expected";
                            case 0:
                                break;
                            }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp))
                                return "timestamp: integer expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.ARK.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.ARK.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.ARK.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.ARK.Proto.SigningInput();
                        switch (object.type) {
                        case "Transfer":
                        case 0:
                            message.type = 0;
                            break;
                        }
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.timestamp != null)
                            message.timestamp = object.timestamp >>> 0;
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.ARK.Proto.SigningInput
                     * @static
                     * @param {TW.ARK.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.type = options.enums === String ? "Transfer" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            object.toAddress = "";
                            object.timestamp = 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = options.enums === String ? $root.TW.ARK.Proto.TransactionType[message.type] : message.type;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            object.timestamp = message.timestamp;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.ARK.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.ARK.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.ARK.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.ARK.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {string} encoded
                     * @memberof TW.ARK.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = "";
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.ARK.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.ARK.Proto.SigningOutput
                     * @static
                     * @param {TW.ARK.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.ARK.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.ARK.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.ARK.Proto.SigningOutput
                     * @static
                     * @param {TW.ARK.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.encoded);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.ARK.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.ARK.Proto.SigningOutput
                     * @static
                     * @param {TW.ARK.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.ARK.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.ARK.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.ARK.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.string();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.ARK.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.ARK.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.ARK.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!$util.isString(message.encoded))
                                return "encoded: string expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.ARK.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.ARK.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.ARK.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.ARK.Proto.SigningOutput();
                        if (object.encoded != null)
                            message.encoded = String(object.encoded);
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.ARK.Proto.SigningOutput
                     * @static
                     * @param {TW.ARK.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.encoded = "";
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = message.encoded;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.ARK.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return ARK;
        })();
    
        TW.Aeternity = (function() {
    
            /**
             * Namespace Aeternity.
             * @memberof TW
             * @namespace
             */
            var Aeternity = {};
    
            Aeternity.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Aeternity
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Aeternity.Proto
                     * @interface ISigningInput
                     * @property {string|null} [fromAddress] SigningInput fromAddress
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Uint8Array|null} [amount] SigningInput amount
                     * @property {Uint8Array|null} [fee] SigningInput fee
                     * @property {string|null} [payload] SigningInput payload
                     * @property {Long|null} [ttl] SigningInput ttl
                     * @property {Long|null} [nonce] SigningInput nonce
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Aeternity.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Aeternity.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fromAddress = "";
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * SigningInput fee.
                     * @member {Uint8Array} fee
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.newBuffer([]);
    
                    /**
                     * SigningInput payload.
                     * @member {string} payload
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.payload = "";
    
                    /**
                     * SigningInput ttl.
                     * @member {Long} ttl
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.ttl = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput nonce.
                     * @member {Long} nonce
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {TW.Aeternity.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Aeternity.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Aeternity.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {TW.Aeternity.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.fromAddress);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.toAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.amount);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.fee);
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.payload);
                        if (message.ttl != null && message.hasOwnProperty("ttl"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.ttl);
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.nonce);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Aeternity.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {TW.Aeternity.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Aeternity.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Aeternity.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromAddress = reader.string();
                                break;
                            case 2:
                                message.toAddress = reader.string();
                                break;
                            case 3:
                                message.amount = reader.bytes();
                                break;
                            case 4:
                                message.fee = reader.bytes();
                                break;
                            case 5:
                                message.payload = reader.string();
                                break;
                            case 6:
                                message.ttl = reader.uint64();
                                break;
                            case 7:
                                message.nonce = reader.uint64();
                                break;
                            case 8:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Aeternity.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!(message.fee && typeof message.fee.length === "number" || $util.isString(message.fee)))
                                return "fee: buffer expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!$util.isString(message.payload))
                                return "payload: string expected";
                        if (message.ttl != null && message.hasOwnProperty("ttl"))
                            if (!$util.isInteger(message.ttl) && !(message.ttl && $util.isInteger(message.ttl.low) && $util.isInteger(message.ttl.high)))
                                return "ttl: integer|Long expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Aeternity.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Aeternity.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Aeternity.Proto.SigningInput();
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        if (object.fee != null)
                            if (typeof object.fee === "string")
                                $util.base64.decode(object.fee, message.fee = $util.newBuffer($util.base64.length(object.fee)), 0);
                            else if (object.fee.length)
                                message.fee = object.fee;
                        if (object.payload != null)
                            message.payload = String(object.payload);
                        if (object.ttl != null)
                            if ($util.Long)
                                (message.ttl = $util.Long.fromValue(object.ttl)).unsigned = true;
                            else if (typeof object.ttl === "string")
                                message.ttl = parseInt(object.ttl, 10);
                            else if (typeof object.ttl === "number")
                                message.ttl = object.ttl;
                            else if (typeof object.ttl === "object")
                                message.ttl = new $util.LongBits(object.ttl.low >>> 0, object.ttl.high >>> 0).toNumber(true);
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @static
                     * @param {TW.Aeternity.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fromAddress = "";
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                            if (options.bytes === String)
                                object.fee = "";
                            else {
                                object.fee = [];
                                if (options.bytes !== Array)
                                    object.fee = $util.newBuffer(object.fee);
                            }
                            object.payload = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.ttl = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.ttl = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            object.fee = options.bytes === String ? $util.base64.encode(message.fee, 0, message.fee.length) : options.bytes === Array ? Array.prototype.slice.call(message.fee) : message.fee;
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = message.payload;
                        if (message.ttl != null && message.hasOwnProperty("ttl"))
                            if (typeof message.ttl === "number")
                                object.ttl = options.longs === String ? String(message.ttl) : message.ttl;
                            else
                                object.ttl = options.longs === String ? $util.Long.prototype.toString.call(message.ttl) : options.longs === Number ? new $util.LongBits(message.ttl.low >>> 0, message.ttl.high >>> 0).toNumber(true) : message.ttl;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Aeternity.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Aeternity.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [encoded] SigningOutput encoded
                     * @property {string|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Aeternity.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Aeternity.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {string} encoded
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = "";
    
                    /**
                     * SigningOutput signature.
                     * @member {string} signature
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {TW.Aeternity.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Aeternity.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Aeternity.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {TW.Aeternity.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.encoded);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Aeternity.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {TW.Aeternity.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Aeternity.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Aeternity.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.string();
                                break;
                            case 2:
                                message.signature = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Aeternity.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!$util.isString(message.encoded))
                                return "encoded: string expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!$util.isString(message.signature))
                                return "signature: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Aeternity.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Aeternity.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Aeternity.Proto.SigningOutput();
                        if (object.encoded != null)
                            message.encoded = String(object.encoded);
                        if (object.signature != null)
                            message.signature = String(object.signature);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @static
                     * @param {TW.Aeternity.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.encoded = "";
                            object.signature = "";
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = message.encoded;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Aeternity.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Aeternity;
        })();
    
        TW.Aion = (function() {
    
            /**
             * Namespace Aion.
             * @memberof TW
             * @namespace
             */
            var Aion = {};
    
            Aion.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Aion
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Aion.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [nonce] SigningInput nonce
                     * @property {Uint8Array|null} [gasPrice] SigningInput gasPrice
                     * @property {Uint8Array|null} [gasLimit] SigningInput gasLimit
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Uint8Array|null} [amount] SigningInput amount
                     * @property {Uint8Array|null} [payload] SigningInput payload
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Aion.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Aion.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput nonce.
                     * @member {Uint8Array} nonce
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasPrice.
                     * @member {Uint8Array} gasPrice
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Uint8Array} gasLimit
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.newBuffer([]);
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * SigningInput payload.
                     * @member {Uint8Array} payload
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.payload = $util.newBuffer([]);
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {TW.Aion.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Aion.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Aion.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {TW.Aion.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.gasPrice);
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.gasLimit);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.toAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.amount);
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payload);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Aion.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {TW.Aion.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Aion.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Aion.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.nonce = reader.bytes();
                                break;
                            case 2:
                                message.gasPrice = reader.bytes();
                                break;
                            case 3:
                                message.gasLimit = reader.bytes();
                                break;
                            case 4:
                                message.toAddress = reader.string();
                                break;
                            case 5:
                                message.amount = reader.bytes();
                                break;
                            case 6:
                                message.payload = reader.bytes();
                                break;
                            case 7:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Aion.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!(message.gasPrice && typeof message.gasPrice.length === "number" || $util.isString(message.gasPrice)))
                                return "gasPrice: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!(message.gasLimit && typeof message.gasLimit.length === "number" || $util.isString(message.gasLimit)))
                                return "gasLimit: buffer expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                return "payload: buffer expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Aion.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Aion.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Aion.Proto.SigningInput();
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        if (object.gasPrice != null)
                            if (typeof object.gasPrice === "string")
                                $util.base64.decode(object.gasPrice, message.gasPrice = $util.newBuffer($util.base64.length(object.gasPrice)), 0);
                            else if (object.gasPrice.length)
                                message.gasPrice = object.gasPrice;
                        if (object.gasLimit != null)
                            if (typeof object.gasLimit === "string")
                                $util.base64.decode(object.gasLimit, message.gasLimit = $util.newBuffer($util.base64.length(object.gasLimit)), 0);
                            else if (object.gasLimit.length)
                                message.gasLimit = object.gasLimit;
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        if (object.payload != null)
                            if (typeof object.payload === "string")
                                $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                            else if (object.payload.length)
                                message.payload = object.payload;
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Aion.Proto.SigningInput
                     * @static
                     * @param {TW.Aion.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            if (options.bytes === String)
                                object.gasPrice = "";
                            else {
                                object.gasPrice = [];
                                if (options.bytes !== Array)
                                    object.gasPrice = $util.newBuffer(object.gasPrice);
                            }
                            if (options.bytes === String)
                                object.gasLimit = "";
                            else {
                                object.gasLimit = [];
                                if (options.bytes !== Array)
                                    object.gasLimit = $util.newBuffer(object.gasLimit);
                            }
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                            if (options.bytes === String)
                                object.payload = "";
                            else {
                                object.payload = [];
                                if (options.bytes !== Array)
                                    object.payload = $util.newBuffer(object.payload);
                            }
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = options.bytes === String ? $util.base64.encode(message.gasPrice, 0, message.gasPrice.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPrice) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            object.gasLimit = options.bytes === String ? $util.base64.encode(message.gasLimit, 0, message.gasLimit.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasLimit) : message.gasLimit;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Aion.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Aion.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Aion.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Aion.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {TW.Aion.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Aion.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Aion.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {TW.Aion.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Aion.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {TW.Aion.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Aion.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Aion.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Aion.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Aion.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Aion.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Aion.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @static
                     * @param {TW.Aion.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Aion.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Aion;
        })();
    
        TW.Any = (function() {
    
            /**
             * Namespace Any.
             * @memberof TW
             * @namespace
             */
            var Any = {};
    
            Any.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Any
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Any.Proto
                     * @interface ISigningInput
                     * @property {number|null} [coinType] SigningInput coinType
                     * @property {string|null} [transaction] SigningInput transaction
                     * @property {string|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Any.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Any.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput coinType.
                     * @member {number} coinType
                     * @memberof TW.Any.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.coinType = 0;
    
                    /**
                     * SigningInput transaction.
                     * @member {string} transaction
                     * @memberof TW.Any.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transaction = "";
    
                    /**
                     * SigningInput privateKey.
                     * @member {string} privateKey
                     * @memberof TW.Any.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = "";
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Any.Proto.SigningInput
                     * @static
                     * @param {TW.Any.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Any.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Any.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Any.Proto.SigningInput
                     * @static
                     * @param {TW.Any.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.coinType != null && message.hasOwnProperty("coinType"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.coinType);
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.transaction);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Any.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Any.Proto.SigningInput
                     * @static
                     * @param {TW.Any.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Any.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Any.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Any.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.coinType = reader.uint32();
                                break;
                            case 2:
                                message.transaction = reader.string();
                                break;
                            case 3:
                                message.privateKey = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Any.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Any.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Any.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.coinType != null && message.hasOwnProperty("coinType"))
                            if (!$util.isInteger(message.coinType))
                                return "coinType: integer expected";
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            if (!$util.isString(message.transaction))
                                return "transaction: string expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!$util.isString(message.privateKey))
                                return "privateKey: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Any.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Any.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Any.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Any.Proto.SigningInput();
                        if (object.coinType != null)
                            message.coinType = object.coinType >>> 0;
                        if (object.transaction != null)
                            message.transaction = String(object.transaction);
                        if (object.privateKey != null)
                            message.privateKey = String(object.privateKey);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Any.Proto.SigningInput
                     * @static
                     * @param {TW.Any.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.coinType = 0;
                            object.transaction = "";
                            object.privateKey = "";
                        }
                        if (message.coinType != null && message.hasOwnProperty("coinType"))
                            object.coinType = message.coinType;
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            object.transaction = message.transaction;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Any.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Any.Proto
                     * @interface ISigningOutput
                     * @property {TW.Any.Proto.SigningOutput.IError|null} [error] SigningOutput error
                     * @property {boolean|null} [success] SigningOutput success
                     * @property {string|null} [output] SigningOutput output
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Any.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Any.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput error.
                     * @member {TW.Any.Proto.SigningOutput.IError|null|undefined} error
                     * @memberof TW.Any.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.error = null;
    
                    /**
                     * SigningOutput success.
                     * @member {boolean} success
                     * @memberof TW.Any.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.success = false;
    
                    /**
                     * SigningOutput output.
                     * @member {string} output
                     * @memberof TW.Any.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.output = "";
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningOutput result.
                     * @member {"error"|"success"|undefined} result
                     * @memberof TW.Any.Proto.SigningOutput
                     * @instance
                     */
                    Object.defineProperty(SigningOutput.prototype, "result", {
                        get: $util.oneOfGetter($oneOfFields = ["error", "success"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Any.Proto.SigningOutput
                     * @static
                     * @param {TW.Any.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Any.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Any.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Any.Proto.SigningOutput
                     * @static
                     * @param {TW.Any.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.TW.Any.Proto.SigningOutput.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.success != null && message.hasOwnProperty("success"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.success);
                        if (message.output != null && message.hasOwnProperty("output"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.output);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Any.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Any.Proto.SigningOutput
                     * @static
                     * @param {TW.Any.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Any.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Any.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Any.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.TW.Any.Proto.SigningOutput.Error.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.success = reader.bool();
                                break;
                            case 4:
                                message.output = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Any.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Any.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Any.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.error != null && message.hasOwnProperty("error")) {
                            properties.result = 1;
                            {
                                var error = $root.TW.Any.Proto.SigningOutput.Error.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                        }
                        if (message.success != null && message.hasOwnProperty("success")) {
                            if (properties.result === 1)
                                return "result: multiple values";
                            properties.result = 1;
                            if (typeof message.success !== "boolean")
                                return "success: boolean expected";
                        }
                        if (message.output != null && message.hasOwnProperty("output"))
                            if (!$util.isString(message.output))
                                return "output: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Any.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Any.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Any.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Any.Proto.SigningOutput();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".TW.Any.Proto.SigningOutput.error: object expected");
                            message.error = $root.TW.Any.Proto.SigningOutput.Error.fromObject(object.error);
                        }
                        if (object.success != null)
                            message.success = Boolean(object.success);
                        if (object.output != null)
                            message.output = String(object.output);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Any.Proto.SigningOutput
                     * @static
                     * @param {TW.Any.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.output = "";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            object.error = $root.TW.Any.Proto.SigningOutput.Error.toObject(message.error, options);
                            if (options.oneofs)
                                object.result = "error";
                        }
                        if (message.success != null && message.hasOwnProperty("success")) {
                            object.success = message.success;
                            if (options.oneofs)
                                object.result = "success";
                        }
                        if (message.output != null && message.hasOwnProperty("output"))
                            object.output = message.output;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Any.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    SigningOutput.Error = (function() {
    
                        /**
                         * Properties of an Error.
                         * @memberof TW.Any.Proto.SigningOutput
                         * @interface IError
                         * @property {number|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */
    
                        /**
                         * Constructs a new Error.
                         * @memberof TW.Any.Proto.SigningOutput
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {TW.Any.Proto.SigningOutput.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Error code.
                         * @member {number} code
                         * @memberof TW.Any.Proto.SigningOutput.Error
                         * @instance
                         */
                        Error.prototype.code = 0;
    
                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof TW.Any.Proto.SigningOutput.Error
                         * @instance
                         */
                        Error.prototype.description = "";
    
                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof TW.Any.Proto.SigningOutput.Error
                         * @static
                         * @param {TW.Any.Proto.SigningOutput.IError=} [properties] Properties to set
                         * @returns {TW.Any.Proto.SigningOutput.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };
    
                        /**
                         * Encodes the specified Error message. Does not implicitly {@link TW.Any.Proto.SigningOutput.Error.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Any.Proto.SigningOutput.Error
                         * @static
                         * @param {TW.Any.Proto.SigningOutput.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };
    
                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link TW.Any.Proto.SigningOutput.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof TW.Any.Proto.SigningOutput.Error
                         * @static
                         * @param {TW.Any.Proto.SigningOutput.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
    
                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Any.Proto.SigningOutput.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Any.Proto.SigningOutput.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Any.Proto.SigningOutput.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.uint32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof TW.Any.Proto.SigningOutput.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {TW.Any.Proto.SigningOutput.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
    
                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof TW.Any.Proto.SigningOutput.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                if (!$util.isInteger(message.code))
                                    return "code: integer expected";
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };
    
                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Any.Proto.SigningOutput.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Any.Proto.SigningOutput.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Any.Proto.SigningOutput.Error)
                                return object;
                            var message = new $root.TW.Any.Proto.SigningOutput.Error();
                            if (object.code != null)
                                message.code = object.code >>> 0;
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Any.Proto.SigningOutput.Error
                         * @static
                         * @param {TW.Any.Proto.SigningOutput.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };
    
                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof TW.Any.Proto.SigningOutput.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Error;
                    })();
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Any;
        })();
    
        TW.Binance = (function() {
    
            /**
             * Namespace Binance.
             * @memberof TW
             * @namespace
             */
            var Binance = {};
    
            Binance.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Binance
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.Binance.Proto
                     * @interface ITransaction
                     * @property {Array.<Uint8Array>|null} [msgs] Transaction msgs
                     * @property {Array.<Uint8Array>|null} [signatures] Transaction signatures
                     * @property {string|null} [memo] Transaction memo
                     * @property {Long|null} [source] Transaction source
                     * @property {Uint8Array|null} [data] Transaction data
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.Binance.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        this.msgs = [];
                        this.signatures = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction msgs.
                     * @member {Array.<Uint8Array>} msgs
                     * @memberof TW.Binance.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.msgs = $util.emptyArray;
    
                    /**
                     * Transaction signatures.
                     * @member {Array.<Uint8Array>} signatures
                     * @memberof TW.Binance.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.signatures = $util.emptyArray;
    
                    /**
                     * Transaction memo.
                     * @member {string} memo
                     * @memberof TW.Binance.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.memo = "";
    
                    /**
                     * Transaction source.
                     * @member {Long} source
                     * @memberof TW.Binance.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.source = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Transaction data.
                     * @member {Uint8Array} data
                     * @memberof TW.Binance.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.data = $util.newBuffer([]);
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {TW.Binance.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.Binance.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {TW.Binance.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.msgs != null && message.msgs.length)
                            for (var i = 0; i < message.msgs.length; ++i)
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.msgs[i]);
                        if (message.signatures != null && message.signatures.length)
                            for (var i = 0; i < message.signatures.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signatures[i]);
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.memo);
                        if (message.source != null && message.hasOwnProperty("source"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.source);
                        if (message.data != null && message.hasOwnProperty("data"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.data);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Transaction message, length delimited. Does not implicitly {@link TW.Binance.Proto.Transaction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {TW.Binance.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.msgs && message.msgs.length))
                                    message.msgs = [];
                                message.msgs.push(reader.bytes());
                                break;
                            case 2:
                                if (!(message.signatures && message.signatures.length))
                                    message.signatures = [];
                                message.signatures.push(reader.bytes());
                                break;
                            case 3:
                                message.memo = reader.string();
                                break;
                            case 4:
                                message.source = reader.int64();
                                break;
                            case 5:
                                message.data = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Binance.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.msgs != null && message.hasOwnProperty("msgs")) {
                            if (!Array.isArray(message.msgs))
                                return "msgs: array expected";
                            for (var i = 0; i < message.msgs.length; ++i)
                                if (!(message.msgs[i] && typeof message.msgs[i].length === "number" || $util.isString(message.msgs[i])))
                                    return "msgs: buffer[] expected";
                        }
                        if (message.signatures != null && message.hasOwnProperty("signatures")) {
                            if (!Array.isArray(message.signatures))
                                return "signatures: array expected";
                            for (var i = 0; i < message.signatures.length; ++i)
                                if (!(message.signatures[i] && typeof message.signatures[i].length === "number" || $util.isString(message.signatures[i])))
                                    return "signatures: buffer[] expected";
                        }
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.source != null && message.hasOwnProperty("source"))
                            if (!$util.isInteger(message.source) && !(message.source && $util.isInteger(message.source.low) && $util.isInteger(message.source.high)))
                                return "source: integer|Long expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                return "data: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.Transaction)
                            return object;
                        var message = new $root.TW.Binance.Proto.Transaction();
                        if (object.msgs) {
                            if (!Array.isArray(object.msgs))
                                throw TypeError(".TW.Binance.Proto.Transaction.msgs: array expected");
                            message.msgs = [];
                            for (var i = 0; i < object.msgs.length; ++i)
                                if (typeof object.msgs[i] === "string")
                                    $util.base64.decode(object.msgs[i], message.msgs[i] = $util.newBuffer($util.base64.length(object.msgs[i])), 0);
                                else if (object.msgs[i].length)
                                    message.msgs[i] = object.msgs[i];
                        }
                        if (object.signatures) {
                            if (!Array.isArray(object.signatures))
                                throw TypeError(".TW.Binance.Proto.Transaction.signatures: array expected");
                            message.signatures = [];
                            for (var i = 0; i < object.signatures.length; ++i)
                                if (typeof object.signatures[i] === "string")
                                    $util.base64.decode(object.signatures[i], message.signatures[i] = $util.newBuffer($util.base64.length(object.signatures[i])), 0);
                                else if (object.signatures[i].length)
                                    message.signatures[i] = object.signatures[i];
                        }
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.source != null)
                            if ($util.Long)
                                (message.source = $util.Long.fromValue(object.source)).unsigned = false;
                            else if (typeof object.source === "string")
                                message.source = parseInt(object.source, 10);
                            else if (typeof object.source === "number")
                                message.source = object.source;
                            else if (typeof object.source === "object")
                                message.source = new $util.LongBits(object.source.low >>> 0, object.source.high >>> 0).toNumber();
                        if (object.data != null)
                            if (typeof object.data === "string")
                                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                            else if (object.data.length)
                                message.data = object.data;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.Transaction
                     * @static
                     * @param {TW.Binance.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.msgs = [];
                            object.signatures = [];
                        }
                        if (options.defaults) {
                            object.memo = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.source = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.source = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.data = "";
                            else {
                                object.data = [];
                                if (options.bytes !== Array)
                                    object.data = $util.newBuffer(object.data);
                            }
                        }
                        if (message.msgs && message.msgs.length) {
                            object.msgs = [];
                            for (var j = 0; j < message.msgs.length; ++j)
                                object.msgs[j] = options.bytes === String ? $util.base64.encode(message.msgs[j], 0, message.msgs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.msgs[j]) : message.msgs[j];
                        }
                        if (message.signatures && message.signatures.length) {
                            object.signatures = [];
                            for (var j = 0; j < message.signatures.length; ++j)
                                object.signatures[j] = options.bytes === String ? $util.base64.encode(message.signatures[j], 0, message.signatures[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.signatures[j]) : message.signatures[j];
                        }
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.source != null && message.hasOwnProperty("source"))
                            if (typeof message.source === "number")
                                object.source = options.longs === String ? String(message.source) : message.source;
                            else
                                object.source = options.longs === String ? $util.Long.prototype.toString.call(message.source) : options.longs === Number ? new $util.LongBits(message.source.low >>> 0, message.source.high >>> 0).toNumber() : message.source;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.Signature = (function() {
    
                    /**
                     * Properties of a Signature.
                     * @memberof TW.Binance.Proto
                     * @interface ISignature
                     * @property {Uint8Array|null} [pubKey] Signature pubKey
                     * @property {Uint8Array|null} [signature] Signature signature
                     * @property {Long|null} [accountNumber] Signature accountNumber
                     * @property {Long|null} [sequence] Signature sequence
                     */
    
                    /**
                     * Constructs a new Signature.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a Signature.
                     * @implements ISignature
                     * @constructor
                     * @param {TW.Binance.Proto.ISignature=} [properties] Properties to set
                     */
                    function Signature(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Signature pubKey.
                     * @member {Uint8Array} pubKey
                     * @memberof TW.Binance.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.pubKey = $util.newBuffer([]);
    
                    /**
                     * Signature signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Binance.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Signature accountNumber.
                     * @member {Long} accountNumber
                     * @memberof TW.Binance.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.accountNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Signature sequence.
                     * @member {Long} sequence
                     * @memberof TW.Binance.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new Signature instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {TW.Binance.Proto.ISignature=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.Signature} Signature instance
                     */
                    Signature.create = function create(properties) {
                        return new Signature(properties);
                    };
    
                    /**
                     * Encodes the specified Signature message. Does not implicitly {@link TW.Binance.Proto.Signature.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {TW.Binance.Proto.ISignature} message Signature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Signature.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pubKey);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.accountNumber);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.sequence);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Signature message, length delimited. Does not implicitly {@link TW.Binance.Proto.Signature.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {TW.Binance.Proto.ISignature} message Signature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Signature.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Signature message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.Signature} Signature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Signature.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.Signature();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.pubKey = reader.bytes();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            case 3:
                                message.accountNumber = reader.int64();
                                break;
                            case 4:
                                message.sequence = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Signature message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Binance.Proto.Signature} Signature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Signature.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Signature message.
                     * @function verify
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Signature.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                            if (!(message.pubKey && typeof message.pubKey.length === "number" || $util.isString(message.pubKey)))
                                return "pubKey: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (!$util.isInteger(message.accountNumber) && !(message.accountNumber && $util.isInteger(message.accountNumber.low) && $util.isInteger(message.accountNumber.high)))
                                return "accountNumber: integer|Long expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                                return "sequence: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a Signature message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.Signature} Signature
                     */
                    Signature.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.Signature)
                            return object;
                        var message = new $root.TW.Binance.Proto.Signature();
                        if (object.pubKey != null)
                            if (typeof object.pubKey === "string")
                                $util.base64.decode(object.pubKey, message.pubKey = $util.newBuffer($util.base64.length(object.pubKey)), 0);
                            else if (object.pubKey.length)
                                message.pubKey = object.pubKey;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.accountNumber != null)
                            if ($util.Long)
                                (message.accountNumber = $util.Long.fromValue(object.accountNumber)).unsigned = false;
                            else if (typeof object.accountNumber === "string")
                                message.accountNumber = parseInt(object.accountNumber, 10);
                            else if (typeof object.accountNumber === "number")
                                message.accountNumber = object.accountNumber;
                            else if (typeof object.accountNumber === "object")
                                message.accountNumber = new $util.LongBits(object.accountNumber.low >>> 0, object.accountNumber.high >>> 0).toNumber();
                        if (object.sequence != null)
                            if ($util.Long)
                                (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                            else if (typeof object.sequence === "string")
                                message.sequence = parseInt(object.sequence, 10);
                            else if (typeof object.sequence === "number")
                                message.sequence = object.sequence;
                            else if (typeof object.sequence === "object")
                                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Signature message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.Signature
                     * @static
                     * @param {TW.Binance.Proto.Signature} message Signature
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Signature.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.pubKey = "";
                            else {
                                object.pubKey = [];
                                if (options.bytes !== Array)
                                    object.pubKey = $util.newBuffer(object.pubKey);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.accountNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.accountNumber = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sequence = options.longs === String ? "0" : 0;
                        }
                        if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                            object.pubKey = options.bytes === String ? $util.base64.encode(message.pubKey, 0, message.pubKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKey) : message.pubKey;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (typeof message.accountNumber === "number")
                                object.accountNumber = options.longs === String ? String(message.accountNumber) : message.accountNumber;
                            else
                                object.accountNumber = options.longs === String ? $util.Long.prototype.toString.call(message.accountNumber) : options.longs === Number ? new $util.LongBits(message.accountNumber.low >>> 0, message.accountNumber.high >>> 0).toNumber() : message.accountNumber;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (typeof message.sequence === "number")
                                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                            else
                                object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                        return object;
                    };
    
                    /**
                     * Converts this Signature to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.Signature
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Signature.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    Signature.PubKey = (function() {
    
                        /**
                         * Properties of a PubKey.
                         * @memberof TW.Binance.Proto.Signature
                         * @interface IPubKey
                         */
    
                        /**
                         * Constructs a new PubKey.
                         * @memberof TW.Binance.Proto.Signature
                         * @classdesc Represents a PubKey.
                         * @implements IPubKey
                         * @constructor
                         * @param {TW.Binance.Proto.Signature.IPubKey=} [properties] Properties to set
                         */
                        function PubKey(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Creates a new PubKey instance using the specified properties.
                         * @function create
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {TW.Binance.Proto.Signature.IPubKey=} [properties] Properties to set
                         * @returns {TW.Binance.Proto.Signature.PubKey} PubKey instance
                         */
                        PubKey.create = function create(properties) {
                            return new PubKey(properties);
                        };
    
                        /**
                         * Encodes the specified PubKey message. Does not implicitly {@link TW.Binance.Proto.Signature.PubKey.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {TW.Binance.Proto.Signature.IPubKey} message PubKey message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PubKey.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };
    
                        /**
                         * Encodes the specified PubKey message, length delimited. Does not implicitly {@link TW.Binance.Proto.Signature.PubKey.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {TW.Binance.Proto.Signature.IPubKey} message PubKey message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PubKey.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
    
                        /**
                         * Decodes a PubKey message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Binance.Proto.Signature.PubKey} PubKey
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PubKey.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.Signature.PubKey();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Decodes a PubKey message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {TW.Binance.Proto.Signature.PubKey} PubKey
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PubKey.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
    
                        /**
                         * Verifies a PubKey message.
                         * @function verify
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PubKey.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };
    
                        /**
                         * Creates a PubKey message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Binance.Proto.Signature.PubKey} PubKey
                         */
                        PubKey.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Binance.Proto.Signature.PubKey)
                                return object;
                            return new $root.TW.Binance.Proto.Signature.PubKey();
                        };
    
                        /**
                         * Creates a plain object from a PubKey message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @static
                         * @param {TW.Binance.Proto.Signature.PubKey} message PubKey
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PubKey.toObject = function toObject() {
                            return {};
                        };
    
                        /**
                         * Converts this PubKey to JSON.
                         * @function toJSON
                         * @memberof TW.Binance.Proto.Signature.PubKey
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PubKey.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return PubKey;
                    })();
    
                    return Signature;
                })();
    
                Proto.TradeOrder = (function() {
    
                    /**
                     * Properties of a TradeOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ITradeOrder
                     * @property {Uint8Array|null} [sender] TradeOrder sender
                     * @property {string|null} [id] TradeOrder id
                     * @property {string|null} [symbol] TradeOrder symbol
                     * @property {Long|null} [ordertype] TradeOrder ordertype
                     * @property {Long|null} [side] TradeOrder side
                     * @property {Long|null} [price] TradeOrder price
                     * @property {Long|null} [quantity] TradeOrder quantity
                     * @property {Long|null} [timeinforce] TradeOrder timeinforce
                     */
    
                    /**
                     * Constructs a new TradeOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TradeOrder.
                     * @implements ITradeOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ITradeOrder=} [properties] Properties to set
                     */
                    function TradeOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TradeOrder sender.
                     * @member {Uint8Array} sender
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.sender = $util.newBuffer([]);
    
                    /**
                     * TradeOrder id.
                     * @member {string} id
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.id = "";
    
                    /**
                     * TradeOrder symbol.
                     * @member {string} symbol
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.symbol = "";
    
                    /**
                     * TradeOrder ordertype.
                     * @member {Long} ordertype
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.ordertype = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TradeOrder side.
                     * @member {Long} side
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.side = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TradeOrder price.
                     * @member {Long} price
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.price = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TradeOrder quantity.
                     * @member {Long} quantity
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.quantity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TradeOrder timeinforce.
                     * @member {Long} timeinforce
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     */
                    TradeOrder.prototype.timeinforce = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TradeOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITradeOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TradeOrder} TradeOrder instance
                     */
                    TradeOrder.create = function create(properties) {
                        return new TradeOrder(properties);
                    };
    
                    /**
                     * Encodes the specified TradeOrder message. Does not implicitly {@link TW.Binance.Proto.TradeOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITradeOrder} message TradeOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TradeOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sender);
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.symbol);
                        if (message.ordertype != null && message.hasOwnProperty("ordertype"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.ordertype);
                        if (message.side != null && message.hasOwnProperty("side"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.side);
                        if (message.price != null && message.hasOwnProperty("price"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.price);
                        if (message.quantity != null && message.hasOwnProperty("quantity"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.quantity);
                        if (message.timeinforce != null && message.hasOwnProperty("timeinforce"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.timeinforce);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TradeOrder message, length delimited. Does not implicitly {@link TW.Binance.Proto.TradeOrder.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITradeOrder} message TradeOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TradeOrder.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TradeOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TradeOrder} TradeOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TradeOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TradeOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.sender = reader.bytes();
                                break;
                            case 2:
                                message.id = reader.string();
                                break;
                            case 3:
                                message.symbol = reader.string();
                                break;
                            case 4:
                                message.ordertype = reader.int64();
                                break;
                            case 5:
                                message.side = reader.int64();
                                break;
                            case 6:
                                message.price = reader.int64();
                                break;
                            case 7:
                                message.quantity = reader.int64();
                                break;
                            case 8:
                                message.timeinforce = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TradeOrder message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Binance.Proto.TradeOrder} TradeOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TradeOrder.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TradeOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TradeOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            if (!(message.sender && typeof message.sender.length === "number" || $util.isString(message.sender)))
                                return "sender: buffer expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        if (message.ordertype != null && message.hasOwnProperty("ordertype"))
                            if (!$util.isInteger(message.ordertype) && !(message.ordertype && $util.isInteger(message.ordertype.low) && $util.isInteger(message.ordertype.high)))
                                return "ordertype: integer|Long expected";
                        if (message.side != null && message.hasOwnProperty("side"))
                            if (!$util.isInteger(message.side) && !(message.side && $util.isInteger(message.side.low) && $util.isInteger(message.side.high)))
                                return "side: integer|Long expected";
                        if (message.price != null && message.hasOwnProperty("price"))
                            if (!$util.isInteger(message.price) && !(message.price && $util.isInteger(message.price.low) && $util.isInteger(message.price.high)))
                                return "price: integer|Long expected";
                        if (message.quantity != null && message.hasOwnProperty("quantity"))
                            if (!$util.isInteger(message.quantity) && !(message.quantity && $util.isInteger(message.quantity.low) && $util.isInteger(message.quantity.high)))
                                return "quantity: integer|Long expected";
                        if (message.timeinforce != null && message.hasOwnProperty("timeinforce"))
                            if (!$util.isInteger(message.timeinforce) && !(message.timeinforce && $util.isInteger(message.timeinforce.low) && $util.isInteger(message.timeinforce.high)))
                                return "timeinforce: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TradeOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TradeOrder} TradeOrder
                     */
                    TradeOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TradeOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.TradeOrder();
                        if (object.sender != null)
                            if (typeof object.sender === "string")
                                $util.base64.decode(object.sender, message.sender = $util.newBuffer($util.base64.length(object.sender)), 0);
                            else if (object.sender.length)
                                message.sender = object.sender;
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        if (object.ordertype != null)
                            if ($util.Long)
                                (message.ordertype = $util.Long.fromValue(object.ordertype)).unsigned = false;
                            else if (typeof object.ordertype === "string")
                                message.ordertype = parseInt(object.ordertype, 10);
                            else if (typeof object.ordertype === "number")
                                message.ordertype = object.ordertype;
                            else if (typeof object.ordertype === "object")
                                message.ordertype = new $util.LongBits(object.ordertype.low >>> 0, object.ordertype.high >>> 0).toNumber();
                        if (object.side != null)
                            if ($util.Long)
                                (message.side = $util.Long.fromValue(object.side)).unsigned = false;
                            else if (typeof object.side === "string")
                                message.side = parseInt(object.side, 10);
                            else if (typeof object.side === "number")
                                message.side = object.side;
                            else if (typeof object.side === "object")
                                message.side = new $util.LongBits(object.side.low >>> 0, object.side.high >>> 0).toNumber();
                        if (object.price != null)
                            if ($util.Long)
                                (message.price = $util.Long.fromValue(object.price)).unsigned = false;
                            else if (typeof object.price === "string")
                                message.price = parseInt(object.price, 10);
                            else if (typeof object.price === "number")
                                message.price = object.price;
                            else if (typeof object.price === "object")
                                message.price = new $util.LongBits(object.price.low >>> 0, object.price.high >>> 0).toNumber();
                        if (object.quantity != null)
                            if ($util.Long)
                                (message.quantity = $util.Long.fromValue(object.quantity)).unsigned = false;
                            else if (typeof object.quantity === "string")
                                message.quantity = parseInt(object.quantity, 10);
                            else if (typeof object.quantity === "number")
                                message.quantity = object.quantity;
                            else if (typeof object.quantity === "object")
                                message.quantity = new $util.LongBits(object.quantity.low >>> 0, object.quantity.high >>> 0).toNumber();
                        if (object.timeinforce != null)
                            if ($util.Long)
                                (message.timeinforce = $util.Long.fromValue(object.timeinforce)).unsigned = false;
                            else if (typeof object.timeinforce === "string")
                                message.timeinforce = parseInt(object.timeinforce, 10);
                            else if (typeof object.timeinforce === "number")
                                message.timeinforce = object.timeinforce;
                            else if (typeof object.timeinforce === "object")
                                message.timeinforce = new $util.LongBits(object.timeinforce.low >>> 0, object.timeinforce.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TradeOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @static
                     * @param {TW.Binance.Proto.TradeOrder} message TradeOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TradeOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.sender = "";
                            else {
                                object.sender = [];
                                if (options.bytes !== Array)
                                    object.sender = $util.newBuffer(object.sender);
                            }
                            object.id = "";
                            object.symbol = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.ordertype = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.ordertype = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.side = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.side = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.price = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.price = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.quantity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.quantity = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timeinforce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timeinforce = options.longs === String ? "0" : 0;
                        }
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            object.sender = options.bytes === String ? $util.base64.encode(message.sender, 0, message.sender.length) : options.bytes === Array ? Array.prototype.slice.call(message.sender) : message.sender;
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        if (message.ordertype != null && message.hasOwnProperty("ordertype"))
                            if (typeof message.ordertype === "number")
                                object.ordertype = options.longs === String ? String(message.ordertype) : message.ordertype;
                            else
                                object.ordertype = options.longs === String ? $util.Long.prototype.toString.call(message.ordertype) : options.longs === Number ? new $util.LongBits(message.ordertype.low >>> 0, message.ordertype.high >>> 0).toNumber() : message.ordertype;
                        if (message.side != null && message.hasOwnProperty("side"))
                            if (typeof message.side === "number")
                                object.side = options.longs === String ? String(message.side) : message.side;
                            else
                                object.side = options.longs === String ? $util.Long.prototype.toString.call(message.side) : options.longs === Number ? new $util.LongBits(message.side.low >>> 0, message.side.high >>> 0).toNumber() : message.side;
                        if (message.price != null && message.hasOwnProperty("price"))
                            if (typeof message.price === "number")
                                object.price = options.longs === String ? String(message.price) : message.price;
                            else
                                object.price = options.longs === String ? $util.Long.prototype.toString.call(message.price) : options.longs === Number ? new $util.LongBits(message.price.low >>> 0, message.price.high >>> 0).toNumber() : message.price;
                        if (message.quantity != null && message.hasOwnProperty("quantity"))
                            if (typeof message.quantity === "number")
                                object.quantity = options.longs === String ? String(message.quantity) : message.quantity;
                            else
                                object.quantity = options.longs === String ? $util.Long.prototype.toString.call(message.quantity) : options.longs === Number ? new $util.LongBits(message.quantity.low >>> 0, message.quantity.high >>> 0).toNumber() : message.quantity;
                        if (message.timeinforce != null && message.hasOwnProperty("timeinforce"))
                            if (typeof message.timeinforce === "number")
                                object.timeinforce = options.longs === String ? String(message.timeinforce) : message.timeinforce;
                            else
                                object.timeinforce = options.longs === String ? $util.Long.prototype.toString.call(message.timeinforce) : options.longs === Number ? new $util.LongBits(message.timeinforce.low >>> 0, message.timeinforce.high >>> 0).toNumber() : message.timeinforce;
                        return object;
                    };
    
                    /**
                     * Converts this TradeOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TradeOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TradeOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TradeOrder;
                })();
    
                Proto.CancelTradeOrder = (function() {
    
                    /**
                     * Properties of a CancelTradeOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ICancelTradeOrder
                     * @property {Uint8Array|null} [sender] CancelTradeOrder sender
                     * @property {string|null} [symbol] CancelTradeOrder symbol
                     * @property {string|null} [refid] CancelTradeOrder refid
                     */
    
                    /**
                     * Constructs a new CancelTradeOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a CancelTradeOrder.
                     * @implements ICancelTradeOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ICancelTradeOrder=} [properties] Properties to set
                     */
                    function CancelTradeOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * CancelTradeOrder sender.
                     * @member {Uint8Array} sender
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @instance
                     */
                    CancelTradeOrder.prototype.sender = $util.newBuffer([]);
    
                    /**
                     * CancelTradeOrder symbol.
                     * @member {string} symbol
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @instance
                     */
                    CancelTradeOrder.prototype.symbol = "";
    
                    /**
                     * CancelTradeOrder refid.
                     * @member {string} refid
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @instance
                     */
                    CancelTradeOrder.prototype.refid = "";
    
                    /**
                     * Creates a new CancelTradeOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {TW.Binance.Proto.ICancelTradeOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.CancelTradeOrder} CancelTradeOrder instance
                     */
                    CancelTradeOrder.create = function create(properties) {
                        return new CancelTradeOrder(properties);
                    };
    
                    /**
                     * Encodes the specified CancelTradeOrder message. Does not implicitly {@link TW.Binance.Proto.CancelTradeOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {TW.Binance.Proto.ICancelTradeOrder} message CancelTradeOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CancelTradeOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sender);
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbol);
                        if (message.refid != null && message.hasOwnProperty("refid"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.refid);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified CancelTradeOrder message, length delimited. Does not implicitly {@link TW.Binance.Proto.CancelTradeOrder.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {TW.Binance.Proto.ICancelTradeOrder} message CancelTradeOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CancelTradeOrder.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a CancelTradeOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.CancelTradeOrder} CancelTradeOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CancelTradeOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.CancelTradeOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.sender = reader.bytes();
                                break;
                            case 2:
                                message.symbol = reader.string();
                                break;
                            case 3:
                                message.refid = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a CancelTradeOrder message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Binance.Proto.CancelTradeOrder} CancelTradeOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CancelTradeOrder.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a CancelTradeOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CancelTradeOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            if (!(message.sender && typeof message.sender.length === "number" || $util.isString(message.sender)))
                                return "sender: buffer expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        if (message.refid != null && message.hasOwnProperty("refid"))
                            if (!$util.isString(message.refid))
                                return "refid: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a CancelTradeOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.CancelTradeOrder} CancelTradeOrder
                     */
                    CancelTradeOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.CancelTradeOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.CancelTradeOrder();
                        if (object.sender != null)
                            if (typeof object.sender === "string")
                                $util.base64.decode(object.sender, message.sender = $util.newBuffer($util.base64.length(object.sender)), 0);
                            else if (object.sender.length)
                                message.sender = object.sender;
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        if (object.refid != null)
                            message.refid = String(object.refid);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a CancelTradeOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @static
                     * @param {TW.Binance.Proto.CancelTradeOrder} message CancelTradeOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CancelTradeOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.sender = "";
                            else {
                                object.sender = [];
                                if (options.bytes !== Array)
                                    object.sender = $util.newBuffer(object.sender);
                            }
                            object.symbol = "";
                            object.refid = "";
                        }
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            object.sender = options.bytes === String ? $util.base64.encode(message.sender, 0, message.sender.length) : options.bytes === Array ? Array.prototype.slice.call(message.sender) : message.sender;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        if (message.refid != null && message.hasOwnProperty("refid"))
                            object.refid = message.refid;
                        return object;
                    };
    
                    /**
                     * Converts this CancelTradeOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.CancelTradeOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CancelTradeOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return CancelTradeOrder;
                })();
    
                Proto.SendOrder = (function() {
    
                    /**
                     * Properties of a SendOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ISendOrder
                     * @property {Array.<TW.Binance.Proto.SendOrder.IInput>|null} [inputs] SendOrder inputs
                     * @property {Array.<TW.Binance.Proto.SendOrder.IOutput>|null} [outputs] SendOrder outputs
                     */
    
                    /**
                     * Constructs a new SendOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a SendOrder.
                     * @implements ISendOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ISendOrder=} [properties] Properties to set
                     */
                    function SendOrder(properties) {
                        this.inputs = [];
                        this.outputs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SendOrder inputs.
                     * @member {Array.<TW.Binance.Proto.SendOrder.IInput>} inputs
                     * @memberof TW.Binance.Proto.SendOrder
                     * @instance
                     */
                    SendOrder.prototype.inputs = $util.emptyArray;
    
                    /**
                     * SendOrder outputs.
                     * @member {Array.<TW.Binance.Proto.SendOrder.IOutput>} outputs
                     * @memberof TW.Binance.Proto.SendOrder
                     * @instance
                     */
                    SendOrder.prototype.outputs = $util.emptyArray;
    
                    /**
                     * Creates a new SendOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {TW.Binance.Proto.ISendOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.SendOrder} SendOrder instance
                     */
                    SendOrder.create = function create(properties) {
                        return new SendOrder(properties);
                    };
    
                    /**
                     * Encodes the specified SendOrder message. Does not implicitly {@link TW.Binance.Proto.SendOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {TW.Binance.Proto.ISendOrder} message SendOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SendOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.inputs != null && message.inputs.length)
                            for (var i = 0; i < message.inputs.length; ++i)
                                $root.TW.Binance.Proto.SendOrder.Input.encode(message.inputs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.outputs != null && message.outputs.length)
                            for (var i = 0; i < message.outputs.length; ++i)
                                $root.TW.Binance.Proto.SendOrder.Output.encode(message.outputs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SendOrder message, length delimited. Does not implicitly {@link TW.Binance.Proto.SendOrder.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {TW.Binance.Proto.ISendOrder} message SendOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SendOrder.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SendOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.SendOrder} SendOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SendOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SendOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.inputs && message.inputs.length))
                                    message.inputs = [];
                                message.inputs.push($root.TW.Binance.Proto.SendOrder.Input.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                if (!(message.outputs && message.outputs.length))
                                    message.outputs = [];
                                message.outputs.push($root.TW.Binance.Proto.SendOrder.Output.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SendOrder message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Binance.Proto.SendOrder} SendOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SendOrder.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SendOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SendOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.inputs != null && message.hasOwnProperty("inputs")) {
                            if (!Array.isArray(message.inputs))
                                return "inputs: array expected";
                            for (var i = 0; i < message.inputs.length; ++i) {
                                var error = $root.TW.Binance.Proto.SendOrder.Input.verify(message.inputs[i]);
                                if (error)
                                    return "inputs." + error;
                            }
                        }
                        if (message.outputs != null && message.hasOwnProperty("outputs")) {
                            if (!Array.isArray(message.outputs))
                                return "outputs: array expected";
                            for (var i = 0; i < message.outputs.length; ++i) {
                                var error = $root.TW.Binance.Proto.SendOrder.Output.verify(message.outputs[i]);
                                if (error)
                                    return "outputs." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SendOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.SendOrder} SendOrder
                     */
                    SendOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.SendOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.SendOrder();
                        if (object.inputs) {
                            if (!Array.isArray(object.inputs))
                                throw TypeError(".TW.Binance.Proto.SendOrder.inputs: array expected");
                            message.inputs = [];
                            for (var i = 0; i < object.inputs.length; ++i) {
                                if (typeof object.inputs[i] !== "object")
                                    throw TypeError(".TW.Binance.Proto.SendOrder.inputs: object expected");
                                message.inputs[i] = $root.TW.Binance.Proto.SendOrder.Input.fromObject(object.inputs[i]);
                            }
                        }
                        if (object.outputs) {
                            if (!Array.isArray(object.outputs))
                                throw TypeError(".TW.Binance.Proto.SendOrder.outputs: array expected");
                            message.outputs = [];
                            for (var i = 0; i < object.outputs.length; ++i) {
                                if (typeof object.outputs[i] !== "object")
                                    throw TypeError(".TW.Binance.Proto.SendOrder.outputs: object expected");
                                message.outputs[i] = $root.TW.Binance.Proto.SendOrder.Output.fromObject(object.outputs[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SendOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.SendOrder
                     * @static
                     * @param {TW.Binance.Proto.SendOrder} message SendOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SendOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.inputs = [];
                            object.outputs = [];
                        }
                        if (message.inputs && message.inputs.length) {
                            object.inputs = [];
                            for (var j = 0; j < message.inputs.length; ++j)
                                object.inputs[j] = $root.TW.Binance.Proto.SendOrder.Input.toObject(message.inputs[j], options);
                        }
                        if (message.outputs && message.outputs.length) {
                            object.outputs = [];
                            for (var j = 0; j < message.outputs.length; ++j)
                                object.outputs[j] = $root.TW.Binance.Proto.SendOrder.Output.toObject(message.outputs[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SendOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.SendOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SendOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    SendOrder.Token = (function() {
    
                        /**
                         * Properties of a Token.
                         * @memberof TW.Binance.Proto.SendOrder
                         * @interface IToken
                         * @property {string|null} [denom] Token denom
                         * @property {Long|null} [amount] Token amount
                         */
    
                        /**
                         * Constructs a new Token.
                         * @memberof TW.Binance.Proto.SendOrder
                         * @classdesc Represents a Token.
                         * @implements IToken
                         * @constructor
                         * @param {TW.Binance.Proto.SendOrder.IToken=} [properties] Properties to set
                         */
                        function Token(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Token denom.
                         * @member {string} denom
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @instance
                         */
                        Token.prototype.denom = "";
    
                        /**
                         * Token amount.
                         * @member {Long} amount
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @instance
                         */
                        Token.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                        /**
                         * Creates a new Token instance using the specified properties.
                         * @function create
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IToken=} [properties] Properties to set
                         * @returns {TW.Binance.Proto.SendOrder.Token} Token instance
                         */
                        Token.create = function create(properties) {
                            return new Token(properties);
                        };
    
                        /**
                         * Encodes the specified Token message. Does not implicitly {@link TW.Binance.Proto.SendOrder.Token.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IToken} message Token message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Token.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.denom != null && message.hasOwnProperty("denom"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
                            return writer;
                        };
    
                        /**
                         * Encodes the specified Token message, length delimited. Does not implicitly {@link TW.Binance.Proto.SendOrder.Token.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IToken} message Token message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Token.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
    
                        /**
                         * Decodes a Token message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Binance.Proto.SendOrder.Token} Token
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Token.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SendOrder.Token();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.denom = reader.string();
                                    break;
                                case 2:
                                    message.amount = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Decodes a Token message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {TW.Binance.Proto.SendOrder.Token} Token
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Token.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
    
                        /**
                         * Verifies a Token message.
                         * @function verify
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Token.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.denom != null && message.hasOwnProperty("denom"))
                                if (!$util.isString(message.denom))
                                    return "denom: string expected";
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                    return "amount: integer|Long expected";
                            return null;
                        };
    
                        /**
                         * Creates a Token message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Binance.Proto.SendOrder.Token} Token
                         */
                        Token.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Binance.Proto.SendOrder.Token)
                                return object;
                            var message = new $root.TW.Binance.Proto.SendOrder.Token();
                            if (object.denom != null)
                                message.denom = String(object.denom);
                            if (object.amount != null)
                                if ($util.Long)
                                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                                else if (typeof object.amount === "string")
                                    message.amount = parseInt(object.amount, 10);
                                else if (typeof object.amount === "number")
                                    message.amount = object.amount;
                                else if (typeof object.amount === "object")
                                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                            return message;
                        };
    
                        /**
                         * Creates a plain object from a Token message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.Token} message Token
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Token.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.denom = "";
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, false);
                                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.amount = options.longs === String ? "0" : 0;
                            }
                            if (message.denom != null && message.hasOwnProperty("denom"))
                                object.denom = message.denom;
                            if (message.amount != null && message.hasOwnProperty("amount"))
                                if (typeof message.amount === "number")
                                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                                else
                                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                            return object;
                        };
    
                        /**
                         * Converts this Token to JSON.
                         * @function toJSON
                         * @memberof TW.Binance.Proto.SendOrder.Token
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Token.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Token;
                    })();
    
                    SendOrder.Input = (function() {
    
                        /**
                         * Properties of an Input.
                         * @memberof TW.Binance.Proto.SendOrder
                         * @interface IInput
                         * @property {Uint8Array|null} [address] Input address
                         * @property {Array.<TW.Binance.Proto.SendOrder.IToken>|null} [coins] Input coins
                         */
    
                        /**
                         * Constructs a new Input.
                         * @memberof TW.Binance.Proto.SendOrder
                         * @classdesc Represents an Input.
                         * @implements IInput
                         * @constructor
                         * @param {TW.Binance.Proto.SendOrder.IInput=} [properties] Properties to set
                         */
                        function Input(properties) {
                            this.coins = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Input address.
                         * @member {Uint8Array} address
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @instance
                         */
                        Input.prototype.address = $util.newBuffer([]);
    
                        /**
                         * Input coins.
                         * @member {Array.<TW.Binance.Proto.SendOrder.IToken>} coins
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @instance
                         */
                        Input.prototype.coins = $util.emptyArray;
    
                        /**
                         * Creates a new Input instance using the specified properties.
                         * @function create
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IInput=} [properties] Properties to set
                         * @returns {TW.Binance.Proto.SendOrder.Input} Input instance
                         */
                        Input.create = function create(properties) {
                            return new Input(properties);
                        };
    
                        /**
                         * Encodes the specified Input message. Does not implicitly {@link TW.Binance.Proto.SendOrder.Input.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IInput} message Input message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Input.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.address != null && message.hasOwnProperty("address"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
                            if (message.coins != null && message.coins.length)
                                for (var i = 0; i < message.coins.length; ++i)
                                    $root.TW.Binance.Proto.SendOrder.Token.encode(message.coins[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };
    
                        /**
                         * Encodes the specified Input message, length delimited. Does not implicitly {@link TW.Binance.Proto.SendOrder.Input.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IInput} message Input message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Input.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
    
                        /**
                         * Decodes an Input message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Binance.Proto.SendOrder.Input} Input
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Input.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SendOrder.Input();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.address = reader.bytes();
                                    break;
                                case 2:
                                    if (!(message.coins && message.coins.length))
                                        message.coins = [];
                                    message.coins.push($root.TW.Binance.Proto.SendOrder.Token.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Decodes an Input message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {TW.Binance.Proto.SendOrder.Input} Input
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Input.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
    
                        /**
                         * Verifies an Input message.
                         * @function verify
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Input.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.address != null && message.hasOwnProperty("address"))
                                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                                    return "address: buffer expected";
                            if (message.coins != null && message.hasOwnProperty("coins")) {
                                if (!Array.isArray(message.coins))
                                    return "coins: array expected";
                                for (var i = 0; i < message.coins.length; ++i) {
                                    var error = $root.TW.Binance.Proto.SendOrder.Token.verify(message.coins[i]);
                                    if (error)
                                        return "coins." + error;
                                }
                            }
                            return null;
                        };
    
                        /**
                         * Creates an Input message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Binance.Proto.SendOrder.Input} Input
                         */
                        Input.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Binance.Proto.SendOrder.Input)
                                return object;
                            var message = new $root.TW.Binance.Proto.SendOrder.Input();
                            if (object.address != null)
                                if (typeof object.address === "string")
                                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                                else if (object.address.length)
                                    message.address = object.address;
                            if (object.coins) {
                                if (!Array.isArray(object.coins))
                                    throw TypeError(".TW.Binance.Proto.SendOrder.Input.coins: array expected");
                                message.coins = [];
                                for (var i = 0; i < object.coins.length; ++i) {
                                    if (typeof object.coins[i] !== "object")
                                        throw TypeError(".TW.Binance.Proto.SendOrder.Input.coins: object expected");
                                    message.coins[i] = $root.TW.Binance.Proto.SendOrder.Token.fromObject(object.coins[i]);
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Creates a plain object from an Input message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.Input} message Input
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Input.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.coins = [];
                            if (options.defaults)
                                if (options.bytes === String)
                                    object.address = "";
                                else {
                                    object.address = [];
                                    if (options.bytes !== Array)
                                        object.address = $util.newBuffer(object.address);
                                }
                            if (message.address != null && message.hasOwnProperty("address"))
                                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
                            if (message.coins && message.coins.length) {
                                object.coins = [];
                                for (var j = 0; j < message.coins.length; ++j)
                                    object.coins[j] = $root.TW.Binance.Proto.SendOrder.Token.toObject(message.coins[j], options);
                            }
                            return object;
                        };
    
                        /**
                         * Converts this Input to JSON.
                         * @function toJSON
                         * @memberof TW.Binance.Proto.SendOrder.Input
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Input.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Input;
                    })();
    
                    SendOrder.Output = (function() {
    
                        /**
                         * Properties of an Output.
                         * @memberof TW.Binance.Proto.SendOrder
                         * @interface IOutput
                         * @property {Uint8Array|null} [address] Output address
                         * @property {Array.<TW.Binance.Proto.SendOrder.IToken>|null} [coins] Output coins
                         */
    
                        /**
                         * Constructs a new Output.
                         * @memberof TW.Binance.Proto.SendOrder
                         * @classdesc Represents an Output.
                         * @implements IOutput
                         * @constructor
                         * @param {TW.Binance.Proto.SendOrder.IOutput=} [properties] Properties to set
                         */
                        function Output(properties) {
                            this.coins = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * Output address.
                         * @member {Uint8Array} address
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @instance
                         */
                        Output.prototype.address = $util.newBuffer([]);
    
                        /**
                         * Output coins.
                         * @member {Array.<TW.Binance.Proto.SendOrder.IToken>} coins
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @instance
                         */
                        Output.prototype.coins = $util.emptyArray;
    
                        /**
                         * Creates a new Output instance using the specified properties.
                         * @function create
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IOutput=} [properties] Properties to set
                         * @returns {TW.Binance.Proto.SendOrder.Output} Output instance
                         */
                        Output.create = function create(properties) {
                            return new Output(properties);
                        };
    
                        /**
                         * Encodes the specified Output message. Does not implicitly {@link TW.Binance.Proto.SendOrder.Output.verify|verify} messages.
                         * @function encode
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IOutput} message Output message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Output.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.address != null && message.hasOwnProperty("address"))
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
                            if (message.coins != null && message.coins.length)
                                for (var i = 0; i < message.coins.length; ++i)
                                    $root.TW.Binance.Proto.SendOrder.Token.encode(message.coins[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };
    
                        /**
                         * Encodes the specified Output message, length delimited. Does not implicitly {@link TW.Binance.Proto.SendOrder.Output.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.IOutput} message Output message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Output.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
    
                        /**
                         * Decodes an Output message from the specified reader or buffer.
                         * @function decode
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {TW.Binance.Proto.SendOrder.Output} Output
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Output.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SendOrder.Output();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.address = reader.bytes();
                                    break;
                                case 2:
                                    if (!(message.coins && message.coins.length))
                                        message.coins = [];
                                    message.coins.push($root.TW.Binance.Proto.SendOrder.Token.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Decodes an Output message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {TW.Binance.Proto.SendOrder.Output} Output
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Output.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
    
                        /**
                         * Verifies an Output message.
                         * @function verify
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Output.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.address != null && message.hasOwnProperty("address"))
                                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                                    return "address: buffer expected";
                            if (message.coins != null && message.hasOwnProperty("coins")) {
                                if (!Array.isArray(message.coins))
                                    return "coins: array expected";
                                for (var i = 0; i < message.coins.length; ++i) {
                                    var error = $root.TW.Binance.Proto.SendOrder.Token.verify(message.coins[i]);
                                    if (error)
                                        return "coins." + error;
                                }
                            }
                            return null;
                        };
    
                        /**
                         * Creates an Output message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {TW.Binance.Proto.SendOrder.Output} Output
                         */
                        Output.fromObject = function fromObject(object) {
                            if (object instanceof $root.TW.Binance.Proto.SendOrder.Output)
                                return object;
                            var message = new $root.TW.Binance.Proto.SendOrder.Output();
                            if (object.address != null)
                                if (typeof object.address === "string")
                                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                                else if (object.address.length)
                                    message.address = object.address;
                            if (object.coins) {
                                if (!Array.isArray(object.coins))
                                    throw TypeError(".TW.Binance.Proto.SendOrder.Output.coins: array expected");
                                message.coins = [];
                                for (var i = 0; i < object.coins.length; ++i) {
                                    if (typeof object.coins[i] !== "object")
                                        throw TypeError(".TW.Binance.Proto.SendOrder.Output.coins: object expected");
                                    message.coins[i] = $root.TW.Binance.Proto.SendOrder.Token.fromObject(object.coins[i]);
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Creates a plain object from an Output message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @static
                         * @param {TW.Binance.Proto.SendOrder.Output} message Output
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Output.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.coins = [];
                            if (options.defaults)
                                if (options.bytes === String)
                                    object.address = "";
                                else {
                                    object.address = [];
                                    if (options.bytes !== Array)
                                        object.address = $util.newBuffer(object.address);
                                }
                            if (message.address != null && message.hasOwnProperty("address"))
                                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
                            if (message.coins && message.coins.length) {
                                object.coins = [];
                                for (var j = 0; j < message.coins.length; ++j)
                                    object.coins[j] = $root.TW.Binance.Proto.SendOrder.Token.toObject(message.coins[j], options);
                            }
                            return object;
                        };
    
                        /**
                         * Converts this Output to JSON.
                         * @function toJSON
                         * @memberof TW.Binance.Proto.SendOrder.Output
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Output.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return Output;
                    })();
    
                    return SendOrder;
                })();
    
                Proto.TokenFreezeOrder = (function() {
    
                    /**
                     * Properties of a TokenFreezeOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ITokenFreezeOrder
                     * @property {Uint8Array|null} [from] TokenFreezeOrder from
                     * @property {string|null} [symbol] TokenFreezeOrder symbol
                     * @property {Long|null} [amount] TokenFreezeOrder amount
                     */
    
                    /**
                     * Constructs a new TokenFreezeOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TokenFreezeOrder.
                     * @implements ITokenFreezeOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ITokenFreezeOrder=} [properties] Properties to set
                     */
                    function TokenFreezeOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TokenFreezeOrder from.
                     * @member {Uint8Array} from
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @instance
                     */
                    TokenFreezeOrder.prototype.from = $util.newBuffer([]);
    
                    /**
                     * TokenFreezeOrder symbol.
                     * @member {string} symbol
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @instance
                     */
                    TokenFreezeOrder.prototype.symbol = "";
    
                    /**
                     * TokenFreezeOrder amount.
                     * @member {Long} amount
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @instance
                     */
                    TokenFreezeOrder.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TokenFreezeOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenFreezeOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TokenFreezeOrder} TokenFreezeOrder instance
                     */
                    TokenFreezeOrder.create = function create(properties) {
                        return new TokenFreezeOrder(properties);
                    };
    
                    /**
                     * Encodes the specified TokenFreezeOrder message. Does not implicitly {@link TW.Binance.Proto.TokenFreezeOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenFreezeOrder} message TokenFreezeOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenFreezeOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && message.hasOwnProperty("from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbol);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TokenFreezeOrder message, length delimited. Does not implicitly {@link TW.Binance.Proto.TokenFreezeOrder.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenFreezeOrder} message TokenFreezeOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenFreezeOrder.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TokenFreezeOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TokenFreezeOrder} TokenFreezeOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenFreezeOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TokenFreezeOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.symbol = reader.string();
                                break;
                            case 3:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TokenFreezeOrder message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Binance.Proto.TokenFreezeOrder} TokenFreezeOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenFreezeOrder.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TokenFreezeOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenFreezeOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TokenFreezeOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TokenFreezeOrder} TokenFreezeOrder
                     */
                    TokenFreezeOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TokenFreezeOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.TokenFreezeOrder();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TokenFreezeOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.TokenFreezeOrder} message TokenFreezeOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenFreezeOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            object.symbol = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TokenFreezeOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TokenFreezeOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenFreezeOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TokenFreezeOrder;
                })();
    
                Proto.TokenUnfreezeOrder = (function() {
    
                    /**
                     * Properties of a TokenUnfreezeOrder.
                     * @memberof TW.Binance.Proto
                     * @interface ITokenUnfreezeOrder
                     * @property {Uint8Array|null} [from] TokenUnfreezeOrder from
                     * @property {string|null} [symbol] TokenUnfreezeOrder symbol
                     * @property {Long|null} [amount] TokenUnfreezeOrder amount
                     */
    
                    /**
                     * Constructs a new TokenUnfreezeOrder.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a TokenUnfreezeOrder.
                     * @implements ITokenUnfreezeOrder
                     * @constructor
                     * @param {TW.Binance.Proto.ITokenUnfreezeOrder=} [properties] Properties to set
                     */
                    function TokenUnfreezeOrder(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TokenUnfreezeOrder from.
                     * @member {Uint8Array} from
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @instance
                     */
                    TokenUnfreezeOrder.prototype.from = $util.newBuffer([]);
    
                    /**
                     * TokenUnfreezeOrder symbol.
                     * @member {string} symbol
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @instance
                     */
                    TokenUnfreezeOrder.prototype.symbol = "";
    
                    /**
                     * TokenUnfreezeOrder amount.
                     * @member {Long} amount
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @instance
                     */
                    TokenUnfreezeOrder.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TokenUnfreezeOrder instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenUnfreezeOrder=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.TokenUnfreezeOrder} TokenUnfreezeOrder instance
                     */
                    TokenUnfreezeOrder.create = function create(properties) {
                        return new TokenUnfreezeOrder(properties);
                    };
    
                    /**
                     * Encodes the specified TokenUnfreezeOrder message. Does not implicitly {@link TW.Binance.Proto.TokenUnfreezeOrder.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenUnfreezeOrder} message TokenUnfreezeOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenUnfreezeOrder.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && message.hasOwnProperty("from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbol);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TokenUnfreezeOrder message, length delimited. Does not implicitly {@link TW.Binance.Proto.TokenUnfreezeOrder.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.ITokenUnfreezeOrder} message TokenUnfreezeOrder message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TokenUnfreezeOrder.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TokenUnfreezeOrder message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.TokenUnfreezeOrder} TokenUnfreezeOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenUnfreezeOrder.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.TokenUnfreezeOrder();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.symbol = reader.string();
                                break;
                            case 3:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TokenUnfreezeOrder message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Binance.Proto.TokenUnfreezeOrder} TokenUnfreezeOrder
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TokenUnfreezeOrder.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TokenUnfreezeOrder message.
                     * @function verify
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TokenUnfreezeOrder.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TokenUnfreezeOrder message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.TokenUnfreezeOrder} TokenUnfreezeOrder
                     */
                    TokenUnfreezeOrder.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.TokenUnfreezeOrder)
                            return object;
                        var message = new $root.TW.Binance.Proto.TokenUnfreezeOrder();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TokenUnfreezeOrder message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @static
                     * @param {TW.Binance.Proto.TokenUnfreezeOrder} message TokenUnfreezeOrder
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TokenUnfreezeOrder.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            object.symbol = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TokenUnfreezeOrder to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.TokenUnfreezeOrder
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TokenUnfreezeOrder.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TokenUnfreezeOrder;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Binance.Proto
                     * @interface ISigningInput
                     * @property {string|null} [chainId] SigningInput chainId
                     * @property {Long|null} [accountNumber] SigningInput accountNumber
                     * @property {Long|null} [sequence] SigningInput sequence
                     * @property {Long|null} [source] SigningInput source
                     * @property {string|null} [memo] SigningInput memo
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.Binance.Proto.ITradeOrder|null} [tradeOrder] SigningInput tradeOrder
                     * @property {TW.Binance.Proto.ICancelTradeOrder|null} [cancelTradeOrder] SigningInput cancelTradeOrder
                     * @property {TW.Binance.Proto.ISendOrder|null} [sendOrder] SigningInput sendOrder
                     * @property {TW.Binance.Proto.ITokenFreezeOrder|null} [freezeOrder] SigningInput freezeOrder
                     * @property {TW.Binance.Proto.ITokenUnfreezeOrder|null} [unfreezeOrder] SigningInput unfreezeOrder
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Binance.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput chainId.
                     * @member {string} chainId
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = "";
    
                    /**
                     * SigningInput accountNumber.
                     * @member {Long} accountNumber
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.accountNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput sequence.
                     * @member {Long} sequence
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput source.
                     * @member {Long} source
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.source = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput memo.
                     * @member {string} memo
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memo = "";
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput tradeOrder.
                     * @member {TW.Binance.Proto.ITradeOrder|null|undefined} tradeOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.tradeOrder = null;
    
                    /**
                     * SigningInput cancelTradeOrder.
                     * @member {TW.Binance.Proto.ICancelTradeOrder|null|undefined} cancelTradeOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.cancelTradeOrder = null;
    
                    /**
                     * SigningInput sendOrder.
                     * @member {TW.Binance.Proto.ISendOrder|null|undefined} sendOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sendOrder = null;
    
                    /**
                     * SigningInput freezeOrder.
                     * @member {TW.Binance.Proto.ITokenFreezeOrder|null|undefined} freezeOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.freezeOrder = null;
    
                    /**
                     * SigningInput unfreezeOrder.
                     * @member {TW.Binance.Proto.ITokenUnfreezeOrder|null|undefined} unfreezeOrder
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.unfreezeOrder = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput orderOneof.
                     * @member {"tradeOrder"|"cancelTradeOrder"|"sendOrder"|"freezeOrder"|"unfreezeOrder"|undefined} orderOneof
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "orderOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["tradeOrder", "cancelTradeOrder", "sendOrder", "freezeOrder", "unfreezeOrder"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {TW.Binance.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Binance.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {TW.Binance.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.chainId);
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.accountNumber);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.sequence);
                        if (message.source != null && message.hasOwnProperty("source"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.source);
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.memo);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.privateKey);
                        if (message.tradeOrder != null && message.hasOwnProperty("tradeOrder"))
                            $root.TW.Binance.Proto.TradeOrder.encode(message.tradeOrder, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.cancelTradeOrder != null && message.hasOwnProperty("cancelTradeOrder"))
                            $root.TW.Binance.Proto.CancelTradeOrder.encode(message.cancelTradeOrder, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.sendOrder != null && message.hasOwnProperty("sendOrder"))
                            $root.TW.Binance.Proto.SendOrder.encode(message.sendOrder, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.freezeOrder != null && message.hasOwnProperty("freezeOrder"))
                            $root.TW.Binance.Proto.TokenFreezeOrder.encode(message.freezeOrder, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        if (message.unfreezeOrder != null && message.hasOwnProperty("unfreezeOrder"))
                            $root.TW.Binance.Proto.TokenUnfreezeOrder.encode(message.unfreezeOrder, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Binance.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {TW.Binance.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainId = reader.string();
                                break;
                            case 2:
                                message.accountNumber = reader.int64();
                                break;
                            case 3:
                                message.sequence = reader.int64();
                                break;
                            case 4:
                                message.source = reader.int64();
                                break;
                            case 5:
                                message.memo = reader.string();
                                break;
                            case 6:
                                message.privateKey = reader.bytes();
                                break;
                            case 8:
                                message.tradeOrder = $root.TW.Binance.Proto.TradeOrder.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.cancelTradeOrder = $root.TW.Binance.Proto.CancelTradeOrder.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.sendOrder = $root.TW.Binance.Proto.SendOrder.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.freezeOrder = $root.TW.Binance.Proto.TokenFreezeOrder.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.unfreezeOrder = $root.TW.Binance.Proto.TokenUnfreezeOrder.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Binance.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isString(message.chainId))
                                return "chainId: string expected";
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (!$util.isInteger(message.accountNumber) && !(message.accountNumber && $util.isInteger(message.accountNumber.low) && $util.isInteger(message.accountNumber.high)))
                                return "accountNumber: integer|Long expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                                return "sequence: integer|Long expected";
                        if (message.source != null && message.hasOwnProperty("source"))
                            if (!$util.isInteger(message.source) && !(message.source && $util.isInteger(message.source.low) && $util.isInteger(message.source.high)))
                                return "source: integer|Long expected";
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.tradeOrder != null && message.hasOwnProperty("tradeOrder")) {
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TradeOrder.verify(message.tradeOrder);
                                if (error)
                                    return "tradeOrder." + error;
                            }
                        }
                        if (message.cancelTradeOrder != null && message.hasOwnProperty("cancelTradeOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.CancelTradeOrder.verify(message.cancelTradeOrder);
                                if (error)
                                    return "cancelTradeOrder." + error;
                            }
                        }
                        if (message.sendOrder != null && message.hasOwnProperty("sendOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.SendOrder.verify(message.sendOrder);
                                if (error)
                                    return "sendOrder." + error;
                            }
                        }
                        if (message.freezeOrder != null && message.hasOwnProperty("freezeOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TokenFreezeOrder.verify(message.freezeOrder);
                                if (error)
                                    return "freezeOrder." + error;
                            }
                        }
                        if (message.unfreezeOrder != null && message.hasOwnProperty("unfreezeOrder")) {
                            if (properties.orderOneof === 1)
                                return "orderOneof: multiple values";
                            properties.orderOneof = 1;
                            {
                                var error = $root.TW.Binance.Proto.TokenUnfreezeOrder.verify(message.unfreezeOrder);
                                if (error)
                                    return "unfreezeOrder." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Binance.Proto.SigningInput();
                        if (object.chainId != null)
                            message.chainId = String(object.chainId);
                        if (object.accountNumber != null)
                            if ($util.Long)
                                (message.accountNumber = $util.Long.fromValue(object.accountNumber)).unsigned = false;
                            else if (typeof object.accountNumber === "string")
                                message.accountNumber = parseInt(object.accountNumber, 10);
                            else if (typeof object.accountNumber === "number")
                                message.accountNumber = object.accountNumber;
                            else if (typeof object.accountNumber === "object")
                                message.accountNumber = new $util.LongBits(object.accountNumber.low >>> 0, object.accountNumber.high >>> 0).toNumber();
                        if (object.sequence != null)
                            if ($util.Long)
                                (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                            else if (typeof object.sequence === "string")
                                message.sequence = parseInt(object.sequence, 10);
                            else if (typeof object.sequence === "number")
                                message.sequence = object.sequence;
                            else if (typeof object.sequence === "object")
                                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                        if (object.source != null)
                            if ($util.Long)
                                (message.source = $util.Long.fromValue(object.source)).unsigned = false;
                            else if (typeof object.source === "string")
                                message.source = parseInt(object.source, 10);
                            else if (typeof object.source === "number")
                                message.source = object.source;
                            else if (typeof object.source === "object")
                                message.source = new $util.LongBits(object.source.low >>> 0, object.source.high >>> 0).toNumber();
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.tradeOrder != null) {
                            if (typeof object.tradeOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.tradeOrder: object expected");
                            message.tradeOrder = $root.TW.Binance.Proto.TradeOrder.fromObject(object.tradeOrder);
                        }
                        if (object.cancelTradeOrder != null) {
                            if (typeof object.cancelTradeOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.cancelTradeOrder: object expected");
                            message.cancelTradeOrder = $root.TW.Binance.Proto.CancelTradeOrder.fromObject(object.cancelTradeOrder);
                        }
                        if (object.sendOrder != null) {
                            if (typeof object.sendOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.sendOrder: object expected");
                            message.sendOrder = $root.TW.Binance.Proto.SendOrder.fromObject(object.sendOrder);
                        }
                        if (object.freezeOrder != null) {
                            if (typeof object.freezeOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.freezeOrder: object expected");
                            message.freezeOrder = $root.TW.Binance.Proto.TokenFreezeOrder.fromObject(object.freezeOrder);
                        }
                        if (object.unfreezeOrder != null) {
                            if (typeof object.unfreezeOrder !== "object")
                                throw TypeError(".TW.Binance.Proto.SigningInput.unfreezeOrder: object expected");
                            message.unfreezeOrder = $root.TW.Binance.Proto.TokenUnfreezeOrder.fromObject(object.unfreezeOrder);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.SigningInput
                     * @static
                     * @param {TW.Binance.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.chainId = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.accountNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.accountNumber = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sequence = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.source = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.source = options.longs === String ? "0" : 0;
                            object.memo = "";
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (typeof message.accountNumber === "number")
                                object.accountNumber = options.longs === String ? String(message.accountNumber) : message.accountNumber;
                            else
                                object.accountNumber = options.longs === String ? $util.Long.prototype.toString.call(message.accountNumber) : options.longs === Number ? new $util.LongBits(message.accountNumber.low >>> 0, message.accountNumber.high >>> 0).toNumber() : message.accountNumber;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (typeof message.sequence === "number")
                                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                            else
                                object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                        if (message.source != null && message.hasOwnProperty("source"))
                            if (typeof message.source === "number")
                                object.source = options.longs === String ? String(message.source) : message.source;
                            else
                                object.source = options.longs === String ? $util.Long.prototype.toString.call(message.source) : options.longs === Number ? new $util.LongBits(message.source.low >>> 0, message.source.high >>> 0).toNumber() : message.source;
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.tradeOrder != null && message.hasOwnProperty("tradeOrder")) {
                            object.tradeOrder = $root.TW.Binance.Proto.TradeOrder.toObject(message.tradeOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "tradeOrder";
                        }
                        if (message.cancelTradeOrder != null && message.hasOwnProperty("cancelTradeOrder")) {
                            object.cancelTradeOrder = $root.TW.Binance.Proto.CancelTradeOrder.toObject(message.cancelTradeOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "cancelTradeOrder";
                        }
                        if (message.sendOrder != null && message.hasOwnProperty("sendOrder")) {
                            object.sendOrder = $root.TW.Binance.Proto.SendOrder.toObject(message.sendOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "sendOrder";
                        }
                        if (message.freezeOrder != null && message.hasOwnProperty("freezeOrder")) {
                            object.freezeOrder = $root.TW.Binance.Proto.TokenFreezeOrder.toObject(message.freezeOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "freezeOrder";
                        }
                        if (message.unfreezeOrder != null && message.hasOwnProperty("unfreezeOrder")) {
                            object.unfreezeOrder = $root.TW.Binance.Proto.TokenUnfreezeOrder.toObject(message.unfreezeOrder, options);
                            if (options.oneofs)
                                object.orderOneof = "unfreezeOrder";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Binance.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Binance.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Binance.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {TW.Binance.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Binance.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Binance.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {TW.Binance.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Binance.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {TW.Binance.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Binance.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Binance.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Binance.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Binance.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Binance.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Binance.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @static
                     * @param {TW.Binance.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Binance.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Binance;
        })();
    
        TW.Bitcoin = (function() {
    
            /**
             * Namespace Bitcoin.
             * @memberof TW
             * @namespace
             */
            var Bitcoin = {};
    
            Bitcoin.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Bitcoin
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.Bitcoin.Proto
                     * @interface ITransaction
                     * @property {number|null} [version] Transaction version
                     * @property {number|null} [lockTime] Transaction lockTime
                     * @property {Array.<TW.Bitcoin.Proto.ITransactionInput>|null} [inputs] Transaction inputs
                     * @property {Array.<TW.Bitcoin.Proto.ITransactionOutput>|null} [outputs] Transaction outputs
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.Bitcoin.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        this.inputs = [];
                        this.outputs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction version.
                     * @member {number} version
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.version = 0;
    
                    /**
                     * Transaction lockTime.
                     * @member {number} lockTime
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.lockTime = 0;
    
                    /**
                     * Transaction inputs.
                     * @member {Array.<TW.Bitcoin.Proto.ITransactionInput>} inputs
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.inputs = $util.emptyArray;
    
                    /**
                     * Transaction outputs.
                     * @member {Array.<TW.Bitcoin.Proto.ITransactionOutput>} outputs
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.outputs = $util.emptyArray;
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.Bitcoin.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.version != null && message.hasOwnProperty("version"))
                            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.version);
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.lockTime);
                        if (message.inputs != null && message.inputs.length)
                            for (var i = 0; i < message.inputs.length; ++i)
                                $root.TW.Bitcoin.Proto.TransactionInput.encode(message.inputs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.outputs != null && message.outputs.length)
                            for (var i = 0; i < message.outputs.length; ++i)
                                $root.TW.Bitcoin.Proto.TransactionOutput.encode(message.outputs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Transaction message, length delimited. Does not implicitly {@link TW.Bitcoin.Proto.Transaction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.version = reader.sint32();
                                break;
                            case 2:
                                message.lockTime = reader.uint32();
                                break;
                            case 3:
                                if (!(message.inputs && message.inputs.length))
                                    message.inputs = [];
                                message.inputs.push($root.TW.Bitcoin.Proto.TransactionInput.decode(reader, reader.uint32()));
                                break;
                            case 4:
                                if (!(message.outputs && message.outputs.length))
                                    message.outputs = [];
                                message.outputs.push($root.TW.Bitcoin.Proto.TransactionOutput.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Bitcoin.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (!$util.isInteger(message.lockTime))
                                return "lockTime: integer expected";
                        if (message.inputs != null && message.hasOwnProperty("inputs")) {
                            if (!Array.isArray(message.inputs))
                                return "inputs: array expected";
                            for (var i = 0; i < message.inputs.length; ++i) {
                                var error = $root.TW.Bitcoin.Proto.TransactionInput.verify(message.inputs[i]);
                                if (error)
                                    return "inputs." + error;
                            }
                        }
                        if (message.outputs != null && message.hasOwnProperty("outputs")) {
                            if (!Array.isArray(message.outputs))
                                return "outputs: array expected";
                            for (var i = 0; i < message.outputs.length; ++i) {
                                var error = $root.TW.Bitcoin.Proto.TransactionOutput.verify(message.outputs[i]);
                                if (error)
                                    return "outputs." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.Transaction)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.Transaction();
                        if (object.version != null)
                            message.version = object.version | 0;
                        if (object.lockTime != null)
                            message.lockTime = object.lockTime >>> 0;
                        if (object.inputs) {
                            if (!Array.isArray(object.inputs))
                                throw TypeError(".TW.Bitcoin.Proto.Transaction.inputs: array expected");
                            message.inputs = [];
                            for (var i = 0; i < object.inputs.length; ++i) {
                                if (typeof object.inputs[i] !== "object")
                                    throw TypeError(".TW.Bitcoin.Proto.Transaction.inputs: object expected");
                                message.inputs[i] = $root.TW.Bitcoin.Proto.TransactionInput.fromObject(object.inputs[i]);
                            }
                        }
                        if (object.outputs) {
                            if (!Array.isArray(object.outputs))
                                throw TypeError(".TW.Bitcoin.Proto.Transaction.outputs: array expected");
                            message.outputs = [];
                            for (var i = 0; i < object.outputs.length; ++i) {
                                if (typeof object.outputs[i] !== "object")
                                    throw TypeError(".TW.Bitcoin.Proto.Transaction.outputs: object expected");
                                message.outputs[i] = $root.TW.Bitcoin.Proto.TransactionOutput.fromObject(object.outputs[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @static
                     * @param {TW.Bitcoin.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.inputs = [];
                            object.outputs = [];
                        }
                        if (options.defaults) {
                            object.version = 0;
                            object.lockTime = 0;
                        }
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            object.lockTime = message.lockTime;
                        if (message.inputs && message.inputs.length) {
                            object.inputs = [];
                            for (var j = 0; j < message.inputs.length; ++j)
                                object.inputs[j] = $root.TW.Bitcoin.Proto.TransactionInput.toObject(message.inputs[j], options);
                        }
                        if (message.outputs && message.outputs.length) {
                            object.outputs = [];
                            for (var j = 0; j < message.outputs.length; ++j)
                                object.outputs[j] = $root.TW.Bitcoin.Proto.TransactionOutput.toObject(message.outputs[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.TransactionInput = (function() {
    
                    /**
                     * Properties of a TransactionInput.
                     * @memberof TW.Bitcoin.Proto
                     * @interface ITransactionInput
                     * @property {TW.Bitcoin.Proto.IOutPoint|null} [previousOutput] TransactionInput previousOutput
                     * @property {number|null} [sequence] TransactionInput sequence
                     * @property {Uint8Array|null} [script] TransactionInput script
                     */
    
                    /**
                     * Constructs a new TransactionInput.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a TransactionInput.
                     * @implements ITransactionInput
                     * @constructor
                     * @param {TW.Bitcoin.Proto.ITransactionInput=} [properties] Properties to set
                     */
                    function TransactionInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionInput previousOutput.
                     * @member {TW.Bitcoin.Proto.IOutPoint|null|undefined} previousOutput
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.previousOutput = null;
    
                    /**
                     * TransactionInput sequence.
                     * @member {number} sequence
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.sequence = 0;
    
                    /**
                     * TransactionInput script.
                     * @member {Uint8Array} script
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.script = $util.newBuffer([]);
    
                    /**
                     * Creates a new TransactionInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionInput=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.TransactionInput} TransactionInput instance
                     */
                    TransactionInput.create = function create(properties) {
                        return new TransactionInput(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionInput message. Does not implicitly {@link TW.Bitcoin.Proto.TransactionInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionInput} message TransactionInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.previousOutput != null && message.hasOwnProperty("previousOutput"))
                            $root.TW.Bitcoin.Proto.OutPoint.encode(message.previousOutput, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sequence);
                        if (message.script != null && message.hasOwnProperty("script"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.script);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TransactionInput message, length delimited. Does not implicitly {@link TW.Bitcoin.Proto.TransactionInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionInput} message TransactionInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TransactionInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.TransactionInput} TransactionInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.TransactionInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.previousOutput = $root.TW.Bitcoin.Proto.OutPoint.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.sequence = reader.uint32();
                                break;
                            case 3:
                                message.script = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TransactionInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Bitcoin.Proto.TransactionInput} TransactionInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TransactionInput message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.previousOutput != null && message.hasOwnProperty("previousOutput")) {
                            var error = $root.TW.Bitcoin.Proto.OutPoint.verify(message.previousOutput);
                            if (error)
                                return "previousOutput." + error;
                        }
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence))
                                return "sequence: integer expected";
                        if (message.script != null && message.hasOwnProperty("script"))
                            if (!(message.script && typeof message.script.length === "number" || $util.isString(message.script)))
                                return "script: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.TransactionInput} TransactionInput
                     */
                    TransactionInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.TransactionInput)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.TransactionInput();
                        if (object.previousOutput != null) {
                            if (typeof object.previousOutput !== "object")
                                throw TypeError(".TW.Bitcoin.Proto.TransactionInput.previousOutput: object expected");
                            message.previousOutput = $root.TW.Bitcoin.Proto.OutPoint.fromObject(object.previousOutput);
                        }
                        if (object.sequence != null)
                            message.sequence = object.sequence >>> 0;
                        if (object.script != null)
                            if (typeof object.script === "string")
                                $util.base64.decode(object.script, message.script = $util.newBuffer($util.base64.length(object.script)), 0);
                            else if (object.script.length)
                                message.script = object.script;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @static
                     * @param {TW.Bitcoin.Proto.TransactionInput} message TransactionInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.previousOutput = null;
                            object.sequence = 0;
                            if (options.bytes === String)
                                object.script = "";
                            else {
                                object.script = [];
                                if (options.bytes !== Array)
                                    object.script = $util.newBuffer(object.script);
                            }
                        }
                        if (message.previousOutput != null && message.hasOwnProperty("previousOutput"))
                            object.previousOutput = $root.TW.Bitcoin.Proto.OutPoint.toObject(message.previousOutput, options);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            object.sequence = message.sequence;
                        if (message.script != null && message.hasOwnProperty("script"))
                            object.script = options.bytes === String ? $util.base64.encode(message.script, 0, message.script.length) : options.bytes === Array ? Array.prototype.slice.call(message.script) : message.script;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionInput to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.TransactionInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionInput;
                })();
    
                Proto.OutPoint = (function() {
    
                    /**
                     * Properties of an OutPoint.
                     * @memberof TW.Bitcoin.Proto
                     * @interface IOutPoint
                     * @property {Uint8Array|null} [hash] OutPoint hash
                     * @property {number|null} [index] OutPoint index
                     * @property {number|null} [sequence] OutPoint sequence
                     */
    
                    /**
                     * Constructs a new OutPoint.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents an OutPoint.
                     * @implements IOutPoint
                     * @constructor
                     * @param {TW.Bitcoin.Proto.IOutPoint=} [properties] Properties to set
                     */
                    function OutPoint(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * OutPoint hash.
                     * @member {Uint8Array} hash
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @instance
                     */
                    OutPoint.prototype.hash = $util.newBuffer([]);
    
                    /**
                     * OutPoint index.
                     * @member {number} index
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @instance
                     */
                    OutPoint.prototype.index = 0;
    
                    /**
                     * OutPoint sequence.
                     * @member {number} sequence
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @instance
                     */
                    OutPoint.prototype.sequence = 0;
    
                    /**
                     * Creates a new OutPoint instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {TW.Bitcoin.Proto.IOutPoint=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.OutPoint} OutPoint instance
                     */
                    OutPoint.create = function create(properties) {
                        return new OutPoint(properties);
                    };
    
                    /**
                     * Encodes the specified OutPoint message. Does not implicitly {@link TW.Bitcoin.Proto.OutPoint.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {TW.Bitcoin.Proto.IOutPoint} message OutPoint message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OutPoint.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                        if (message.index != null && message.hasOwnProperty("index"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.sequence);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified OutPoint message, length delimited. Does not implicitly {@link TW.Bitcoin.Proto.OutPoint.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {TW.Bitcoin.Proto.IOutPoint} message OutPoint message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OutPoint.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an OutPoint message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.OutPoint} OutPoint
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OutPoint.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.OutPoint();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.hash = reader.bytes();
                                break;
                            case 2:
                                message.index = reader.uint32();
                                break;
                            case 3:
                                message.sequence = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an OutPoint message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Bitcoin.Proto.OutPoint} OutPoint
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OutPoint.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an OutPoint message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    OutPoint.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                                return "hash: buffer expected";
                        if (message.index != null && message.hasOwnProperty("index"))
                            if (!$util.isInteger(message.index))
                                return "index: integer expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence))
                                return "sequence: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an OutPoint message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.OutPoint} OutPoint
                     */
                    OutPoint.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.OutPoint)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.OutPoint();
                        if (object.hash != null)
                            if (typeof object.hash === "string")
                                $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                            else if (object.hash.length)
                                message.hash = object.hash;
                        if (object.index != null)
                            message.index = object.index >>> 0;
                        if (object.sequence != null)
                            message.sequence = object.sequence >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an OutPoint message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @static
                     * @param {TW.Bitcoin.Proto.OutPoint} message OutPoint
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    OutPoint.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.hash = "";
                            else {
                                object.hash = [];
                                if (options.bytes !== Array)
                                    object.hash = $util.newBuffer(object.hash);
                            }
                            object.index = 0;
                            object.sequence = 0;
                        }
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                        if (message.index != null && message.hasOwnProperty("index"))
                            object.index = message.index;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            object.sequence = message.sequence;
                        return object;
                    };
    
                    /**
                     * Converts this OutPoint to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.OutPoint
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    OutPoint.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return OutPoint;
                })();
    
                Proto.TransactionOutput = (function() {
    
                    /**
                     * Properties of a TransactionOutput.
                     * @memberof TW.Bitcoin.Proto
                     * @interface ITransactionOutput
                     * @property {Long|null} [value] TransactionOutput value
                     * @property {Uint8Array|null} [script] TransactionOutput script
                     */
    
                    /**
                     * Constructs a new TransactionOutput.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a TransactionOutput.
                     * @implements ITransactionOutput
                     * @constructor
                     * @param {TW.Bitcoin.Proto.ITransactionOutput=} [properties] Properties to set
                     */
                    function TransactionOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionOutput value.
                     * @member {Long} value
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionOutput script.
                     * @member {Uint8Array} script
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.script = $util.newBuffer([]);
    
                    /**
                     * Creates a new TransactionOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionOutput=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.TransactionOutput} TransactionOutput instance
                     */
                    TransactionOutput.create = function create(properties) {
                        return new TransactionOutput(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionOutput message. Does not implicitly {@link TW.Bitcoin.Proto.TransactionOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionOutput} message TransactionOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
                        if (message.script != null && message.hasOwnProperty("script"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.script);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TransactionOutput message, length delimited. Does not implicitly {@link TW.Bitcoin.Proto.TransactionOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionOutput} message TransactionOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TransactionOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.TransactionOutput} TransactionOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.TransactionOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.int64();
                                break;
                            case 2:
                                message.script = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TransactionOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Bitcoin.Proto.TransactionOutput} TransactionOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TransactionOutput message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        if (message.script != null && message.hasOwnProperty("script"))
                            if (!(message.script && typeof message.script.length === "number" || $util.isString(message.script)))
                                return "script: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.TransactionOutput} TransactionOutput
                     */
                    TransactionOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.TransactionOutput)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.TransactionOutput();
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                        if (object.script != null)
                            if (typeof object.script === "string")
                                $util.base64.decode(object.script, message.script = $util.newBuffer($util.base64.length(object.script)), 0);
                            else if (object.script.length)
                                message.script = object.script;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.TransactionOutput} message TransactionOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.script = "";
                            else {
                                object.script = [];
                                if (options.bytes !== Array)
                                    object.script = $util.newBuffer(object.script);
                            }
                        }
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                        if (message.script != null && message.hasOwnProperty("script"))
                            object.script = options.bytes === String ? $util.base64.encode(message.script, 0, message.script.length) : options.bytes === Array ? Array.prototype.slice.call(message.script) : message.script;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.TransactionOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionOutput;
                })();
    
                Proto.UnspentTransaction = (function() {
    
                    /**
                     * Properties of an UnspentTransaction.
                     * @memberof TW.Bitcoin.Proto
                     * @interface IUnspentTransaction
                     * @property {TW.Bitcoin.Proto.IOutPoint|null} [outPoint] UnspentTransaction outPoint
                     * @property {Uint8Array|null} [script] UnspentTransaction script
                     * @property {Long|null} [amount] UnspentTransaction amount
                     */
    
                    /**
                     * Constructs a new UnspentTransaction.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents an UnspentTransaction.
                     * @implements IUnspentTransaction
                     * @constructor
                     * @param {TW.Bitcoin.Proto.IUnspentTransaction=} [properties] Properties to set
                     */
                    function UnspentTransaction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * UnspentTransaction outPoint.
                     * @member {TW.Bitcoin.Proto.IOutPoint|null|undefined} outPoint
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @instance
                     */
                    UnspentTransaction.prototype.outPoint = null;
    
                    /**
                     * UnspentTransaction script.
                     * @member {Uint8Array} script
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @instance
                     */
                    UnspentTransaction.prototype.script = $util.newBuffer([]);
    
                    /**
                     * UnspentTransaction amount.
                     * @member {Long} amount
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @instance
                     */
                    UnspentTransaction.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new UnspentTransaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {TW.Bitcoin.Proto.IUnspentTransaction=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.UnspentTransaction} UnspentTransaction instance
                     */
                    UnspentTransaction.create = function create(properties) {
                        return new UnspentTransaction(properties);
                    };
    
                    /**
                     * Encodes the specified UnspentTransaction message. Does not implicitly {@link TW.Bitcoin.Proto.UnspentTransaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {TW.Bitcoin.Proto.IUnspentTransaction} message UnspentTransaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UnspentTransaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.outPoint != null && message.hasOwnProperty("outPoint"))
                            $root.TW.Bitcoin.Proto.OutPoint.encode(message.outPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.script != null && message.hasOwnProperty("script"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.script);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified UnspentTransaction message, length delimited. Does not implicitly {@link TW.Bitcoin.Proto.UnspentTransaction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {TW.Bitcoin.Proto.IUnspentTransaction} message UnspentTransaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    UnspentTransaction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an UnspentTransaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.UnspentTransaction} UnspentTransaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UnspentTransaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.UnspentTransaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.outPoint = $root.TW.Bitcoin.Proto.OutPoint.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.script = reader.bytes();
                                break;
                            case 3:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an UnspentTransaction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Bitcoin.Proto.UnspentTransaction} UnspentTransaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    UnspentTransaction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an UnspentTransaction message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UnspentTransaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.outPoint != null && message.hasOwnProperty("outPoint")) {
                            var error = $root.TW.Bitcoin.Proto.OutPoint.verify(message.outPoint);
                            if (error)
                                return "outPoint." + error;
                        }
                        if (message.script != null && message.hasOwnProperty("script"))
                            if (!(message.script && typeof message.script.length === "number" || $util.isString(message.script)))
                                return "script: buffer expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an UnspentTransaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.UnspentTransaction} UnspentTransaction
                     */
                    UnspentTransaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.UnspentTransaction)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.UnspentTransaction();
                        if (object.outPoint != null) {
                            if (typeof object.outPoint !== "object")
                                throw TypeError(".TW.Bitcoin.Proto.UnspentTransaction.outPoint: object expected");
                            message.outPoint = $root.TW.Bitcoin.Proto.OutPoint.fromObject(object.outPoint);
                        }
                        if (object.script != null)
                            if (typeof object.script === "string")
                                $util.base64.decode(object.script, message.script = $util.newBuffer($util.base64.length(object.script)), 0);
                            else if (object.script.length)
                                message.script = object.script;
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an UnspentTransaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @static
                     * @param {TW.Bitcoin.Proto.UnspentTransaction} message UnspentTransaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UnspentTransaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.outPoint = null;
                            if (options.bytes === String)
                                object.script = "";
                            else {
                                object.script = [];
                                if (options.bytes !== Array)
                                    object.script = $util.newBuffer(object.script);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.outPoint != null && message.hasOwnProperty("outPoint"))
                            object.outPoint = $root.TW.Bitcoin.Proto.OutPoint.toObject(message.outPoint, options);
                        if (message.script != null && message.hasOwnProperty("script"))
                            object.script = options.bytes === String ? $util.base64.encode(message.script, 0, message.script.length) : options.bytes === Array ? Array.prototype.slice.call(message.script) : message.script;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this UnspentTransaction to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.UnspentTransaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UnspentTransaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return UnspentTransaction;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Bitcoin.Proto
                     * @interface ISigningInput
                     * @property {number|null} [hashType] SigningInput hashType
                     * @property {Long|null} [amount] SigningInput amount
                     * @property {Long|null} [byteFee] SigningInput byteFee
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {string|null} [changeAddress] SigningInput changeAddress
                     * @property {Array.<Uint8Array>|null} [privateKey] SigningInput privateKey
                     * @property {Object.<string,Uint8Array>|null} [scripts] SigningInput scripts
                     * @property {Array.<TW.Bitcoin.Proto.IUnspentTransaction>|null} [utxo] SigningInput utxo
                     * @property {boolean|null} [useMaxAmount] SigningInput useMaxAmount
                     * @property {number|null} [coinType] SigningInput coinType
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Bitcoin.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        this.privateKey = [];
                        this.scripts = {};
                        this.utxo = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput hashType.
                     * @member {number} hashType
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.hashType = 0;
    
                    /**
                     * SigningInput amount.
                     * @member {Long} amount
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput byteFee.
                     * @member {Long} byteFee
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.byteFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput changeAddress.
                     * @member {string} changeAddress
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.changeAddress = "";
    
                    /**
                     * SigningInput privateKey.
                     * @member {Array.<Uint8Array>} privateKey
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.emptyArray;
    
                    /**
                     * SigningInput scripts.
                     * @member {Object.<string,Uint8Array>} scripts
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.scripts = $util.emptyObject;
    
                    /**
                     * SigningInput utxo.
                     * @member {Array.<TW.Bitcoin.Proto.IUnspentTransaction>} utxo
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.utxo = $util.emptyArray;
    
                    /**
                     * SigningInput useMaxAmount.
                     * @member {boolean} useMaxAmount
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.useMaxAmount = false;
    
                    /**
                     * SigningInput coinType.
                     * @member {number} coinType
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.coinType = 0;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {TW.Bitcoin.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Bitcoin.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {TW.Bitcoin.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.hashType != null && message.hasOwnProperty("hashType"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.hashType);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
                        if (message.byteFee != null && message.hasOwnProperty("byteFee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.byteFee);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.toAddress);
                        if (message.changeAddress != null && message.hasOwnProperty("changeAddress"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.changeAddress);
                        if (message.privateKey != null && message.privateKey.length)
                            for (var i = 0; i < message.privateKey.length; ++i)
                                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.privateKey[i]);
                        if (message.scripts != null && message.hasOwnProperty("scripts"))
                            for (var keys = Object.keys(message.scripts), i = 0; i < keys.length; ++i)
                                writer.uint32(/* id 11, wireType 2 =*/90).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.scripts[keys[i]]).ldelim();
                        if (message.utxo != null && message.utxo.length)
                            for (var i = 0; i < message.utxo.length; ++i)
                                $root.TW.Bitcoin.Proto.UnspentTransaction.encode(message.utxo[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        if (message.useMaxAmount != null && message.hasOwnProperty("useMaxAmount"))
                            writer.uint32(/* id 13, wireType 0 =*/104).bool(message.useMaxAmount);
                        if (message.coinType != null && message.hasOwnProperty("coinType"))
                            writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.coinType);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Bitcoin.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {TW.Bitcoin.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.SigningInput(), key;
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.hashType = reader.uint32();
                                break;
                            case 2:
                                message.amount = reader.int64();
                                break;
                            case 3:
                                message.byteFee = reader.int64();
                                break;
                            case 4:
                                message.toAddress = reader.string();
                                break;
                            case 5:
                                message.changeAddress = reader.string();
                                break;
                            case 10:
                                if (!(message.privateKey && message.privateKey.length))
                                    message.privateKey = [];
                                message.privateKey.push(reader.bytes());
                                break;
                            case 11:
                                reader.skip().pos++;
                                if (message.scripts === $util.emptyObject)
                                    message.scripts = {};
                                key = reader.string();
                                reader.pos++;
                                message.scripts[key] = reader.bytes();
                                break;
                            case 12:
                                if (!(message.utxo && message.utxo.length))
                                    message.utxo = [];
                                message.utxo.push($root.TW.Bitcoin.Proto.UnspentTransaction.decode(reader, reader.uint32()));
                                break;
                            case 13:
                                message.useMaxAmount = reader.bool();
                                break;
                            case 14:
                                message.coinType = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Bitcoin.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.hashType != null && message.hasOwnProperty("hashType"))
                            if (!$util.isInteger(message.hashType))
                                return "hashType: integer expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.byteFee != null && message.hasOwnProperty("byteFee"))
                            if (!$util.isInteger(message.byteFee) && !(message.byteFee && $util.isInteger(message.byteFee.low) && $util.isInteger(message.byteFee.high)))
                                return "byteFee: integer|Long expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.changeAddress != null && message.hasOwnProperty("changeAddress"))
                            if (!$util.isString(message.changeAddress))
                                return "changeAddress: string expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey")) {
                            if (!Array.isArray(message.privateKey))
                                return "privateKey: array expected";
                            for (var i = 0; i < message.privateKey.length; ++i)
                                if (!(message.privateKey[i] && typeof message.privateKey[i].length === "number" || $util.isString(message.privateKey[i])))
                                    return "privateKey: buffer[] expected";
                        }
                        if (message.scripts != null && message.hasOwnProperty("scripts")) {
                            if (!$util.isObject(message.scripts))
                                return "scripts: object expected";
                            var key = Object.keys(message.scripts);
                            for (var i = 0; i < key.length; ++i)
                                if (!(message.scripts[key[i]] && typeof message.scripts[key[i]].length === "number" || $util.isString(message.scripts[key[i]])))
                                    return "scripts: buffer{k:string} expected";
                        }
                        if (message.utxo != null && message.hasOwnProperty("utxo")) {
                            if (!Array.isArray(message.utxo))
                                return "utxo: array expected";
                            for (var i = 0; i < message.utxo.length; ++i) {
                                var error = $root.TW.Bitcoin.Proto.UnspentTransaction.verify(message.utxo[i]);
                                if (error)
                                    return "utxo." + error;
                            }
                        }
                        if (message.useMaxAmount != null && message.hasOwnProperty("useMaxAmount"))
                            if (typeof message.useMaxAmount !== "boolean")
                                return "useMaxAmount: boolean expected";
                        if (message.coinType != null && message.hasOwnProperty("coinType"))
                            if (!$util.isInteger(message.coinType))
                                return "coinType: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.SigningInput();
                        if (object.hashType != null)
                            message.hashType = object.hashType >>> 0;
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.byteFee != null)
                            if ($util.Long)
                                (message.byteFee = $util.Long.fromValue(object.byteFee)).unsigned = false;
                            else if (typeof object.byteFee === "string")
                                message.byteFee = parseInt(object.byteFee, 10);
                            else if (typeof object.byteFee === "number")
                                message.byteFee = object.byteFee;
                            else if (typeof object.byteFee === "object")
                                message.byteFee = new $util.LongBits(object.byteFee.low >>> 0, object.byteFee.high >>> 0).toNumber();
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.changeAddress != null)
                            message.changeAddress = String(object.changeAddress);
                        if (object.privateKey) {
                            if (!Array.isArray(object.privateKey))
                                throw TypeError(".TW.Bitcoin.Proto.SigningInput.privateKey: array expected");
                            message.privateKey = [];
                            for (var i = 0; i < object.privateKey.length; ++i)
                                if (typeof object.privateKey[i] === "string")
                                    $util.base64.decode(object.privateKey[i], message.privateKey[i] = $util.newBuffer($util.base64.length(object.privateKey[i])), 0);
                                else if (object.privateKey[i].length)
                                    message.privateKey[i] = object.privateKey[i];
                        }
                        if (object.scripts) {
                            if (typeof object.scripts !== "object")
                                throw TypeError(".TW.Bitcoin.Proto.SigningInput.scripts: object expected");
                            message.scripts = {};
                            for (var keys = Object.keys(object.scripts), i = 0; i < keys.length; ++i)
                                if (typeof object.scripts[keys[i]] === "string")
                                    $util.base64.decode(object.scripts[keys[i]], message.scripts[keys[i]] = $util.newBuffer($util.base64.length(object.scripts[keys[i]])), 0);
                                else if (object.scripts[keys[i]].length)
                                    message.scripts[keys[i]] = object.scripts[keys[i]];
                        }
                        if (object.utxo) {
                            if (!Array.isArray(object.utxo))
                                throw TypeError(".TW.Bitcoin.Proto.SigningInput.utxo: array expected");
                            message.utxo = [];
                            for (var i = 0; i < object.utxo.length; ++i) {
                                if (typeof object.utxo[i] !== "object")
                                    throw TypeError(".TW.Bitcoin.Proto.SigningInput.utxo: object expected");
                                message.utxo[i] = $root.TW.Bitcoin.Proto.UnspentTransaction.fromObject(object.utxo[i]);
                            }
                        }
                        if (object.useMaxAmount != null)
                            message.useMaxAmount = Boolean(object.useMaxAmount);
                        if (object.coinType != null)
                            message.coinType = object.coinType >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @static
                     * @param {TW.Bitcoin.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.privateKey = [];
                            object.utxo = [];
                        }
                        if (options.objects || options.defaults)
                            object.scripts = {};
                        if (options.defaults) {
                            object.hashType = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.byteFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.byteFee = options.longs === String ? "0" : 0;
                            object.toAddress = "";
                            object.changeAddress = "";
                            object.useMaxAmount = false;
                            object.coinType = 0;
                        }
                        if (message.hashType != null && message.hasOwnProperty("hashType"))
                            object.hashType = message.hashType;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.byteFee != null && message.hasOwnProperty("byteFee"))
                            if (typeof message.byteFee === "number")
                                object.byteFee = options.longs === String ? String(message.byteFee) : message.byteFee;
                            else
                                object.byteFee = options.longs === String ? $util.Long.prototype.toString.call(message.byteFee) : options.longs === Number ? new $util.LongBits(message.byteFee.low >>> 0, message.byteFee.high >>> 0).toNumber() : message.byteFee;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.changeAddress != null && message.hasOwnProperty("changeAddress"))
                            object.changeAddress = message.changeAddress;
                        if (message.privateKey && message.privateKey.length) {
                            object.privateKey = [];
                            for (var j = 0; j < message.privateKey.length; ++j)
                                object.privateKey[j] = options.bytes === String ? $util.base64.encode(message.privateKey[j], 0, message.privateKey[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey[j]) : message.privateKey[j];
                        }
                        var keys2;
                        if (message.scripts && (keys2 = Object.keys(message.scripts)).length) {
                            object.scripts = {};
                            for (var j = 0; j < keys2.length; ++j)
                                object.scripts[keys2[j]] = options.bytes === String ? $util.base64.encode(message.scripts[keys2[j]], 0, message.scripts[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.scripts[keys2[j]]) : message.scripts[keys2[j]];
                        }
                        if (message.utxo && message.utxo.length) {
                            object.utxo = [];
                            for (var j = 0; j < message.utxo.length; ++j)
                                object.utxo[j] = $root.TW.Bitcoin.Proto.UnspentTransaction.toObject(message.utxo[j], options);
                        }
                        if (message.useMaxAmount != null && message.hasOwnProperty("useMaxAmount"))
                            object.useMaxAmount = message.useMaxAmount;
                        if (message.coinType != null && message.hasOwnProperty("coinType"))
                            object.coinType = message.coinType;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.TransactionPlan = (function() {
    
                    /**
                     * Properties of a TransactionPlan.
                     * @memberof TW.Bitcoin.Proto
                     * @interface ITransactionPlan
                     * @property {Long|null} [amount] TransactionPlan amount
                     * @property {Long|null} [availableAmount] TransactionPlan availableAmount
                     * @property {Long|null} [fee] TransactionPlan fee
                     * @property {Long|null} [change] TransactionPlan change
                     * @property {Array.<TW.Bitcoin.Proto.IUnspentTransaction>|null} [utxos] TransactionPlan utxos
                     */
    
                    /**
                     * Constructs a new TransactionPlan.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a TransactionPlan.
                     * @implements ITransactionPlan
                     * @constructor
                     * @param {TW.Bitcoin.Proto.ITransactionPlan=} [properties] Properties to set
                     */
                    function TransactionPlan(properties) {
                        this.utxos = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionPlan amount.
                     * @member {Long} amount
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionPlan availableAmount.
                     * @member {Long} availableAmount
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.availableAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionPlan fee.
                     * @member {Long} fee
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionPlan change.
                     * @member {Long} change
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.change = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionPlan utxos.
                     * @member {Array.<TW.Bitcoin.Proto.IUnspentTransaction>} utxos
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.utxos = $util.emptyArray;
    
                    /**
                     * Creates a new TransactionPlan instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionPlan=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.TransactionPlan} TransactionPlan instance
                     */
                    TransactionPlan.create = function create(properties) {
                        return new TransactionPlan(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionPlan message. Does not implicitly {@link TW.Bitcoin.Proto.TransactionPlan.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionPlan} message TransactionPlan message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionPlan.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.amount);
                        if (message.availableAmount != null && message.hasOwnProperty("availableAmount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.availableAmount);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fee);
                        if (message.change != null && message.hasOwnProperty("change"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.change);
                        if (message.utxos != null && message.utxos.length)
                            for (var i = 0; i < message.utxos.length; ++i)
                                $root.TW.Bitcoin.Proto.UnspentTransaction.encode(message.utxos[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TransactionPlan message, length delimited. Does not implicitly {@link TW.Bitcoin.Proto.TransactionPlan.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {TW.Bitcoin.Proto.ITransactionPlan} message TransactionPlan message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionPlan.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TransactionPlan message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.TransactionPlan} TransactionPlan
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionPlan.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.TransactionPlan();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.int64();
                                break;
                            case 2:
                                message.availableAmount = reader.int64();
                                break;
                            case 3:
                                message.fee = reader.int64();
                                break;
                            case 4:
                                message.change = reader.int64();
                                break;
                            case 5:
                                if (!(message.utxos && message.utxos.length))
                                    message.utxos = [];
                                message.utxos.push($root.TW.Bitcoin.Proto.UnspentTransaction.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TransactionPlan message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Bitcoin.Proto.TransactionPlan} TransactionPlan
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionPlan.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TransactionPlan message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionPlan.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.availableAmount != null && message.hasOwnProperty("availableAmount"))
                            if (!$util.isInteger(message.availableAmount) && !(message.availableAmount && $util.isInteger(message.availableAmount.low) && $util.isInteger(message.availableAmount.high)))
                                return "availableAmount: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.change != null && message.hasOwnProperty("change"))
                            if (!$util.isInteger(message.change) && !(message.change && $util.isInteger(message.change.low) && $util.isInteger(message.change.high)))
                                return "change: integer|Long expected";
                        if (message.utxos != null && message.hasOwnProperty("utxos")) {
                            if (!Array.isArray(message.utxos))
                                return "utxos: array expected";
                            for (var i = 0; i < message.utxos.length; ++i) {
                                var error = $root.TW.Bitcoin.Proto.UnspentTransaction.verify(message.utxos[i]);
                                if (error)
                                    return "utxos." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a TransactionPlan message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.TransactionPlan} TransactionPlan
                     */
                    TransactionPlan.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.TransactionPlan)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.TransactionPlan();
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.availableAmount != null)
                            if ($util.Long)
                                (message.availableAmount = $util.Long.fromValue(object.availableAmount)).unsigned = false;
                            else if (typeof object.availableAmount === "string")
                                message.availableAmount = parseInt(object.availableAmount, 10);
                            else if (typeof object.availableAmount === "number")
                                message.availableAmount = object.availableAmount;
                            else if (typeof object.availableAmount === "object")
                                message.availableAmount = new $util.LongBits(object.availableAmount.low >>> 0, object.availableAmount.high >>> 0).toNumber();
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        if (object.change != null)
                            if ($util.Long)
                                (message.change = $util.Long.fromValue(object.change)).unsigned = false;
                            else if (typeof object.change === "string")
                                message.change = parseInt(object.change, 10);
                            else if (typeof object.change === "number")
                                message.change = object.change;
                            else if (typeof object.change === "object")
                                message.change = new $util.LongBits(object.change.low >>> 0, object.change.high >>> 0).toNumber();
                        if (object.utxos) {
                            if (!Array.isArray(object.utxos))
                                throw TypeError(".TW.Bitcoin.Proto.TransactionPlan.utxos: array expected");
                            message.utxos = [];
                            for (var i = 0; i < object.utxos.length; ++i) {
                                if (typeof object.utxos[i] !== "object")
                                    throw TypeError(".TW.Bitcoin.Proto.TransactionPlan.utxos: object expected");
                                message.utxos[i] = $root.TW.Bitcoin.Proto.UnspentTransaction.fromObject(object.utxos[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionPlan message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @static
                     * @param {TW.Bitcoin.Proto.TransactionPlan} message TransactionPlan
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionPlan.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.utxos = [];
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.availableAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.availableAmount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.change = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.change = options.longs === String ? "0" : 0;
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.availableAmount != null && message.hasOwnProperty("availableAmount"))
                            if (typeof message.availableAmount === "number")
                                object.availableAmount = options.longs === String ? String(message.availableAmount) : message.availableAmount;
                            else
                                object.availableAmount = options.longs === String ? $util.Long.prototype.toString.call(message.availableAmount) : options.longs === Number ? new $util.LongBits(message.availableAmount.low >>> 0, message.availableAmount.high >>> 0).toNumber() : message.availableAmount;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.change != null && message.hasOwnProperty("change"))
                            if (typeof message.change === "number")
                                object.change = options.longs === String ? String(message.change) : message.change;
                            else
                                object.change = options.longs === String ? $util.Long.prototype.toString.call(message.change) : options.longs === Number ? new $util.LongBits(message.change.low >>> 0, message.change.high >>> 0).toNumber() : message.change;
                        if (message.utxos && message.utxos.length) {
                            object.utxos = [];
                            for (var j = 0; j < message.utxos.length; ++j)
                                object.utxos[j] = $root.TW.Bitcoin.Proto.UnspentTransaction.toObject(message.utxos[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this TransactionPlan to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.TransactionPlan
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionPlan.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionPlan;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Bitcoin.Proto
                     * @interface ISigningOutput
                     * @property {TW.Bitcoin.Proto.ITransaction|null} [transaction] SigningOutput transaction
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {Long|null} [fee] SigningOutput fee
                     * @property {Long|null} [maxAmount] SigningOutput maxAmount
                     * @property {string|null} [transactionId] SigningOutput transactionId
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Bitcoin.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Bitcoin.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput transaction.
                     * @member {TW.Bitcoin.Proto.ITransaction|null|undefined} transaction
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.transaction = null;
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput fee.
                     * @member {Long} fee
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningOutput maxAmount.
                     * @member {Long} maxAmount
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.maxAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningOutput transactionId.
                     * @member {string} transactionId
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.transactionId = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Bitcoin.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Bitcoin.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            $root.TW.Bitcoin.Proto.Transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encoded);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fee);
                        if (message.maxAmount != null && message.hasOwnProperty("maxAmount"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.maxAmount);
                        if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.transactionId);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Bitcoin.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bitcoin.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bitcoin.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transaction = $root.TW.Bitcoin.Proto.Transaction.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.encoded = reader.bytes();
                                break;
                            case 3:
                                message.fee = reader.int64();
                                break;
                            case 4:
                                message.maxAmount = reader.int64();
                                break;
                            case 5:
                                message.transactionId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Bitcoin.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.transaction != null && message.hasOwnProperty("transaction")) {
                            var error = $root.TW.Bitcoin.Proto.Transaction.verify(message.transaction);
                            if (error)
                                return "transaction." + error;
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.maxAmount != null && message.hasOwnProperty("maxAmount"))
                            if (!$util.isInteger(message.maxAmount) && !(message.maxAmount && $util.isInteger(message.maxAmount.low) && $util.isInteger(message.maxAmount.high)))
                                return "maxAmount: integer|Long expected";
                        if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                            if (!$util.isString(message.transactionId))
                                return "transactionId: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bitcoin.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bitcoin.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Bitcoin.Proto.SigningOutput();
                        if (object.transaction != null) {
                            if (typeof object.transaction !== "object")
                                throw TypeError(".TW.Bitcoin.Proto.SigningOutput.transaction: object expected");
                            message.transaction = $root.TW.Bitcoin.Proto.Transaction.fromObject(object.transaction);
                        }
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        if (object.maxAmount != null)
                            if ($util.Long)
                                (message.maxAmount = $util.Long.fromValue(object.maxAmount)).unsigned = false;
                            else if (typeof object.maxAmount === "string")
                                message.maxAmount = parseInt(object.maxAmount, 10);
                            else if (typeof object.maxAmount === "number")
                                message.maxAmount = object.maxAmount;
                            else if (typeof object.maxAmount === "object")
                                message.maxAmount = new $util.LongBits(object.maxAmount.low >>> 0, object.maxAmount.high >>> 0).toNumber();
                        if (object.transactionId != null)
                            message.transactionId = String(object.transactionId);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @static
                     * @param {TW.Bitcoin.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.transaction = null;
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.maxAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.maxAmount = options.longs === String ? "0" : 0;
                            object.transactionId = "";
                        }
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            object.transaction = $root.TW.Bitcoin.Proto.Transaction.toObject(message.transaction, options);
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.maxAmount != null && message.hasOwnProperty("maxAmount"))
                            if (typeof message.maxAmount === "number")
                                object.maxAmount = options.longs === String ? String(message.maxAmount) : message.maxAmount;
                            else
                                object.maxAmount = options.longs === String ? $util.Long.prototype.toString.call(message.maxAmount) : options.longs === Number ? new $util.LongBits(message.maxAmount.low >>> 0, message.maxAmount.high >>> 0).toNumber() : message.maxAmount;
                        if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                            object.transactionId = message.transactionId;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Bitcoin.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Bitcoin;
        })();
    
        TW.Bravo = (function() {
    
            /**
             * Namespace Bravo.
             * @memberof TW
             * @namespace
             */
            var Bravo = {};
    
            Bravo.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Bravo
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Bravo.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [chainId] SigningInput chainId
                     * @property {string|null} [sender] SigningInput sender
                     * @property {string|null} [recipient] SigningInput recipient
                     * @property {number|null} [amount] SigningInput amount
                     * @property {boolean|null} [testnet] SigningInput testnet
                     * @property {string|null} [memo] SigningInput memo
                     * @property {Uint8Array|null} [referenceBlockId] SigningInput referenceBlockId
                     * @property {number|null} [referenceBlockTime] SigningInput referenceBlockTime
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Bravo.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Bravo.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput chainId.
                     * @member {Uint8Array} chainId
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = $util.newBuffer([]);
    
                    /**
                     * SigningInput sender.
                     * @member {string} sender
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sender = "";
    
                    /**
                     * SigningInput recipient.
                     * @member {string} recipient
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.recipient = "";
    
                    /**
                     * SigningInput amount.
                     * @member {number} amount
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = 0;
    
                    /**
                     * SigningInput testnet.
                     * @member {boolean} testnet
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.testnet = false;
    
                    /**
                     * SigningInput memo.
                     * @member {string} memo
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memo = "";
    
                    /**
                     * SigningInput referenceBlockId.
                     * @member {Uint8Array} referenceBlockId
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.referenceBlockId = $util.newBuffer([]);
    
                    /**
                     * SigningInput referenceBlockTime.
                     * @member {number} referenceBlockTime
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.referenceBlockTime = 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @static
                     * @param {TW.Bravo.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Bravo.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Bravo.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @static
                     * @param {TW.Bravo.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chainId);
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sender);
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.recipient);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 4, wireType 1 =*/33).double(message.amount);
                        if (message.testnet != null && message.hasOwnProperty("testnet"))
                            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.testnet);
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.memo);
                        if (message.referenceBlockId != null && message.hasOwnProperty("referenceBlockId"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.referenceBlockId);
                        if (message.referenceBlockTime != null && message.hasOwnProperty("referenceBlockTime"))
                            writer.uint32(/* id 8, wireType 5 =*/69).sfixed32(message.referenceBlockTime);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Bravo.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @static
                     * @param {TW.Bravo.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bravo.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bravo.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainId = reader.bytes();
                                break;
                            case 2:
                                message.sender = reader.string();
                                break;
                            case 3:
                                message.recipient = reader.string();
                                break;
                            case 4:
                                message.amount = reader.double();
                                break;
                            case 5:
                                message.testnet = reader.bool();
                                break;
                            case 6:
                                message.memo = reader.string();
                                break;
                            case 7:
                                message.referenceBlockId = reader.bytes();
                                break;
                            case 8:
                                message.referenceBlockTime = reader.sfixed32();
                                break;
                            case 9:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Bravo.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!(message.chainId && typeof message.chainId.length === "number" || $util.isString(message.chainId)))
                                return "chainId: buffer expected";
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            if (!$util.isString(message.sender))
                                return "sender: string expected";
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            if (!$util.isString(message.recipient))
                                return "recipient: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount !== "number")
                                return "amount: number expected";
                        if (message.testnet != null && message.hasOwnProperty("testnet"))
                            if (typeof message.testnet !== "boolean")
                                return "testnet: boolean expected";
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.referenceBlockId != null && message.hasOwnProperty("referenceBlockId"))
                            if (!(message.referenceBlockId && typeof message.referenceBlockId.length === "number" || $util.isString(message.referenceBlockId)))
                                return "referenceBlockId: buffer expected";
                        if (message.referenceBlockTime != null && message.hasOwnProperty("referenceBlockTime"))
                            if (!$util.isInteger(message.referenceBlockTime))
                                return "referenceBlockTime: integer expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bravo.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bravo.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Bravo.Proto.SigningInput();
                        if (object.chainId != null)
                            if (typeof object.chainId === "string")
                                $util.base64.decode(object.chainId, message.chainId = $util.newBuffer($util.base64.length(object.chainId)), 0);
                            else if (object.chainId.length)
                                message.chainId = object.chainId;
                        if (object.sender != null)
                            message.sender = String(object.sender);
                        if (object.recipient != null)
                            message.recipient = String(object.recipient);
                        if (object.amount != null)
                            message.amount = Number(object.amount);
                        if (object.testnet != null)
                            message.testnet = Boolean(object.testnet);
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.referenceBlockId != null)
                            if (typeof object.referenceBlockId === "string")
                                $util.base64.decode(object.referenceBlockId, message.referenceBlockId = $util.newBuffer($util.base64.length(object.referenceBlockId)), 0);
                            else if (object.referenceBlockId.length)
                                message.referenceBlockId = object.referenceBlockId;
                        if (object.referenceBlockTime != null)
                            message.referenceBlockTime = object.referenceBlockTime | 0;
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @static
                     * @param {TW.Bravo.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.chainId = "";
                            else {
                                object.chainId = [];
                                if (options.bytes !== Array)
                                    object.chainId = $util.newBuffer(object.chainId);
                            }
                            object.sender = "";
                            object.recipient = "";
                            object.amount = 0;
                            object.testnet = false;
                            object.memo = "";
                            if (options.bytes === String)
                                object.referenceBlockId = "";
                            else {
                                object.referenceBlockId = [];
                                if (options.bytes !== Array)
                                    object.referenceBlockId = $util.newBuffer(object.referenceBlockId);
                            }
                            object.referenceBlockTime = 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = options.bytes === String ? $util.base64.encode(message.chainId, 0, message.chainId.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainId) : message.chainId;
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            object.sender = message.sender;
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            object.recipient = message.recipient;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.json && !isFinite(message.amount) ? String(message.amount) : message.amount;
                        if (message.testnet != null && message.hasOwnProperty("testnet"))
                            object.testnet = message.testnet;
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.referenceBlockId != null && message.hasOwnProperty("referenceBlockId"))
                            object.referenceBlockId = options.bytes === String ? $util.base64.encode(message.referenceBlockId, 0, message.referenceBlockId.length) : options.bytes === Array ? Array.prototype.slice.call(message.referenceBlockId) : message.referenceBlockId;
                        if (message.referenceBlockTime != null && message.hasOwnProperty("referenceBlockTime"))
                            object.referenceBlockTime = message.referenceBlockTime;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Bravo.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Bravo.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [jsonEncoded] SigningOutput jsonEncoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Bravo.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Bravo.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput jsonEncoded.
                     * @member {string} jsonEncoded
                     * @memberof TW.Bravo.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.jsonEncoded = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Bravo.Proto.SigningOutput
                     * @static
                     * @param {TW.Bravo.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Bravo.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Bravo.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Bravo.Proto.SigningOutput
                     * @static
                     * @param {TW.Bravo.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.jsonEncoded != null && message.hasOwnProperty("jsonEncoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.jsonEncoded);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Bravo.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Bravo.Proto.SigningOutput
                     * @static
                     * @param {TW.Bravo.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Bravo.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Bravo.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Bravo.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.jsonEncoded = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Bravo.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Bravo.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Bravo.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.jsonEncoded != null && message.hasOwnProperty("jsonEncoded"))
                            if (!$util.isString(message.jsonEncoded))
                                return "jsonEncoded: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Bravo.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Bravo.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Bravo.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Bravo.Proto.SigningOutput();
                        if (object.jsonEncoded != null)
                            message.jsonEncoded = String(object.jsonEncoded);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Bravo.Proto.SigningOutput
                     * @static
                     * @param {TW.Bravo.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.jsonEncoded = "";
                        if (message.jsonEncoded != null && message.hasOwnProperty("jsonEncoded"))
                            object.jsonEncoded = message.jsonEncoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Bravo.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Bravo;
        })();
    
        TW.Coinex = (function() {
    
            /**
             * Namespace Coinex.
             * @memberof TW
             * @namespace
             */
            var Coinex = {};
    
            Coinex.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Coinex
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Amount = (function() {
    
                    /**
                     * Properties of an Amount.
                     * @memberof TW.Coinex.Proto
                     * @interface IAmount
                     * @property {string|null} [denom] Amount denom
                     * @property {Long|null} [amount] Amount amount
                     */
    
                    /**
                     * Constructs a new Amount.
                     * @memberof TW.Coinex.Proto
                     * @classdesc Represents an Amount.
                     * @implements IAmount
                     * @constructor
                     * @param {TW.Coinex.Proto.IAmount=} [properties] Properties to set
                     */
                    function Amount(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Amount denom.
                     * @member {string} denom
                     * @memberof TW.Coinex.Proto.Amount
                     * @instance
                     */
                    Amount.prototype.denom = "";
    
                    /**
                     * Amount amount.
                     * @member {Long} amount
                     * @memberof TW.Coinex.Proto.Amount
                     * @instance
                     */
                    Amount.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new Amount instance using the specified properties.
                     * @function create
                     * @memberof TW.Coinex.Proto.Amount
                     * @static
                     * @param {TW.Coinex.Proto.IAmount=} [properties] Properties to set
                     * @returns {TW.Coinex.Proto.Amount} Amount instance
                     */
                    Amount.create = function create(properties) {
                        return new Amount(properties);
                    };
    
                    /**
                     * Encodes the specified Amount message. Does not implicitly {@link TW.Coinex.Proto.Amount.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Coinex.Proto.Amount
                     * @static
                     * @param {TW.Coinex.Proto.IAmount} message Amount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Amount.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Amount message, length delimited. Does not implicitly {@link TW.Coinex.Proto.Amount.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Coinex.Proto.Amount
                     * @static
                     * @param {TW.Coinex.Proto.IAmount} message Amount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Amount.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an Amount message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Coinex.Proto.Amount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Coinex.Proto.Amount} Amount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Amount.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Coinex.Proto.Amount();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.denom = reader.string();
                                break;
                            case 2:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an Amount message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Coinex.Proto.Amount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Coinex.Proto.Amount} Amount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Amount.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an Amount message.
                     * @function verify
                     * @memberof TW.Coinex.Proto.Amount
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Amount.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            if (!$util.isString(message.denom))
                                return "denom: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an Amount message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Coinex.Proto.Amount
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Coinex.Proto.Amount} Amount
                     */
                    Amount.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Coinex.Proto.Amount)
                            return object;
                        var message = new $root.TW.Coinex.Proto.Amount();
                        if (object.denom != null)
                            message.denom = String(object.denom);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Amount message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Coinex.Proto.Amount
                     * @static
                     * @param {TW.Coinex.Proto.Amount} message Amount
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Amount.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.denom = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            object.denom = message.denom;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this Amount to JSON.
                     * @function toJSON
                     * @memberof TW.Coinex.Proto.Amount
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Amount.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Amount;
                })();
    
                Proto.Fee = (function() {
    
                    /**
                     * Properties of a Fee.
                     * @memberof TW.Coinex.Proto
                     * @interface IFee
                     * @property {Array.<TW.Coinex.Proto.IAmount>|null} [amounts] Fee amounts
                     * @property {Long|null} [gas] Fee gas
                     */
    
                    /**
                     * Constructs a new Fee.
                     * @memberof TW.Coinex.Proto
                     * @classdesc Represents a Fee.
                     * @implements IFee
                     * @constructor
                     * @param {TW.Coinex.Proto.IFee=} [properties] Properties to set
                     */
                    function Fee(properties) {
                        this.amounts = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Fee amounts.
                     * @member {Array.<TW.Coinex.Proto.IAmount>} amounts
                     * @memberof TW.Coinex.Proto.Fee
                     * @instance
                     */
                    Fee.prototype.amounts = $util.emptyArray;
    
                    /**
                     * Fee gas.
                     * @member {Long} gas
                     * @memberof TW.Coinex.Proto.Fee
                     * @instance
                     */
                    Fee.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new Fee instance using the specified properties.
                     * @function create
                     * @memberof TW.Coinex.Proto.Fee
                     * @static
                     * @param {TW.Coinex.Proto.IFee=} [properties] Properties to set
                     * @returns {TW.Coinex.Proto.Fee} Fee instance
                     */
                    Fee.create = function create(properties) {
                        return new Fee(properties);
                    };
    
                    /**
                     * Encodes the specified Fee message. Does not implicitly {@link TW.Coinex.Proto.Fee.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Coinex.Proto.Fee
                     * @static
                     * @param {TW.Coinex.Proto.IFee} message Fee message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Fee.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amounts != null && message.amounts.length)
                            for (var i = 0; i < message.amounts.length; ++i)
                                $root.TW.Coinex.Proto.Amount.encode(message.amounts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.gas);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Fee message, length delimited. Does not implicitly {@link TW.Coinex.Proto.Fee.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Coinex.Proto.Fee
                     * @static
                     * @param {TW.Coinex.Proto.IFee} message Fee message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Fee.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Fee message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Coinex.Proto.Fee
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Coinex.Proto.Fee} Fee
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Fee.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Coinex.Proto.Fee();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.amounts && message.amounts.length))
                                    message.amounts = [];
                                message.amounts.push($root.TW.Coinex.Proto.Amount.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                message.gas = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Fee message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Coinex.Proto.Fee
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Coinex.Proto.Fee} Fee
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Fee.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Fee message.
                     * @function verify
                     * @memberof TW.Coinex.Proto.Fee
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Fee.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amounts != null && message.hasOwnProperty("amounts")) {
                            if (!Array.isArray(message.amounts))
                                return "amounts: array expected";
                            for (var i = 0; i < message.amounts.length; ++i) {
                                var error = $root.TW.Coinex.Proto.Amount.verify(message.amounts[i]);
                                if (error)
                                    return "amounts." + error;
                            }
                        }
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            if (!$util.isInteger(message.gas) && !(message.gas && $util.isInteger(message.gas.low) && $util.isInteger(message.gas.high)))
                                return "gas: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a Fee message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Coinex.Proto.Fee
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Coinex.Proto.Fee} Fee
                     */
                    Fee.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Coinex.Proto.Fee)
                            return object;
                        var message = new $root.TW.Coinex.Proto.Fee();
                        if (object.amounts) {
                            if (!Array.isArray(object.amounts))
                                throw TypeError(".TW.Coinex.Proto.Fee.amounts: array expected");
                            message.amounts = [];
                            for (var i = 0; i < object.amounts.length; ++i) {
                                if (typeof object.amounts[i] !== "object")
                                    throw TypeError(".TW.Coinex.Proto.Fee.amounts: object expected");
                                message.amounts[i] = $root.TW.Coinex.Proto.Amount.fromObject(object.amounts[i]);
                            }
                        }
                        if (object.gas != null)
                            if ($util.Long)
                                (message.gas = $util.Long.fromValue(object.gas)).unsigned = true;
                            else if (typeof object.gas === "string")
                                message.gas = parseInt(object.gas, 10);
                            else if (typeof object.gas === "number")
                                message.gas = object.gas;
                            else if (typeof object.gas === "object")
                                message.gas = new $util.LongBits(object.gas.low >>> 0, object.gas.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Fee message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Coinex.Proto.Fee
                     * @static
                     * @param {TW.Coinex.Proto.Fee} message Fee
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Fee.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.amounts = [];
                        if (options.defaults)
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gas = options.longs === String ? "0" : 0;
                        if (message.amounts && message.amounts.length) {
                            object.amounts = [];
                            for (var j = 0; j < message.amounts.length; ++j)
                                object.amounts[j] = $root.TW.Coinex.Proto.Amount.toObject(message.amounts[j], options);
                        }
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            if (typeof message.gas === "number")
                                object.gas = options.longs === String ? String(message.gas) : message.gas;
                            else
                                object.gas = options.longs === String ? $util.Long.prototype.toString.call(message.gas) : options.longs === Number ? new $util.LongBits(message.gas.low >>> 0, message.gas.high >>> 0).toNumber(true) : message.gas;
                        return object;
                    };
    
                    /**
                     * Converts this Fee to JSON.
                     * @function toJSON
                     * @memberof TW.Coinex.Proto.Fee
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Fee.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Fee;
                })();
    
                Proto.SendCoinsMessage = (function() {
    
                    /**
                     * Properties of a SendCoinsMessage.
                     * @memberof TW.Coinex.Proto
                     * @interface ISendCoinsMessage
                     * @property {string|null} [fromAddress] SendCoinsMessage fromAddress
                     * @property {string|null} [toAddress] SendCoinsMessage toAddress
                     * @property {Array.<TW.Coinex.Proto.IAmount>|null} [amounts] SendCoinsMessage amounts
                     * @property {Long|null} [unlockTime] SendCoinsMessage unlockTime
                     * @property {string|null} [typePrefix] SendCoinsMessage typePrefix
                     */
    
                    /**
                     * Constructs a new SendCoinsMessage.
                     * @memberof TW.Coinex.Proto
                     * @classdesc Represents a SendCoinsMessage.
                     * @implements ISendCoinsMessage
                     * @constructor
                     * @param {TW.Coinex.Proto.ISendCoinsMessage=} [properties] Properties to set
                     */
                    function SendCoinsMessage(properties) {
                        this.amounts = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SendCoinsMessage fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @instance
                     */
                    SendCoinsMessage.prototype.fromAddress = "";
    
                    /**
                     * SendCoinsMessage toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @instance
                     */
                    SendCoinsMessage.prototype.toAddress = "";
    
                    /**
                     * SendCoinsMessage amounts.
                     * @member {Array.<TW.Coinex.Proto.IAmount>} amounts
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @instance
                     */
                    SendCoinsMessage.prototype.amounts = $util.emptyArray;
    
                    /**
                     * SendCoinsMessage unlockTime.
                     * @member {Long} unlockTime
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @instance
                     */
                    SendCoinsMessage.prototype.unlockTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SendCoinsMessage typePrefix.
                     * @member {string} typePrefix
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @instance
                     */
                    SendCoinsMessage.prototype.typePrefix = "";
    
                    /**
                     * Creates a new SendCoinsMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @static
                     * @param {TW.Coinex.Proto.ISendCoinsMessage=} [properties] Properties to set
                     * @returns {TW.Coinex.Proto.SendCoinsMessage} SendCoinsMessage instance
                     */
                    SendCoinsMessage.create = function create(properties) {
                        return new SendCoinsMessage(properties);
                    };
    
                    /**
                     * Encodes the specified SendCoinsMessage message. Does not implicitly {@link TW.Coinex.Proto.SendCoinsMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @static
                     * @param {TW.Coinex.Proto.ISendCoinsMessage} message SendCoinsMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SendCoinsMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.fromAddress);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.toAddress);
                        if (message.amounts != null && message.amounts.length)
                            for (var i = 0; i < message.amounts.length; ++i)
                                $root.TW.Coinex.Proto.Amount.encode(message.amounts[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.unlockTime != null && message.hasOwnProperty("unlockTime"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.unlockTime);
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.typePrefix);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SendCoinsMessage message, length delimited. Does not implicitly {@link TW.Coinex.Proto.SendCoinsMessage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @static
                     * @param {TW.Coinex.Proto.ISendCoinsMessage} message SendCoinsMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SendCoinsMessage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SendCoinsMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Coinex.Proto.SendCoinsMessage} SendCoinsMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SendCoinsMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Coinex.Proto.SendCoinsMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromAddress = reader.string();
                                break;
                            case 2:
                                message.toAddress = reader.string();
                                break;
                            case 3:
                                if (!(message.amounts && message.amounts.length))
                                    message.amounts = [];
                                message.amounts.push($root.TW.Coinex.Proto.Amount.decode(reader, reader.uint32()));
                                break;
                            case 4:
                                message.unlockTime = reader.int64();
                                break;
                            case 5:
                                message.typePrefix = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SendCoinsMessage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Coinex.Proto.SendCoinsMessage} SendCoinsMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SendCoinsMessage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SendCoinsMessage message.
                     * @function verify
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SendCoinsMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amounts != null && message.hasOwnProperty("amounts")) {
                            if (!Array.isArray(message.amounts))
                                return "amounts: array expected";
                            for (var i = 0; i < message.amounts.length; ++i) {
                                var error = $root.TW.Coinex.Proto.Amount.verify(message.amounts[i]);
                                if (error)
                                    return "amounts." + error;
                            }
                        }
                        if (message.unlockTime != null && message.hasOwnProperty("unlockTime"))
                            if (!$util.isInteger(message.unlockTime) && !(message.unlockTime && $util.isInteger(message.unlockTime.low) && $util.isInteger(message.unlockTime.high)))
                                return "unlockTime: integer|Long expected";
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            if (!$util.isString(message.typePrefix))
                                return "typePrefix: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SendCoinsMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Coinex.Proto.SendCoinsMessage} SendCoinsMessage
                     */
                    SendCoinsMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Coinex.Proto.SendCoinsMessage)
                            return object;
                        var message = new $root.TW.Coinex.Proto.SendCoinsMessage();
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amounts) {
                            if (!Array.isArray(object.amounts))
                                throw TypeError(".TW.Coinex.Proto.SendCoinsMessage.amounts: array expected");
                            message.amounts = [];
                            for (var i = 0; i < object.amounts.length; ++i) {
                                if (typeof object.amounts[i] !== "object")
                                    throw TypeError(".TW.Coinex.Proto.SendCoinsMessage.amounts: object expected");
                                message.amounts[i] = $root.TW.Coinex.Proto.Amount.fromObject(object.amounts[i]);
                            }
                        }
                        if (object.unlockTime != null)
                            if ($util.Long)
                                (message.unlockTime = $util.Long.fromValue(object.unlockTime)).unsigned = false;
                            else if (typeof object.unlockTime === "string")
                                message.unlockTime = parseInt(object.unlockTime, 10);
                            else if (typeof object.unlockTime === "number")
                                message.unlockTime = object.unlockTime;
                            else if (typeof object.unlockTime === "object")
                                message.unlockTime = new $util.LongBits(object.unlockTime.low >>> 0, object.unlockTime.high >>> 0).toNumber();
                        if (object.typePrefix != null)
                            message.typePrefix = String(object.typePrefix);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SendCoinsMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @static
                     * @param {TW.Coinex.Proto.SendCoinsMessage} message SendCoinsMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SendCoinsMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.amounts = [];
                        if (options.defaults) {
                            object.fromAddress = "";
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.unlockTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.unlockTime = options.longs === String ? "0" : 0;
                            object.typePrefix = "";
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amounts && message.amounts.length) {
                            object.amounts = [];
                            for (var j = 0; j < message.amounts.length; ++j)
                                object.amounts[j] = $root.TW.Coinex.Proto.Amount.toObject(message.amounts[j], options);
                        }
                        if (message.unlockTime != null && message.hasOwnProperty("unlockTime"))
                            if (typeof message.unlockTime === "number")
                                object.unlockTime = options.longs === String ? String(message.unlockTime) : message.unlockTime;
                            else
                                object.unlockTime = options.longs === String ? $util.Long.prototype.toString.call(message.unlockTime) : options.longs === Number ? new $util.LongBits(message.unlockTime.low >>> 0, message.unlockTime.high >>> 0).toNumber() : message.unlockTime;
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            object.typePrefix = message.typePrefix;
                        return object;
                    };
    
                    /**
                     * Converts this SendCoinsMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Coinex.Proto.SendCoinsMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SendCoinsMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SendCoinsMessage;
                })();
    
                Proto.StakeMessage = (function() {
    
                    /**
                     * Properties of a StakeMessage.
                     * @memberof TW.Coinex.Proto
                     * @interface IStakeMessage
                     * @property {string|null} [delegatorAddress] StakeMessage delegatorAddress
                     * @property {string|null} [validatorAddress] StakeMessage validatorAddress
                     * @property {TW.Coinex.Proto.IAmount|null} [amount] StakeMessage amount
                     * @property {string|null} [typePrefix] StakeMessage typePrefix
                     */
    
                    /**
                     * Constructs a new StakeMessage.
                     * @memberof TW.Coinex.Proto
                     * @classdesc Represents a StakeMessage.
                     * @implements IStakeMessage
                     * @constructor
                     * @param {TW.Coinex.Proto.IStakeMessage=} [properties] Properties to set
                     */
                    function StakeMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * StakeMessage delegatorAddress.
                     * @member {string} delegatorAddress
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @instance
                     */
                    StakeMessage.prototype.delegatorAddress = "";
    
                    /**
                     * StakeMessage validatorAddress.
                     * @member {string} validatorAddress
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @instance
                     */
                    StakeMessage.prototype.validatorAddress = "";
    
                    /**
                     * StakeMessage amount.
                     * @member {TW.Coinex.Proto.IAmount|null|undefined} amount
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @instance
                     */
                    StakeMessage.prototype.amount = null;
    
                    /**
                     * StakeMessage typePrefix.
                     * @member {string} typePrefix
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @instance
                     */
                    StakeMessage.prototype.typePrefix = "";
    
                    /**
                     * Creates a new StakeMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @static
                     * @param {TW.Coinex.Proto.IStakeMessage=} [properties] Properties to set
                     * @returns {TW.Coinex.Proto.StakeMessage} StakeMessage instance
                     */
                    StakeMessage.create = function create(properties) {
                        return new StakeMessage(properties);
                    };
    
                    /**
                     * Encodes the specified StakeMessage message. Does not implicitly {@link TW.Coinex.Proto.StakeMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @static
                     * @param {TW.Coinex.Proto.IStakeMessage} message StakeMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StakeMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegatorAddress);
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.validatorAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            $root.TW.Coinex.Proto.Amount.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.typePrefix);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified StakeMessage message, length delimited. Does not implicitly {@link TW.Coinex.Proto.StakeMessage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @static
                     * @param {TW.Coinex.Proto.IStakeMessage} message StakeMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StakeMessage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a StakeMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Coinex.Proto.StakeMessage} StakeMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StakeMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Coinex.Proto.StakeMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.delegatorAddress = reader.string();
                                break;
                            case 2:
                                message.validatorAddress = reader.string();
                                break;
                            case 3:
                                message.amount = $root.TW.Coinex.Proto.Amount.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.typePrefix = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a StakeMessage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Coinex.Proto.StakeMessage} StakeMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StakeMessage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a StakeMessage message.
                     * @function verify
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StakeMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            if (!$util.isString(message.delegatorAddress))
                                return "delegatorAddress: string expected";
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            if (!$util.isString(message.validatorAddress))
                                return "validatorAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount")) {
                            var error = $root.TW.Coinex.Proto.Amount.verify(message.amount);
                            if (error)
                                return "amount." + error;
                        }
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            if (!$util.isString(message.typePrefix))
                                return "typePrefix: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a StakeMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Coinex.Proto.StakeMessage} StakeMessage
                     */
                    StakeMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Coinex.Proto.StakeMessage)
                            return object;
                        var message = new $root.TW.Coinex.Proto.StakeMessage();
                        if (object.delegatorAddress != null)
                            message.delegatorAddress = String(object.delegatorAddress);
                        if (object.validatorAddress != null)
                            message.validatorAddress = String(object.validatorAddress);
                        if (object.amount != null) {
                            if (typeof object.amount !== "object")
                                throw TypeError(".TW.Coinex.Proto.StakeMessage.amount: object expected");
                            message.amount = $root.TW.Coinex.Proto.Amount.fromObject(object.amount);
                        }
                        if (object.typePrefix != null)
                            message.typePrefix = String(object.typePrefix);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a StakeMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @static
                     * @param {TW.Coinex.Proto.StakeMessage} message StakeMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StakeMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.delegatorAddress = "";
                            object.validatorAddress = "";
                            object.amount = null;
                            object.typePrefix = "";
                        }
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            object.delegatorAddress = message.delegatorAddress;
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            object.validatorAddress = message.validatorAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = $root.TW.Coinex.Proto.Amount.toObject(message.amount, options);
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            object.typePrefix = message.typePrefix;
                        return object;
                    };
    
                    /**
                     * Converts this StakeMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Coinex.Proto.StakeMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StakeMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return StakeMessage;
                })();
    
                Proto.Signature = (function() {
    
                    /**
                     * Properties of a Signature.
                     * @memberof TW.Coinex.Proto
                     * @interface ISignature
                     * @property {Uint8Array|null} [publicKey] Signature publicKey
                     * @property {Uint8Array|null} [signature] Signature signature
                     */
    
                    /**
                     * Constructs a new Signature.
                     * @memberof TW.Coinex.Proto
                     * @classdesc Represents a Signature.
                     * @implements ISignature
                     * @constructor
                     * @param {TW.Coinex.Proto.ISignature=} [properties] Properties to set
                     */
                    function Signature(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Signature publicKey.
                     * @member {Uint8Array} publicKey
                     * @memberof TW.Coinex.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.publicKey = $util.newBuffer([]);
    
                    /**
                     * Signature signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Coinex.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new Signature instance using the specified properties.
                     * @function create
                     * @memberof TW.Coinex.Proto.Signature
                     * @static
                     * @param {TW.Coinex.Proto.ISignature=} [properties] Properties to set
                     * @returns {TW.Coinex.Proto.Signature} Signature instance
                     */
                    Signature.create = function create(properties) {
                        return new Signature(properties);
                    };
    
                    /**
                     * Encodes the specified Signature message. Does not implicitly {@link TW.Coinex.Proto.Signature.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Coinex.Proto.Signature
                     * @static
                     * @param {TW.Coinex.Proto.ISignature} message Signature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Signature.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Signature message, length delimited. Does not implicitly {@link TW.Coinex.Proto.Signature.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Coinex.Proto.Signature
                     * @static
                     * @param {TW.Coinex.Proto.ISignature} message Signature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Signature.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Signature message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Coinex.Proto.Signature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Coinex.Proto.Signature} Signature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Signature.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Coinex.Proto.Signature();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.publicKey = reader.bytes();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Signature message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Coinex.Proto.Signature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Coinex.Proto.Signature} Signature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Signature.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Signature message.
                     * @function verify
                     * @memberof TW.Coinex.Proto.Signature
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Signature.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                                return "publicKey: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Signature message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Coinex.Proto.Signature
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Coinex.Proto.Signature} Signature
                     */
                    Signature.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Coinex.Proto.Signature)
                            return object;
                        var message = new $root.TW.Coinex.Proto.Signature();
                        if (object.publicKey != null)
                            if (typeof object.publicKey === "string")
                                $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                            else if (object.publicKey.length)
                                message.publicKey = object.publicKey;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Signature message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Coinex.Proto.Signature
                     * @static
                     * @param {TW.Coinex.Proto.Signature} message Signature
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Signature.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.publicKey = "";
                            else {
                                object.publicKey = [];
                                if (options.bytes !== Array)
                                    object.publicKey = $util.newBuffer(object.publicKey);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this Signature to JSON.
                     * @function toJSON
                     * @memberof TW.Coinex.Proto.Signature
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Signature.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Signature;
                })();
    
                Proto.WithdrawStakeRewardMessage = (function() {
    
                    /**
                     * Properties of a WithdrawStakeRewardMessage.
                     * @memberof TW.Coinex.Proto
                     * @interface IWithdrawStakeRewardMessage
                     * @property {string|null} [delegatorAddress] WithdrawStakeRewardMessage delegatorAddress
                     * @property {string|null} [validatorAddress] WithdrawStakeRewardMessage validatorAddress
                     * @property {string|null} [typePrefix] WithdrawStakeRewardMessage typePrefix
                     */
    
                    /**
                     * Constructs a new WithdrawStakeRewardMessage.
                     * @memberof TW.Coinex.Proto
                     * @classdesc Represents a WithdrawStakeRewardMessage.
                     * @implements IWithdrawStakeRewardMessage
                     * @constructor
                     * @param {TW.Coinex.Proto.IWithdrawStakeRewardMessage=} [properties] Properties to set
                     */
                    function WithdrawStakeRewardMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * WithdrawStakeRewardMessage delegatorAddress.
                     * @member {string} delegatorAddress
                     * @memberof TW.Coinex.Proto.WithdrawStakeRewardMessage
                     * @instance
                     */
                    WithdrawStakeRewardMessage.prototype.delegatorAddress = "";
    
                    /**
                     * WithdrawStakeRewardMessage validatorAddress.
                     * @member {string} validatorAddress
                     * @memberof TW.Coinex.Proto.WithdrawStakeRewardMessage
                     * @instance
                     */
                    WithdrawStakeRewardMessage.prototype.validatorAddress = "";
    
                    /**
                     * WithdrawStakeRewardMessage typePrefix.
                     * @member {string} typePrefix
                     * @memberof TW.Coinex.Proto.WithdrawStakeRewardMessage
                     * @instance
                     */
                    WithdrawStakeRewardMessage.prototype.typePrefix = "";
    
                    /**
                     * Creates a new WithdrawStakeRewardMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Coinex.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {TW.Coinex.Proto.IWithdrawStakeRewardMessage=} [properties] Properties to set
                     * @returns {TW.Coinex.Proto.WithdrawStakeRewardMessage} WithdrawStakeRewardMessage instance
                     */
                    WithdrawStakeRewardMessage.create = function create(properties) {
                        return new WithdrawStakeRewardMessage(properties);
                    };
    
                    /**
                     * Encodes the specified WithdrawStakeRewardMessage message. Does not implicitly {@link TW.Coinex.Proto.WithdrawStakeRewardMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Coinex.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {TW.Coinex.Proto.IWithdrawStakeRewardMessage} message WithdrawStakeRewardMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    WithdrawStakeRewardMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegatorAddress);
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.validatorAddress);
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.typePrefix);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified WithdrawStakeRewardMessage message, length delimited. Does not implicitly {@link TW.Coinex.Proto.WithdrawStakeRewardMessage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Coinex.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {TW.Coinex.Proto.IWithdrawStakeRewardMessage} message WithdrawStakeRewardMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    WithdrawStakeRewardMessage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a WithdrawStakeRewardMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Coinex.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Coinex.Proto.WithdrawStakeRewardMessage} WithdrawStakeRewardMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    WithdrawStakeRewardMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Coinex.Proto.WithdrawStakeRewardMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.delegatorAddress = reader.string();
                                break;
                            case 2:
                                message.validatorAddress = reader.string();
                                break;
                            case 3:
                                message.typePrefix = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a WithdrawStakeRewardMessage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Coinex.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Coinex.Proto.WithdrawStakeRewardMessage} WithdrawStakeRewardMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    WithdrawStakeRewardMessage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a WithdrawStakeRewardMessage message.
                     * @function verify
                     * @memberof TW.Coinex.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    WithdrawStakeRewardMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            if (!$util.isString(message.delegatorAddress))
                                return "delegatorAddress: string expected";
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            if (!$util.isString(message.validatorAddress))
                                return "validatorAddress: string expected";
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            if (!$util.isString(message.typePrefix))
                                return "typePrefix: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a WithdrawStakeRewardMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Coinex.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Coinex.Proto.WithdrawStakeRewardMessage} WithdrawStakeRewardMessage
                     */
                    WithdrawStakeRewardMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Coinex.Proto.WithdrawStakeRewardMessage)
                            return object;
                        var message = new $root.TW.Coinex.Proto.WithdrawStakeRewardMessage();
                        if (object.delegatorAddress != null)
                            message.delegatorAddress = String(object.delegatorAddress);
                        if (object.validatorAddress != null)
                            message.validatorAddress = String(object.validatorAddress);
                        if (object.typePrefix != null)
                            message.typePrefix = String(object.typePrefix);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a WithdrawStakeRewardMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Coinex.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {TW.Coinex.Proto.WithdrawStakeRewardMessage} message WithdrawStakeRewardMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    WithdrawStakeRewardMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.delegatorAddress = "";
                            object.validatorAddress = "";
                            object.typePrefix = "";
                        }
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            object.delegatorAddress = message.delegatorAddress;
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            object.validatorAddress = message.validatorAddress;
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            object.typePrefix = message.typePrefix;
                        return object;
                    };
    
                    /**
                     * Converts this WithdrawStakeRewardMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Coinex.Proto.WithdrawStakeRewardMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    WithdrawStakeRewardMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return WithdrawStakeRewardMessage;
                })();
    
                Proto.SetAliasMessage = (function() {
    
                    /**
                     * Properties of a SetAliasMessage.
                     * @memberof TW.Coinex.Proto
                     * @interface ISetAliasMessage
                     * @property {string|null} [owner] SetAliasMessage owner
                     * @property {string|null} [alias] SetAliasMessage alias
                     * @property {boolean|null} [isAdd] SetAliasMessage isAdd
                     * @property {boolean|null} [asDefault] SetAliasMessage asDefault
                     * @property {string|null} [typePrefix] SetAliasMessage typePrefix
                     */
    
                    /**
                     * Constructs a new SetAliasMessage.
                     * @memberof TW.Coinex.Proto
                     * @classdesc Represents a SetAliasMessage.
                     * @implements ISetAliasMessage
                     * @constructor
                     * @param {TW.Coinex.Proto.ISetAliasMessage=} [properties] Properties to set
                     */
                    function SetAliasMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SetAliasMessage owner.
                     * @member {string} owner
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @instance
                     */
                    SetAliasMessage.prototype.owner = "";
    
                    /**
                     * SetAliasMessage alias.
                     * @member {string} alias
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @instance
                     */
                    SetAliasMessage.prototype.alias = "";
    
                    /**
                     * SetAliasMessage isAdd.
                     * @member {boolean} isAdd
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @instance
                     */
                    SetAliasMessage.prototype.isAdd = false;
    
                    /**
                     * SetAliasMessage asDefault.
                     * @member {boolean} asDefault
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @instance
                     */
                    SetAliasMessage.prototype.asDefault = false;
    
                    /**
                     * SetAliasMessage typePrefix.
                     * @member {string} typePrefix
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @instance
                     */
                    SetAliasMessage.prototype.typePrefix = "";
    
                    /**
                     * Creates a new SetAliasMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @static
                     * @param {TW.Coinex.Proto.ISetAliasMessage=} [properties] Properties to set
                     * @returns {TW.Coinex.Proto.SetAliasMessage} SetAliasMessage instance
                     */
                    SetAliasMessage.create = function create(properties) {
                        return new SetAliasMessage(properties);
                    };
    
                    /**
                     * Encodes the specified SetAliasMessage message. Does not implicitly {@link TW.Coinex.Proto.SetAliasMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @static
                     * @param {TW.Coinex.Proto.ISetAliasMessage} message SetAliasMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SetAliasMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.owner != null && message.hasOwnProperty("owner"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.owner);
                        if (message.alias != null && message.hasOwnProperty("alias"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.alias);
                        if (message.isAdd != null && message.hasOwnProperty("isAdd"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isAdd);
                        if (message.asDefault != null && message.hasOwnProperty("asDefault"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.asDefault);
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.typePrefix);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SetAliasMessage message, length delimited. Does not implicitly {@link TW.Coinex.Proto.SetAliasMessage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @static
                     * @param {TW.Coinex.Proto.ISetAliasMessage} message SetAliasMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SetAliasMessage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SetAliasMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Coinex.Proto.SetAliasMessage} SetAliasMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SetAliasMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Coinex.Proto.SetAliasMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.owner = reader.string();
                                break;
                            case 2:
                                message.alias = reader.string();
                                break;
                            case 3:
                                message.isAdd = reader.bool();
                                break;
                            case 4:
                                message.asDefault = reader.bool();
                                break;
                            case 5:
                                message.typePrefix = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SetAliasMessage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Coinex.Proto.SetAliasMessage} SetAliasMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SetAliasMessage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SetAliasMessage message.
                     * @function verify
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SetAliasMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.owner != null && message.hasOwnProperty("owner"))
                            if (!$util.isString(message.owner))
                                return "owner: string expected";
                        if (message.alias != null && message.hasOwnProperty("alias"))
                            if (!$util.isString(message.alias))
                                return "alias: string expected";
                        if (message.isAdd != null && message.hasOwnProperty("isAdd"))
                            if (typeof message.isAdd !== "boolean")
                                return "isAdd: boolean expected";
                        if (message.asDefault != null && message.hasOwnProperty("asDefault"))
                            if (typeof message.asDefault !== "boolean")
                                return "asDefault: boolean expected";
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            if (!$util.isString(message.typePrefix))
                                return "typePrefix: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SetAliasMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Coinex.Proto.SetAliasMessage} SetAliasMessage
                     */
                    SetAliasMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Coinex.Proto.SetAliasMessage)
                            return object;
                        var message = new $root.TW.Coinex.Proto.SetAliasMessage();
                        if (object.owner != null)
                            message.owner = String(object.owner);
                        if (object.alias != null)
                            message.alias = String(object.alias);
                        if (object.isAdd != null)
                            message.isAdd = Boolean(object.isAdd);
                        if (object.asDefault != null)
                            message.asDefault = Boolean(object.asDefault);
                        if (object.typePrefix != null)
                            message.typePrefix = String(object.typePrefix);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SetAliasMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @static
                     * @param {TW.Coinex.Proto.SetAliasMessage} message SetAliasMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SetAliasMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.owner = "";
                            object.alias = "";
                            object.isAdd = false;
                            object.asDefault = false;
                            object.typePrefix = "";
                        }
                        if (message.owner != null && message.hasOwnProperty("owner"))
                            object.owner = message.owner;
                        if (message.alias != null && message.hasOwnProperty("alias"))
                            object.alias = message.alias;
                        if (message.isAdd != null && message.hasOwnProperty("isAdd"))
                            object.isAdd = message.isAdd;
                        if (message.asDefault != null && message.hasOwnProperty("asDefault"))
                            object.asDefault = message.asDefault;
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            object.typePrefix = message.typePrefix;
                        return object;
                    };
    
                    /**
                     * Converts this SetAliasMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Coinex.Proto.SetAliasMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SetAliasMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SetAliasMessage;
                })();
    
                Proto.CreateOrderMessage = (function() {
    
                    /**
                     * Properties of a CreateOrderMessage.
                     * @memberof TW.Coinex.Proto
                     * @interface ICreateOrderMessage
                     * @property {string|null} [sender] CreateOrderMessage sender
                     * @property {string|null} [sequence] CreateOrderMessage sequence
                     * @property {string|null} [tradingPair] CreateOrderMessage tradingPair
                     * @property {Long|null} [orderType] CreateOrderMessage orderType
                     * @property {Long|null} [pricePrecision] CreateOrderMessage pricePrecision
                     * @property {string|null} [price] CreateOrderMessage price
                     * @property {string|null} [quantity] CreateOrderMessage quantity
                     * @property {Long|null} [side] CreateOrderMessage side
                     * @property {string|null} [timeInForce] CreateOrderMessage timeInForce
                     * @property {string|null} [existBlocks] CreateOrderMessage existBlocks
                     * @property {string|null} [typePrefix] CreateOrderMessage typePrefix
                     */
    
                    /**
                     * Constructs a new CreateOrderMessage.
                     * @memberof TW.Coinex.Proto
                     * @classdesc Represents a CreateOrderMessage.
                     * @implements ICreateOrderMessage
                     * @constructor
                     * @param {TW.Coinex.Proto.ICreateOrderMessage=} [properties] Properties to set
                     */
                    function CreateOrderMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * CreateOrderMessage sender.
                     * @member {string} sender
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @instance
                     */
                    CreateOrderMessage.prototype.sender = "";
    
                    /**
                     * CreateOrderMessage sequence.
                     * @member {string} sequence
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @instance
                     */
                    CreateOrderMessage.prototype.sequence = "";
    
                    /**
                     * CreateOrderMessage tradingPair.
                     * @member {string} tradingPair
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @instance
                     */
                    CreateOrderMessage.prototype.tradingPair = "";
    
                    /**
                     * CreateOrderMessage orderType.
                     * @member {Long} orderType
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @instance
                     */
                    CreateOrderMessage.prototype.orderType = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * CreateOrderMessage pricePrecision.
                     * @member {Long} pricePrecision
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @instance
                     */
                    CreateOrderMessage.prototype.pricePrecision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * CreateOrderMessage price.
                     * @member {string} price
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @instance
                     */
                    CreateOrderMessage.prototype.price = "";
    
                    /**
                     * CreateOrderMessage quantity.
                     * @member {string} quantity
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @instance
                     */
                    CreateOrderMessage.prototype.quantity = "";
    
                    /**
                     * CreateOrderMessage side.
                     * @member {Long} side
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @instance
                     */
                    CreateOrderMessage.prototype.side = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * CreateOrderMessage timeInForce.
                     * @member {string} timeInForce
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @instance
                     */
                    CreateOrderMessage.prototype.timeInForce = "";
    
                    /**
                     * CreateOrderMessage existBlocks.
                     * @member {string} existBlocks
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @instance
                     */
                    CreateOrderMessage.prototype.existBlocks = "";
    
                    /**
                     * CreateOrderMessage typePrefix.
                     * @member {string} typePrefix
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @instance
                     */
                    CreateOrderMessage.prototype.typePrefix = "";
    
                    /**
                     * Creates a new CreateOrderMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @static
                     * @param {TW.Coinex.Proto.ICreateOrderMessage=} [properties] Properties to set
                     * @returns {TW.Coinex.Proto.CreateOrderMessage} CreateOrderMessage instance
                     */
                    CreateOrderMessage.create = function create(properties) {
                        return new CreateOrderMessage(properties);
                    };
    
                    /**
                     * Encodes the specified CreateOrderMessage message. Does not implicitly {@link TW.Coinex.Proto.CreateOrderMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @static
                     * @param {TW.Coinex.Proto.ICreateOrderMessage} message CreateOrderMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CreateOrderMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sequence);
                        if (message.tradingPair != null && message.hasOwnProperty("tradingPair"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.tradingPair);
                        if (message.orderType != null && message.hasOwnProperty("orderType"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.orderType);
                        if (message.pricePrecision != null && message.hasOwnProperty("pricePrecision"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.pricePrecision);
                        if (message.price != null && message.hasOwnProperty("price"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.price);
                        if (message.quantity != null && message.hasOwnProperty("quantity"))
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.quantity);
                        if (message.side != null && message.hasOwnProperty("side"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.side);
                        if (message.timeInForce != null && message.hasOwnProperty("timeInForce"))
                            writer.uint32(/* id 9, wireType 2 =*/74).string(message.timeInForce);
                        if (message.existBlocks != null && message.hasOwnProperty("existBlocks"))
                            writer.uint32(/* id 10, wireType 2 =*/82).string(message.existBlocks);
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            writer.uint32(/* id 11, wireType 2 =*/90).string(message.typePrefix);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified CreateOrderMessage message, length delimited. Does not implicitly {@link TW.Coinex.Proto.CreateOrderMessage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @static
                     * @param {TW.Coinex.Proto.ICreateOrderMessage} message CreateOrderMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CreateOrderMessage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a CreateOrderMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Coinex.Proto.CreateOrderMessage} CreateOrderMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CreateOrderMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Coinex.Proto.CreateOrderMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.sender = reader.string();
                                break;
                            case 2:
                                message.sequence = reader.string();
                                break;
                            case 3:
                                message.tradingPair = reader.string();
                                break;
                            case 4:
                                message.orderType = reader.int64();
                                break;
                            case 5:
                                message.pricePrecision = reader.int64();
                                break;
                            case 6:
                                message.price = reader.string();
                                break;
                            case 7:
                                message.quantity = reader.string();
                                break;
                            case 8:
                                message.side = reader.int64();
                                break;
                            case 9:
                                message.timeInForce = reader.string();
                                break;
                            case 10:
                                message.existBlocks = reader.string();
                                break;
                            case 11:
                                message.typePrefix = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a CreateOrderMessage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Coinex.Proto.CreateOrderMessage} CreateOrderMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CreateOrderMessage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a CreateOrderMessage message.
                     * @function verify
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateOrderMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            if (!$util.isString(message.sender))
                                return "sender: string expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isString(message.sequence))
                                return "sequence: string expected";
                        if (message.tradingPair != null && message.hasOwnProperty("tradingPair"))
                            if (!$util.isString(message.tradingPair))
                                return "tradingPair: string expected";
                        if (message.orderType != null && message.hasOwnProperty("orderType"))
                            if (!$util.isInteger(message.orderType) && !(message.orderType && $util.isInteger(message.orderType.low) && $util.isInteger(message.orderType.high)))
                                return "orderType: integer|Long expected";
                        if (message.pricePrecision != null && message.hasOwnProperty("pricePrecision"))
                            if (!$util.isInteger(message.pricePrecision) && !(message.pricePrecision && $util.isInteger(message.pricePrecision.low) && $util.isInteger(message.pricePrecision.high)))
                                return "pricePrecision: integer|Long expected";
                        if (message.price != null && message.hasOwnProperty("price"))
                            if (!$util.isString(message.price))
                                return "price: string expected";
                        if (message.quantity != null && message.hasOwnProperty("quantity"))
                            if (!$util.isString(message.quantity))
                                return "quantity: string expected";
                        if (message.side != null && message.hasOwnProperty("side"))
                            if (!$util.isInteger(message.side) && !(message.side && $util.isInteger(message.side.low) && $util.isInteger(message.side.high)))
                                return "side: integer|Long expected";
                        if (message.timeInForce != null && message.hasOwnProperty("timeInForce"))
                            if (!$util.isString(message.timeInForce))
                                return "timeInForce: string expected";
                        if (message.existBlocks != null && message.hasOwnProperty("existBlocks"))
                            if (!$util.isString(message.existBlocks))
                                return "existBlocks: string expected";
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            if (!$util.isString(message.typePrefix))
                                return "typePrefix: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a CreateOrderMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Coinex.Proto.CreateOrderMessage} CreateOrderMessage
                     */
                    CreateOrderMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Coinex.Proto.CreateOrderMessage)
                            return object;
                        var message = new $root.TW.Coinex.Proto.CreateOrderMessage();
                        if (object.sender != null)
                            message.sender = String(object.sender);
                        if (object.sequence != null)
                            message.sequence = String(object.sequence);
                        if (object.tradingPair != null)
                            message.tradingPair = String(object.tradingPair);
                        if (object.orderType != null)
                            if ($util.Long)
                                (message.orderType = $util.Long.fromValue(object.orderType)).unsigned = false;
                            else if (typeof object.orderType === "string")
                                message.orderType = parseInt(object.orderType, 10);
                            else if (typeof object.orderType === "number")
                                message.orderType = object.orderType;
                            else if (typeof object.orderType === "object")
                                message.orderType = new $util.LongBits(object.orderType.low >>> 0, object.orderType.high >>> 0).toNumber();
                        if (object.pricePrecision != null)
                            if ($util.Long)
                                (message.pricePrecision = $util.Long.fromValue(object.pricePrecision)).unsigned = false;
                            else if (typeof object.pricePrecision === "string")
                                message.pricePrecision = parseInt(object.pricePrecision, 10);
                            else if (typeof object.pricePrecision === "number")
                                message.pricePrecision = object.pricePrecision;
                            else if (typeof object.pricePrecision === "object")
                                message.pricePrecision = new $util.LongBits(object.pricePrecision.low >>> 0, object.pricePrecision.high >>> 0).toNumber();
                        if (object.price != null)
                            message.price = String(object.price);
                        if (object.quantity != null)
                            message.quantity = String(object.quantity);
                        if (object.side != null)
                            if ($util.Long)
                                (message.side = $util.Long.fromValue(object.side)).unsigned = false;
                            else if (typeof object.side === "string")
                                message.side = parseInt(object.side, 10);
                            else if (typeof object.side === "number")
                                message.side = object.side;
                            else if (typeof object.side === "object")
                                message.side = new $util.LongBits(object.side.low >>> 0, object.side.high >>> 0).toNumber();
                        if (object.timeInForce != null)
                            message.timeInForce = String(object.timeInForce);
                        if (object.existBlocks != null)
                            message.existBlocks = String(object.existBlocks);
                        if (object.typePrefix != null)
                            message.typePrefix = String(object.typePrefix);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a CreateOrderMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @static
                     * @param {TW.Coinex.Proto.CreateOrderMessage} message CreateOrderMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateOrderMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.sender = "";
                            object.sequence = "";
                            object.tradingPair = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.orderType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.orderType = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.pricePrecision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.pricePrecision = options.longs === String ? "0" : 0;
                            object.price = "";
                            object.quantity = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.side = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.side = options.longs === String ? "0" : 0;
                            object.timeInForce = "";
                            object.existBlocks = "";
                            object.typePrefix = "";
                        }
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            object.sender = message.sender;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            object.sequence = message.sequence;
                        if (message.tradingPair != null && message.hasOwnProperty("tradingPair"))
                            object.tradingPair = message.tradingPair;
                        if (message.orderType != null && message.hasOwnProperty("orderType"))
                            if (typeof message.orderType === "number")
                                object.orderType = options.longs === String ? String(message.orderType) : message.orderType;
                            else
                                object.orderType = options.longs === String ? $util.Long.prototype.toString.call(message.orderType) : options.longs === Number ? new $util.LongBits(message.orderType.low >>> 0, message.orderType.high >>> 0).toNumber() : message.orderType;
                        if (message.pricePrecision != null && message.hasOwnProperty("pricePrecision"))
                            if (typeof message.pricePrecision === "number")
                                object.pricePrecision = options.longs === String ? String(message.pricePrecision) : message.pricePrecision;
                            else
                                object.pricePrecision = options.longs === String ? $util.Long.prototype.toString.call(message.pricePrecision) : options.longs === Number ? new $util.LongBits(message.pricePrecision.low >>> 0, message.pricePrecision.high >>> 0).toNumber() : message.pricePrecision;
                        if (message.price != null && message.hasOwnProperty("price"))
                            object.price = message.price;
                        if (message.quantity != null && message.hasOwnProperty("quantity"))
                            object.quantity = message.quantity;
                        if (message.side != null && message.hasOwnProperty("side"))
                            if (typeof message.side === "number")
                                object.side = options.longs === String ? String(message.side) : message.side;
                            else
                                object.side = options.longs === String ? $util.Long.prototype.toString.call(message.side) : options.longs === Number ? new $util.LongBits(message.side.low >>> 0, message.side.high >>> 0).toNumber() : message.side;
                        if (message.timeInForce != null && message.hasOwnProperty("timeInForce"))
                            object.timeInForce = message.timeInForce;
                        if (message.existBlocks != null && message.hasOwnProperty("existBlocks"))
                            object.existBlocks = message.existBlocks;
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            object.typePrefix = message.typePrefix;
                        return object;
                    };
    
                    /**
                     * Converts this CreateOrderMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Coinex.Proto.CreateOrderMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateOrderMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return CreateOrderMessage;
                })();
    
                Proto.CancelOrderMessage = (function() {
    
                    /**
                     * Properties of a CancelOrderMessage.
                     * @memberof TW.Coinex.Proto
                     * @interface ICancelOrderMessage
                     * @property {string|null} [orderId] CancelOrderMessage orderId
                     * @property {string|null} [sender] CancelOrderMessage sender
                     * @property {string|null} [typePrefix] CancelOrderMessage typePrefix
                     */
    
                    /**
                     * Constructs a new CancelOrderMessage.
                     * @memberof TW.Coinex.Proto
                     * @classdesc Represents a CancelOrderMessage.
                     * @implements ICancelOrderMessage
                     * @constructor
                     * @param {TW.Coinex.Proto.ICancelOrderMessage=} [properties] Properties to set
                     */
                    function CancelOrderMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * CancelOrderMessage orderId.
                     * @member {string} orderId
                     * @memberof TW.Coinex.Proto.CancelOrderMessage
                     * @instance
                     */
                    CancelOrderMessage.prototype.orderId = "";
    
                    /**
                     * CancelOrderMessage sender.
                     * @member {string} sender
                     * @memberof TW.Coinex.Proto.CancelOrderMessage
                     * @instance
                     */
                    CancelOrderMessage.prototype.sender = "";
    
                    /**
                     * CancelOrderMessage typePrefix.
                     * @member {string} typePrefix
                     * @memberof TW.Coinex.Proto.CancelOrderMessage
                     * @instance
                     */
                    CancelOrderMessage.prototype.typePrefix = "";
    
                    /**
                     * Creates a new CancelOrderMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Coinex.Proto.CancelOrderMessage
                     * @static
                     * @param {TW.Coinex.Proto.ICancelOrderMessage=} [properties] Properties to set
                     * @returns {TW.Coinex.Proto.CancelOrderMessage} CancelOrderMessage instance
                     */
                    CancelOrderMessage.create = function create(properties) {
                        return new CancelOrderMessage(properties);
                    };
    
                    /**
                     * Encodes the specified CancelOrderMessage message. Does not implicitly {@link TW.Coinex.Proto.CancelOrderMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Coinex.Proto.CancelOrderMessage
                     * @static
                     * @param {TW.Coinex.Proto.ICancelOrderMessage} message CancelOrderMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CancelOrderMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.orderId != null && message.hasOwnProperty("orderId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.orderId);
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sender);
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.typePrefix);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified CancelOrderMessage message, length delimited. Does not implicitly {@link TW.Coinex.Proto.CancelOrderMessage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Coinex.Proto.CancelOrderMessage
                     * @static
                     * @param {TW.Coinex.Proto.ICancelOrderMessage} message CancelOrderMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CancelOrderMessage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a CancelOrderMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Coinex.Proto.CancelOrderMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Coinex.Proto.CancelOrderMessage} CancelOrderMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CancelOrderMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Coinex.Proto.CancelOrderMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.orderId = reader.string();
                                break;
                            case 2:
                                message.sender = reader.string();
                                break;
                            case 3:
                                message.typePrefix = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a CancelOrderMessage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Coinex.Proto.CancelOrderMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Coinex.Proto.CancelOrderMessage} CancelOrderMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CancelOrderMessage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a CancelOrderMessage message.
                     * @function verify
                     * @memberof TW.Coinex.Proto.CancelOrderMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CancelOrderMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.orderId != null && message.hasOwnProperty("orderId"))
                            if (!$util.isString(message.orderId))
                                return "orderId: string expected";
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            if (!$util.isString(message.sender))
                                return "sender: string expected";
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            if (!$util.isString(message.typePrefix))
                                return "typePrefix: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a CancelOrderMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Coinex.Proto.CancelOrderMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Coinex.Proto.CancelOrderMessage} CancelOrderMessage
                     */
                    CancelOrderMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Coinex.Proto.CancelOrderMessage)
                            return object;
                        var message = new $root.TW.Coinex.Proto.CancelOrderMessage();
                        if (object.orderId != null)
                            message.orderId = String(object.orderId);
                        if (object.sender != null)
                            message.sender = String(object.sender);
                        if (object.typePrefix != null)
                            message.typePrefix = String(object.typePrefix);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a CancelOrderMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Coinex.Proto.CancelOrderMessage
                     * @static
                     * @param {TW.Coinex.Proto.CancelOrderMessage} message CancelOrderMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CancelOrderMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.orderId = "";
                            object.sender = "";
                            object.typePrefix = "";
                        }
                        if (message.orderId != null && message.hasOwnProperty("orderId"))
                            object.orderId = message.orderId;
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            object.sender = message.sender;
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            object.typePrefix = message.typePrefix;
                        return object;
                    };
    
                    /**
                     * Converts this CancelOrderMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Coinex.Proto.CancelOrderMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CancelOrderMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return CancelOrderMessage;
                })();
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.Coinex.Proto
                     * @interface ITransaction
                     * @property {TW.Coinex.Proto.IFee|null} [fee] Transaction fee
                     * @property {string|null} [memo] Transaction memo
                     * @property {TW.Coinex.Proto.ISignature|null} [signature] Transaction signature
                     * @property {TW.Coinex.Proto.ISendCoinsMessage|null} [sendCoinsMessage] Transaction sendCoinsMessage
                     * @property {TW.Coinex.Proto.IStakeMessage|null} [stakeMessage] Transaction stakeMessage
                     * @property {TW.Coinex.Proto.IStakeMessage|null} [unstakeMessage] Transaction unstakeMessage
                     * @property {TW.Coinex.Proto.IWithdrawStakeRewardMessage|null} [withdrawStakeRewardMessage] Transaction withdrawStakeRewardMessage
                     * @property {TW.Coinex.Proto.ISetAliasMessage|null} [setAliasMessage] Transaction setAliasMessage
                     * @property {TW.Coinex.Proto.ICreateOrderMessage|null} [createOrderMessage] Transaction createOrderMessage
                     * @property {TW.Coinex.Proto.ICancelOrderMessage|null} [cancelOrderMessage] Transaction cancelOrderMessage
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.Coinex.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.Coinex.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction fee.
                     * @member {TW.Coinex.Proto.IFee|null|undefined} fee
                     * @memberof TW.Coinex.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.fee = null;
    
                    /**
                     * Transaction memo.
                     * @member {string} memo
                     * @memberof TW.Coinex.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.memo = "";
    
                    /**
                     * Transaction signature.
                     * @member {TW.Coinex.Proto.ISignature|null|undefined} signature
                     * @memberof TW.Coinex.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.signature = null;
    
                    /**
                     * Transaction sendCoinsMessage.
                     * @member {TW.Coinex.Proto.ISendCoinsMessage|null|undefined} sendCoinsMessage
                     * @memberof TW.Coinex.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.sendCoinsMessage = null;
    
                    /**
                     * Transaction stakeMessage.
                     * @member {TW.Coinex.Proto.IStakeMessage|null|undefined} stakeMessage
                     * @memberof TW.Coinex.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.stakeMessage = null;
    
                    /**
                     * Transaction unstakeMessage.
                     * @member {TW.Coinex.Proto.IStakeMessage|null|undefined} unstakeMessage
                     * @memberof TW.Coinex.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.unstakeMessage = null;
    
                    /**
                     * Transaction withdrawStakeRewardMessage.
                     * @member {TW.Coinex.Proto.IWithdrawStakeRewardMessage|null|undefined} withdrawStakeRewardMessage
                     * @memberof TW.Coinex.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.withdrawStakeRewardMessage = null;
    
                    /**
                     * Transaction setAliasMessage.
                     * @member {TW.Coinex.Proto.ISetAliasMessage|null|undefined} setAliasMessage
                     * @memberof TW.Coinex.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.setAliasMessage = null;
    
                    /**
                     * Transaction createOrderMessage.
                     * @member {TW.Coinex.Proto.ICreateOrderMessage|null|undefined} createOrderMessage
                     * @memberof TW.Coinex.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.createOrderMessage = null;
    
                    /**
                     * Transaction cancelOrderMessage.
                     * @member {TW.Coinex.Proto.ICancelOrderMessage|null|undefined} cancelOrderMessage
                     * @memberof TW.Coinex.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.cancelOrderMessage = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Transaction messageOneof.
                     * @member {"sendCoinsMessage"|"stakeMessage"|"unstakeMessage"|"withdrawStakeRewardMessage"|"setAliasMessage"|"createOrderMessage"|"cancelOrderMessage"|undefined} messageOneof
                     * @memberof TW.Coinex.Proto.Transaction
                     * @instance
                     */
                    Object.defineProperty(Transaction.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["sendCoinsMessage", "stakeMessage", "unstakeMessage", "withdrawStakeRewardMessage", "setAliasMessage", "createOrderMessage", "cancelOrderMessage"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Coinex.Proto.Transaction
                     * @static
                     * @param {TW.Coinex.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.Coinex.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.Coinex.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Coinex.Proto.Transaction
                     * @static
                     * @param {TW.Coinex.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            $root.TW.Coinex.Proto.Fee.encode(message.fee, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.memo);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            $root.TW.Coinex.Proto.Signature.encode(message.signature, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage"))
                            $root.TW.Coinex.Proto.SendCoinsMessage.encode(message.sendCoinsMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage"))
                            $root.TW.Coinex.Proto.StakeMessage.encode(message.stakeMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage"))
                            $root.TW.Coinex.Proto.StakeMessage.encode(message.unstakeMessage, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage"))
                            $root.TW.Coinex.Proto.WithdrawStakeRewardMessage.encode(message.withdrawStakeRewardMessage, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.setAliasMessage != null && message.hasOwnProperty("setAliasMessage"))
                            $root.TW.Coinex.Proto.SetAliasMessage.encode(message.setAliasMessage, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.createOrderMessage != null && message.hasOwnProperty("createOrderMessage"))
                            $root.TW.Coinex.Proto.CreateOrderMessage.encode(message.createOrderMessage, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.cancelOrderMessage != null && message.hasOwnProperty("cancelOrderMessage"))
                            $root.TW.Coinex.Proto.CancelOrderMessage.encode(message.cancelOrderMessage, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Transaction message, length delimited. Does not implicitly {@link TW.Coinex.Proto.Transaction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Coinex.Proto.Transaction
                     * @static
                     * @param {TW.Coinex.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Coinex.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Coinex.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Coinex.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fee = $root.TW.Coinex.Proto.Fee.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.memo = reader.string();
                                break;
                            case 3:
                                message.signature = $root.TW.Coinex.Proto.Signature.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.sendCoinsMessage = $root.TW.Coinex.Proto.SendCoinsMessage.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.stakeMessage = $root.TW.Coinex.Proto.StakeMessage.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.unstakeMessage = $root.TW.Coinex.Proto.StakeMessage.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.withdrawStakeRewardMessage = $root.TW.Coinex.Proto.WithdrawStakeRewardMessage.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.setAliasMessage = $root.TW.Coinex.Proto.SetAliasMessage.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.createOrderMessage = $root.TW.Coinex.Proto.CreateOrderMessage.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.cancelOrderMessage = $root.TW.Coinex.Proto.CancelOrderMessage.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Coinex.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Coinex.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.Coinex.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.fee != null && message.hasOwnProperty("fee")) {
                            var error = $root.TW.Coinex.Proto.Fee.verify(message.fee);
                            if (error)
                                return "fee." + error;
                        }
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.signature != null && message.hasOwnProperty("signature")) {
                            var error = $root.TW.Coinex.Proto.Signature.verify(message.signature);
                            if (error)
                                return "signature." + error;
                        }
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.SendCoinsMessage.verify(message.sendCoinsMessage);
                                if (error)
                                    return "sendCoinsMessage." + error;
                            }
                        }
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.StakeMessage.verify(message.stakeMessage);
                                if (error)
                                    return "stakeMessage." + error;
                            }
                        }
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.StakeMessage.verify(message.unstakeMessage);
                                if (error)
                                    return "unstakeMessage." + error;
                            }
                        }
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.WithdrawStakeRewardMessage.verify(message.withdrawStakeRewardMessage);
                                if (error)
                                    return "withdrawStakeRewardMessage." + error;
                            }
                        }
                        if (message.setAliasMessage != null && message.hasOwnProperty("setAliasMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.SetAliasMessage.verify(message.setAliasMessage);
                                if (error)
                                    return "setAliasMessage." + error;
                            }
                        }
                        if (message.createOrderMessage != null && message.hasOwnProperty("createOrderMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.CreateOrderMessage.verify(message.createOrderMessage);
                                if (error)
                                    return "createOrderMessage." + error;
                            }
                        }
                        if (message.cancelOrderMessage != null && message.hasOwnProperty("cancelOrderMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.CancelOrderMessage.verify(message.cancelOrderMessage);
                                if (error)
                                    return "cancelOrderMessage." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Coinex.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Coinex.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Coinex.Proto.Transaction)
                            return object;
                        var message = new $root.TW.Coinex.Proto.Transaction();
                        if (object.fee != null) {
                            if (typeof object.fee !== "object")
                                throw TypeError(".TW.Coinex.Proto.Transaction.fee: object expected");
                            message.fee = $root.TW.Coinex.Proto.Fee.fromObject(object.fee);
                        }
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.signature != null) {
                            if (typeof object.signature !== "object")
                                throw TypeError(".TW.Coinex.Proto.Transaction.signature: object expected");
                            message.signature = $root.TW.Coinex.Proto.Signature.fromObject(object.signature);
                        }
                        if (object.sendCoinsMessage != null) {
                            if (typeof object.sendCoinsMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.Transaction.sendCoinsMessage: object expected");
                            message.sendCoinsMessage = $root.TW.Coinex.Proto.SendCoinsMessage.fromObject(object.sendCoinsMessage);
                        }
                        if (object.stakeMessage != null) {
                            if (typeof object.stakeMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.Transaction.stakeMessage: object expected");
                            message.stakeMessage = $root.TW.Coinex.Proto.StakeMessage.fromObject(object.stakeMessage);
                        }
                        if (object.unstakeMessage != null) {
                            if (typeof object.unstakeMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.Transaction.unstakeMessage: object expected");
                            message.unstakeMessage = $root.TW.Coinex.Proto.StakeMessage.fromObject(object.unstakeMessage);
                        }
                        if (object.withdrawStakeRewardMessage != null) {
                            if (typeof object.withdrawStakeRewardMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.Transaction.withdrawStakeRewardMessage: object expected");
                            message.withdrawStakeRewardMessage = $root.TW.Coinex.Proto.WithdrawStakeRewardMessage.fromObject(object.withdrawStakeRewardMessage);
                        }
                        if (object.setAliasMessage != null) {
                            if (typeof object.setAliasMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.Transaction.setAliasMessage: object expected");
                            message.setAliasMessage = $root.TW.Coinex.Proto.SetAliasMessage.fromObject(object.setAliasMessage);
                        }
                        if (object.createOrderMessage != null) {
                            if (typeof object.createOrderMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.Transaction.createOrderMessage: object expected");
                            message.createOrderMessage = $root.TW.Coinex.Proto.CreateOrderMessage.fromObject(object.createOrderMessage);
                        }
                        if (object.cancelOrderMessage != null) {
                            if (typeof object.cancelOrderMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.Transaction.cancelOrderMessage: object expected");
                            message.cancelOrderMessage = $root.TW.Coinex.Proto.CancelOrderMessage.fromObject(object.cancelOrderMessage);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Coinex.Proto.Transaction
                     * @static
                     * @param {TW.Coinex.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fee = null;
                            object.memo = "";
                            object.signature = null;
                        }
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            object.fee = $root.TW.Coinex.Proto.Fee.toObject(message.fee, options);
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = $root.TW.Coinex.Proto.Signature.toObject(message.signature, options);
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage")) {
                            object.sendCoinsMessage = $root.TW.Coinex.Proto.SendCoinsMessage.toObject(message.sendCoinsMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "sendCoinsMessage";
                        }
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage")) {
                            object.stakeMessage = $root.TW.Coinex.Proto.StakeMessage.toObject(message.stakeMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "stakeMessage";
                        }
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage")) {
                            object.unstakeMessage = $root.TW.Coinex.Proto.StakeMessage.toObject(message.unstakeMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "unstakeMessage";
                        }
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage")) {
                            object.withdrawStakeRewardMessage = $root.TW.Coinex.Proto.WithdrawStakeRewardMessage.toObject(message.withdrawStakeRewardMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "withdrawStakeRewardMessage";
                        }
                        if (message.setAliasMessage != null && message.hasOwnProperty("setAliasMessage")) {
                            object.setAliasMessage = $root.TW.Coinex.Proto.SetAliasMessage.toObject(message.setAliasMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "setAliasMessage";
                        }
                        if (message.createOrderMessage != null && message.hasOwnProperty("createOrderMessage")) {
                            object.createOrderMessage = $root.TW.Coinex.Proto.CreateOrderMessage.toObject(message.createOrderMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "createOrderMessage";
                        }
                        if (message.cancelOrderMessage != null && message.hasOwnProperty("cancelOrderMessage")) {
                            object.cancelOrderMessage = $root.TW.Coinex.Proto.CancelOrderMessage.toObject(message.cancelOrderMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "cancelOrderMessage";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.Coinex.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Coinex.Proto
                     * @interface ISigningInput
                     * @property {Long|null} [accountNumber] SigningInput accountNumber
                     * @property {string|null} [chainId] SigningInput chainId
                     * @property {TW.Coinex.Proto.IFee|null} [fee] SigningInput fee
                     * @property {string|null} [memo] SigningInput memo
                     * @property {Long|null} [sequence] SigningInput sequence
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.Coinex.Proto.ISendCoinsMessage|null} [sendCoinsMessage] SigningInput sendCoinsMessage
                     * @property {TW.Coinex.Proto.IStakeMessage|null} [stakeMessage] SigningInput stakeMessage
                     * @property {TW.Coinex.Proto.IStakeMessage|null} [unstakeMessage] SigningInput unstakeMessage
                     * @property {TW.Coinex.Proto.IWithdrawStakeRewardMessage|null} [withdrawStakeRewardMessage] SigningInput withdrawStakeRewardMessage
                     * @property {TW.Coinex.Proto.ISetAliasMessage|null} [setAliasMessage] SigningInput setAliasMessage
                     * @property {TW.Coinex.Proto.ICreateOrderMessage|null} [createOrderMessage] SigningInput createOrderMessage
                     * @property {TW.Coinex.Proto.ICancelOrderMessage|null} [cancelOrderMessage] SigningInput cancelOrderMessage
                     * @property {string|null} [typePrefix] SigningInput typePrefix
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Coinex.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Coinex.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput accountNumber.
                     * @member {Long} accountNumber
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.accountNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput chainId.
                     * @member {string} chainId
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = "";
    
                    /**
                     * SigningInput fee.
                     * @member {TW.Coinex.Proto.IFee|null|undefined} fee
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = null;
    
                    /**
                     * SigningInput memo.
                     * @member {string} memo
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memo = "";
    
                    /**
                     * SigningInput sequence.
                     * @member {Long} sequence
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput sendCoinsMessage.
                     * @member {TW.Coinex.Proto.ISendCoinsMessage|null|undefined} sendCoinsMessage
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sendCoinsMessage = null;
    
                    /**
                     * SigningInput stakeMessage.
                     * @member {TW.Coinex.Proto.IStakeMessage|null|undefined} stakeMessage
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stakeMessage = null;
    
                    /**
                     * SigningInput unstakeMessage.
                     * @member {TW.Coinex.Proto.IStakeMessage|null|undefined} unstakeMessage
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.unstakeMessage = null;
    
                    /**
                     * SigningInput withdrawStakeRewardMessage.
                     * @member {TW.Coinex.Proto.IWithdrawStakeRewardMessage|null|undefined} withdrawStakeRewardMessage
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.withdrawStakeRewardMessage = null;
    
                    /**
                     * SigningInput setAliasMessage.
                     * @member {TW.Coinex.Proto.ISetAliasMessage|null|undefined} setAliasMessage
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.setAliasMessage = null;
    
                    /**
                     * SigningInput createOrderMessage.
                     * @member {TW.Coinex.Proto.ICreateOrderMessage|null|undefined} createOrderMessage
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.createOrderMessage = null;
    
                    /**
                     * SigningInput cancelOrderMessage.
                     * @member {TW.Coinex.Proto.ICancelOrderMessage|null|undefined} cancelOrderMessage
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.cancelOrderMessage = null;
    
                    /**
                     * SigningInput typePrefix.
                     * @member {string} typePrefix
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.typePrefix = "";
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput messageOneof.
                     * @member {"sendCoinsMessage"|"stakeMessage"|"unstakeMessage"|"withdrawStakeRewardMessage"|"setAliasMessage"|"createOrderMessage"|"cancelOrderMessage"|undefined} messageOneof
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["sendCoinsMessage", "stakeMessage", "unstakeMessage", "withdrawStakeRewardMessage", "setAliasMessage", "createOrderMessage", "cancelOrderMessage"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @static
                     * @param {TW.Coinex.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Coinex.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Coinex.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @static
                     * @param {TW.Coinex.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.accountNumber);
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.chainId);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            $root.TW.Coinex.Proto.Fee.encode(message.fee, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.memo);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.sequence);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.privateKey);
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage"))
                            $root.TW.Coinex.Proto.SendCoinsMessage.encode(message.sendCoinsMessage, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage"))
                            $root.TW.Coinex.Proto.StakeMessage.encode(message.stakeMessage, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage"))
                            $root.TW.Coinex.Proto.StakeMessage.encode(message.unstakeMessage, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage"))
                            $root.TW.Coinex.Proto.WithdrawStakeRewardMessage.encode(message.withdrawStakeRewardMessage, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.setAliasMessage != null && message.hasOwnProperty("setAliasMessage"))
                            $root.TW.Coinex.Proto.SetAliasMessage.encode(message.setAliasMessage, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        if (message.createOrderMessage != null && message.hasOwnProperty("createOrderMessage"))
                            $root.TW.Coinex.Proto.CreateOrderMessage.encode(message.createOrderMessage, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        if (message.cancelOrderMessage != null && message.hasOwnProperty("cancelOrderMessage"))
                            $root.TW.Coinex.Proto.CancelOrderMessage.encode(message.cancelOrderMessage, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            writer.uint32(/* id 14, wireType 2 =*/114).string(message.typePrefix);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Coinex.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @static
                     * @param {TW.Coinex.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Coinex.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Coinex.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.accountNumber = reader.uint64();
                                break;
                            case 2:
                                message.chainId = reader.string();
                                break;
                            case 3:
                                message.fee = $root.TW.Coinex.Proto.Fee.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.memo = reader.string();
                                break;
                            case 5:
                                message.sequence = reader.uint64();
                                break;
                            case 6:
                                message.privateKey = reader.bytes();
                                break;
                            case 7:
                                message.sendCoinsMessage = $root.TW.Coinex.Proto.SendCoinsMessage.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.stakeMessage = $root.TW.Coinex.Proto.StakeMessage.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.unstakeMessage = $root.TW.Coinex.Proto.StakeMessage.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.withdrawStakeRewardMessage = $root.TW.Coinex.Proto.WithdrawStakeRewardMessage.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.setAliasMessage = $root.TW.Coinex.Proto.SetAliasMessage.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.createOrderMessage = $root.TW.Coinex.Proto.CreateOrderMessage.decode(reader, reader.uint32());
                                break;
                            case 13:
                                message.cancelOrderMessage = $root.TW.Coinex.Proto.CancelOrderMessage.decode(reader, reader.uint32());
                                break;
                            case 14:
                                message.typePrefix = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Coinex.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (!$util.isInteger(message.accountNumber) && !(message.accountNumber && $util.isInteger(message.accountNumber.low) && $util.isInteger(message.accountNumber.high)))
                                return "accountNumber: integer|Long expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isString(message.chainId))
                                return "chainId: string expected";
                        if (message.fee != null && message.hasOwnProperty("fee")) {
                            var error = $root.TW.Coinex.Proto.Fee.verify(message.fee);
                            if (error)
                                return "fee." + error;
                        }
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                                return "sequence: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.SendCoinsMessage.verify(message.sendCoinsMessage);
                                if (error)
                                    return "sendCoinsMessage." + error;
                            }
                        }
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.StakeMessage.verify(message.stakeMessage);
                                if (error)
                                    return "stakeMessage." + error;
                            }
                        }
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.StakeMessage.verify(message.unstakeMessage);
                                if (error)
                                    return "unstakeMessage." + error;
                            }
                        }
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.WithdrawStakeRewardMessage.verify(message.withdrawStakeRewardMessage);
                                if (error)
                                    return "withdrawStakeRewardMessage." + error;
                            }
                        }
                        if (message.setAliasMessage != null && message.hasOwnProperty("setAliasMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.SetAliasMessage.verify(message.setAliasMessage);
                                if (error)
                                    return "setAliasMessage." + error;
                            }
                        }
                        if (message.createOrderMessage != null && message.hasOwnProperty("createOrderMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.CreateOrderMessage.verify(message.createOrderMessage);
                                if (error)
                                    return "createOrderMessage." + error;
                            }
                        }
                        if (message.cancelOrderMessage != null && message.hasOwnProperty("cancelOrderMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Coinex.Proto.CancelOrderMessage.verify(message.cancelOrderMessage);
                                if (error)
                                    return "cancelOrderMessage." + error;
                            }
                        }
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            if (!$util.isString(message.typePrefix))
                                return "typePrefix: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Coinex.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Coinex.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Coinex.Proto.SigningInput();
                        if (object.accountNumber != null)
                            if ($util.Long)
                                (message.accountNumber = $util.Long.fromValue(object.accountNumber)).unsigned = true;
                            else if (typeof object.accountNumber === "string")
                                message.accountNumber = parseInt(object.accountNumber, 10);
                            else if (typeof object.accountNumber === "number")
                                message.accountNumber = object.accountNumber;
                            else if (typeof object.accountNumber === "object")
                                message.accountNumber = new $util.LongBits(object.accountNumber.low >>> 0, object.accountNumber.high >>> 0).toNumber(true);
                        if (object.chainId != null)
                            message.chainId = String(object.chainId);
                        if (object.fee != null) {
                            if (typeof object.fee !== "object")
                                throw TypeError(".TW.Coinex.Proto.SigningInput.fee: object expected");
                            message.fee = $root.TW.Coinex.Proto.Fee.fromObject(object.fee);
                        }
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.sequence != null)
                            if ($util.Long)
                                (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
                            else if (typeof object.sequence === "string")
                                message.sequence = parseInt(object.sequence, 10);
                            else if (typeof object.sequence === "number")
                                message.sequence = object.sequence;
                            else if (typeof object.sequence === "object")
                                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.sendCoinsMessage != null) {
                            if (typeof object.sendCoinsMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.SigningInput.sendCoinsMessage: object expected");
                            message.sendCoinsMessage = $root.TW.Coinex.Proto.SendCoinsMessage.fromObject(object.sendCoinsMessage);
                        }
                        if (object.stakeMessage != null) {
                            if (typeof object.stakeMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.SigningInput.stakeMessage: object expected");
                            message.stakeMessage = $root.TW.Coinex.Proto.StakeMessage.fromObject(object.stakeMessage);
                        }
                        if (object.unstakeMessage != null) {
                            if (typeof object.unstakeMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.SigningInput.unstakeMessage: object expected");
                            message.unstakeMessage = $root.TW.Coinex.Proto.StakeMessage.fromObject(object.unstakeMessage);
                        }
                        if (object.withdrawStakeRewardMessage != null) {
                            if (typeof object.withdrawStakeRewardMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.SigningInput.withdrawStakeRewardMessage: object expected");
                            message.withdrawStakeRewardMessage = $root.TW.Coinex.Proto.WithdrawStakeRewardMessage.fromObject(object.withdrawStakeRewardMessage);
                        }
                        if (object.setAliasMessage != null) {
                            if (typeof object.setAliasMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.SigningInput.setAliasMessage: object expected");
                            message.setAliasMessage = $root.TW.Coinex.Proto.SetAliasMessage.fromObject(object.setAliasMessage);
                        }
                        if (object.createOrderMessage != null) {
                            if (typeof object.createOrderMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.SigningInput.createOrderMessage: object expected");
                            message.createOrderMessage = $root.TW.Coinex.Proto.CreateOrderMessage.fromObject(object.createOrderMessage);
                        }
                        if (object.cancelOrderMessage != null) {
                            if (typeof object.cancelOrderMessage !== "object")
                                throw TypeError(".TW.Coinex.Proto.SigningInput.cancelOrderMessage: object expected");
                            message.cancelOrderMessage = $root.TW.Coinex.Proto.CancelOrderMessage.fromObject(object.cancelOrderMessage);
                        }
                        if (object.typePrefix != null)
                            message.typePrefix = String(object.typePrefix);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @static
                     * @param {TW.Coinex.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.accountNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.accountNumber = options.longs === String ? "0" : 0;
                            object.chainId = "";
                            object.fee = null;
                            object.memo = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sequence = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.typePrefix = "";
                        }
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (typeof message.accountNumber === "number")
                                object.accountNumber = options.longs === String ? String(message.accountNumber) : message.accountNumber;
                            else
                                object.accountNumber = options.longs === String ? $util.Long.prototype.toString.call(message.accountNumber) : options.longs === Number ? new $util.LongBits(message.accountNumber.low >>> 0, message.accountNumber.high >>> 0).toNumber(true) : message.accountNumber;
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            object.fee = $root.TW.Coinex.Proto.Fee.toObject(message.fee, options);
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (typeof message.sequence === "number")
                                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                            else
                                object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true) : message.sequence;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage")) {
                            object.sendCoinsMessage = $root.TW.Coinex.Proto.SendCoinsMessage.toObject(message.sendCoinsMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "sendCoinsMessage";
                        }
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage")) {
                            object.stakeMessage = $root.TW.Coinex.Proto.StakeMessage.toObject(message.stakeMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "stakeMessage";
                        }
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage")) {
                            object.unstakeMessage = $root.TW.Coinex.Proto.StakeMessage.toObject(message.unstakeMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "unstakeMessage";
                        }
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage")) {
                            object.withdrawStakeRewardMessage = $root.TW.Coinex.Proto.WithdrawStakeRewardMessage.toObject(message.withdrawStakeRewardMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "withdrawStakeRewardMessage";
                        }
                        if (message.setAliasMessage != null && message.hasOwnProperty("setAliasMessage")) {
                            object.setAliasMessage = $root.TW.Coinex.Proto.SetAliasMessage.toObject(message.setAliasMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "setAliasMessage";
                        }
                        if (message.createOrderMessage != null && message.hasOwnProperty("createOrderMessage")) {
                            object.createOrderMessage = $root.TW.Coinex.Proto.CreateOrderMessage.toObject(message.createOrderMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "createOrderMessage";
                        }
                        if (message.cancelOrderMessage != null && message.hasOwnProperty("cancelOrderMessage")) {
                            object.cancelOrderMessage = $root.TW.Coinex.Proto.CancelOrderMessage.toObject(message.cancelOrderMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "cancelOrderMessage";
                        }
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            object.typePrefix = message.typePrefix;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Coinex.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Coinex.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     * @property {string|null} [json] SigningOutput json
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Coinex.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Coinex.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Coinex.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * SigningOutput json.
                     * @member {string} json
                     * @memberof TW.Coinex.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.json = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Coinex.Proto.SigningOutput
                     * @static
                     * @param {TW.Coinex.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Coinex.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Coinex.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Coinex.Proto.SigningOutput
                     * @static
                     * @param {TW.Coinex.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
                        if (message.json != null && message.hasOwnProperty("json"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.json);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Coinex.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Coinex.Proto.SigningOutput
                     * @static
                     * @param {TW.Coinex.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Coinex.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Coinex.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Coinex.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signature = reader.bytes();
                                break;
                            case 2:
                                message.json = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Coinex.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Coinex.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Coinex.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.json != null && message.hasOwnProperty("json"))
                            if (!$util.isString(message.json))
                                return "json: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Coinex.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Coinex.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Coinex.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Coinex.Proto.SigningOutput();
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.json != null)
                            message.json = String(object.json);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Coinex.Proto.SigningOutput
                     * @static
                     * @param {TW.Coinex.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            object.json = "";
                        }
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.json != null && message.hasOwnProperty("json"))
                            object.json = message.json;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Coinex.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Coinex;
        })();
    
        TW.Proto = (function() {
    
            /**
             * Namespace Proto.
             * @memberof TW
             * @namespace
             */
            var Proto = {};
    
            Proto.Result = (function() {
    
                /**
                 * Properties of a Result.
                 * @memberof TW.Proto
                 * @interface IResult
                 * @property {boolean|null} [success] Result success
                 * @property {string|null} [error] Result error
                 * @property {Array.<google.protobuf.IAny>|null} [objects] Result objects
                 */
    
                /**
                 * Constructs a new Result.
                 * @memberof TW.Proto
                 * @classdesc Represents a Result.
                 * @implements IResult
                 * @constructor
                 * @param {TW.Proto.IResult=} [properties] Properties to set
                 */
                function Result(properties) {
                    this.objects = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Result success.
                 * @member {boolean} success
                 * @memberof TW.Proto.Result
                 * @instance
                 */
                Result.prototype.success = false;
    
                /**
                 * Result error.
                 * @member {string} error
                 * @memberof TW.Proto.Result
                 * @instance
                 */
                Result.prototype.error = "";
    
                /**
                 * Result objects.
                 * @member {Array.<google.protobuf.IAny>} objects
                 * @memberof TW.Proto.Result
                 * @instance
                 */
                Result.prototype.objects = $util.emptyArray;
    
                /**
                 * Creates a new Result instance using the specified properties.
                 * @function create
                 * @memberof TW.Proto.Result
                 * @static
                 * @param {TW.Proto.IResult=} [properties] Properties to set
                 * @returns {TW.Proto.Result} Result instance
                 */
                Result.create = function create(properties) {
                    return new Result(properties);
                };
    
                /**
                 * Encodes the specified Result message. Does not implicitly {@link TW.Proto.Result.verify|verify} messages.
                 * @function encode
                 * @memberof TW.Proto.Result
                 * @static
                 * @param {TW.Proto.IResult} message Result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.success != null && message.hasOwnProperty("success"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.success);
                    if (message.error != null && message.hasOwnProperty("error"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.error);
                    if (message.objects != null && message.objects.length)
                        for (var i = 0; i < message.objects.length; ++i)
                            $root.google.protobuf.Any.encode(message.objects[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Result message, length delimited. Does not implicitly {@link TW.Proto.Result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof TW.Proto.Result
                 * @static
                 * @param {TW.Proto.IResult} message Result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Result message from the specified reader or buffer.
                 * @function decode
                 * @memberof TW.Proto.Result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {TW.Proto.Result} Result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Proto.Result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.success = reader.bool();
                            break;
                        case 2:
                            message.error = reader.string();
                            break;
                        case 3:
                            if (!(message.objects && message.objects.length))
                                message.objects = [];
                            message.objects.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof TW.Proto.Result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {TW.Proto.Result} Result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Result message.
                 * @function verify
                 * @memberof TW.Proto.Result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.success != null && message.hasOwnProperty("success"))
                        if (typeof message.success !== "boolean")
                            return "success: boolean expected";
                    if (message.error != null && message.hasOwnProperty("error"))
                        if (!$util.isString(message.error))
                            return "error: string expected";
                    if (message.objects != null && message.hasOwnProperty("objects")) {
                        if (!Array.isArray(message.objects))
                            return "objects: array expected";
                        for (var i = 0; i < message.objects.length; ++i) {
                            var error = $root.google.protobuf.Any.verify(message.objects[i]);
                            if (error)
                                return "objects." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof TW.Proto.Result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {TW.Proto.Result} Result
                 */
                Result.fromObject = function fromObject(object) {
                    if (object instanceof $root.TW.Proto.Result)
                        return object;
                    var message = new $root.TW.Proto.Result();
                    if (object.success != null)
                        message.success = Boolean(object.success);
                    if (object.error != null)
                        message.error = String(object.error);
                    if (object.objects) {
                        if (!Array.isArray(object.objects))
                            throw TypeError(".TW.Proto.Result.objects: array expected");
                        message.objects = [];
                        for (var i = 0; i < object.objects.length; ++i) {
                            if (typeof object.objects[i] !== "object")
                                throw TypeError(".TW.Proto.Result.objects: object expected");
                            message.objects[i] = $root.google.protobuf.Any.fromObject(object.objects[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof TW.Proto.Result
                 * @static
                 * @param {TW.Proto.Result} message Result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.objects = [];
                    if (options.defaults) {
                        object.success = false;
                        object.error = "";
                    }
                    if (message.success != null && message.hasOwnProperty("success"))
                        object.success = message.success;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = message.error;
                    if (message.objects && message.objects.length) {
                        object.objects = [];
                        for (var j = 0; j < message.objects.length; ++j)
                            object.objects[j] = $root.google.protobuf.Any.toObject(message.objects[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Result to JSON.
                 * @function toJSON
                 * @memberof TW.Proto.Result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Result;
            })();
    
            return Proto;
        })();
    
        TW.Cosmos = (function() {
    
            /**
             * Namespace Cosmos.
             * @memberof TW
             * @namespace
             */
            var Cosmos = {};
    
            Cosmos.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Cosmos
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Amount = (function() {
    
                    /**
                     * Properties of an Amount.
                     * @memberof TW.Cosmos.Proto
                     * @interface IAmount
                     * @property {string|null} [denom] Amount denom
                     * @property {Long|null} [amount] Amount amount
                     */
    
                    /**
                     * Constructs a new Amount.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents an Amount.
                     * @implements IAmount
                     * @constructor
                     * @param {TW.Cosmos.Proto.IAmount=} [properties] Properties to set
                     */
                    function Amount(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Amount denom.
                     * @member {string} denom
                     * @memberof TW.Cosmos.Proto.Amount
                     * @instance
                     */
                    Amount.prototype.denom = "";
    
                    /**
                     * Amount amount.
                     * @member {Long} amount
                     * @memberof TW.Cosmos.Proto.Amount
                     * @instance
                     */
                    Amount.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new Amount instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {TW.Cosmos.Proto.IAmount=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.Amount} Amount instance
                     */
                    Amount.create = function create(properties) {
                        return new Amount(properties);
                    };
    
                    /**
                     * Encodes the specified Amount message. Does not implicitly {@link TW.Cosmos.Proto.Amount.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {TW.Cosmos.Proto.IAmount} message Amount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Amount.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.denom);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Amount message, length delimited. Does not implicitly {@link TW.Cosmos.Proto.Amount.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {TW.Cosmos.Proto.IAmount} message Amount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Amount.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an Amount message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.Amount} Amount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Amount.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Amount();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.denom = reader.string();
                                break;
                            case 2:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an Amount message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Cosmos.Proto.Amount} Amount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Amount.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an Amount message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Amount.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            if (!$util.isString(message.denom))
                                return "denom: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an Amount message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.Amount} Amount
                     */
                    Amount.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.Amount)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.Amount();
                        if (object.denom != null)
                            message.denom = String(object.denom);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Amount message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.Amount
                     * @static
                     * @param {TW.Cosmos.Proto.Amount} message Amount
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Amount.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.denom = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.denom != null && message.hasOwnProperty("denom"))
                            object.denom = message.denom;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this Amount to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.Amount
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Amount.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Amount;
                })();
    
                Proto.Fee = (function() {
    
                    /**
                     * Properties of a Fee.
                     * @memberof TW.Cosmos.Proto
                     * @interface IFee
                     * @property {Array.<TW.Cosmos.Proto.IAmount>|null} [amounts] Fee amounts
                     * @property {Long|null} [gas] Fee gas
                     */
    
                    /**
                     * Constructs a new Fee.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents a Fee.
                     * @implements IFee
                     * @constructor
                     * @param {TW.Cosmos.Proto.IFee=} [properties] Properties to set
                     */
                    function Fee(properties) {
                        this.amounts = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Fee amounts.
                     * @member {Array.<TW.Cosmos.Proto.IAmount>} amounts
                     * @memberof TW.Cosmos.Proto.Fee
                     * @instance
                     */
                    Fee.prototype.amounts = $util.emptyArray;
    
                    /**
                     * Fee gas.
                     * @member {Long} gas
                     * @memberof TW.Cosmos.Proto.Fee
                     * @instance
                     */
                    Fee.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new Fee instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {TW.Cosmos.Proto.IFee=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.Fee} Fee instance
                     */
                    Fee.create = function create(properties) {
                        return new Fee(properties);
                    };
    
                    /**
                     * Encodes the specified Fee message. Does not implicitly {@link TW.Cosmos.Proto.Fee.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {TW.Cosmos.Proto.IFee} message Fee message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Fee.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amounts != null && message.amounts.length)
                            for (var i = 0; i < message.amounts.length; ++i)
                                $root.TW.Cosmos.Proto.Amount.encode(message.amounts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.gas);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Fee message, length delimited. Does not implicitly {@link TW.Cosmos.Proto.Fee.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {TW.Cosmos.Proto.IFee} message Fee message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Fee.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Fee message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.Fee} Fee
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Fee.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Fee();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.amounts && message.amounts.length))
                                    message.amounts = [];
                                message.amounts.push($root.TW.Cosmos.Proto.Amount.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                message.gas = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Fee message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Cosmos.Proto.Fee} Fee
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Fee.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Fee message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Fee.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amounts != null && message.hasOwnProperty("amounts")) {
                            if (!Array.isArray(message.amounts))
                                return "amounts: array expected";
                            for (var i = 0; i < message.amounts.length; ++i) {
                                var error = $root.TW.Cosmos.Proto.Amount.verify(message.amounts[i]);
                                if (error)
                                    return "amounts." + error;
                            }
                        }
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            if (!$util.isInteger(message.gas) && !(message.gas && $util.isInteger(message.gas.low) && $util.isInteger(message.gas.high)))
                                return "gas: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a Fee message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.Fee} Fee
                     */
                    Fee.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.Fee)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.Fee();
                        if (object.amounts) {
                            if (!Array.isArray(object.amounts))
                                throw TypeError(".TW.Cosmos.Proto.Fee.amounts: array expected");
                            message.amounts = [];
                            for (var i = 0; i < object.amounts.length; ++i) {
                                if (typeof object.amounts[i] !== "object")
                                    throw TypeError(".TW.Cosmos.Proto.Fee.amounts: object expected");
                                message.amounts[i] = $root.TW.Cosmos.Proto.Amount.fromObject(object.amounts[i]);
                            }
                        }
                        if (object.gas != null)
                            if ($util.Long)
                                (message.gas = $util.Long.fromValue(object.gas)).unsigned = true;
                            else if (typeof object.gas === "string")
                                message.gas = parseInt(object.gas, 10);
                            else if (typeof object.gas === "number")
                                message.gas = object.gas;
                            else if (typeof object.gas === "object")
                                message.gas = new $util.LongBits(object.gas.low >>> 0, object.gas.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Fee message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.Fee
                     * @static
                     * @param {TW.Cosmos.Proto.Fee} message Fee
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Fee.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.amounts = [];
                        if (options.defaults)
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gas = options.longs === String ? "0" : 0;
                        if (message.amounts && message.amounts.length) {
                            object.amounts = [];
                            for (var j = 0; j < message.amounts.length; ++j)
                                object.amounts[j] = $root.TW.Cosmos.Proto.Amount.toObject(message.amounts[j], options);
                        }
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            if (typeof message.gas === "number")
                                object.gas = options.longs === String ? String(message.gas) : message.gas;
                            else
                                object.gas = options.longs === String ? $util.Long.prototype.toString.call(message.gas) : options.longs === Number ? new $util.LongBits(message.gas.low >>> 0, message.gas.high >>> 0).toNumber(true) : message.gas;
                        return object;
                    };
    
                    /**
                     * Converts this Fee to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.Fee
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Fee.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Fee;
                })();
    
                Proto.SendCoinsMessage = (function() {
    
                    /**
                     * Properties of a SendCoinsMessage.
                     * @memberof TW.Cosmos.Proto
                     * @interface ISendCoinsMessage
                     * @property {string|null} [fromAddress] SendCoinsMessage fromAddress
                     * @property {string|null} [toAddress] SendCoinsMessage toAddress
                     * @property {Array.<TW.Cosmos.Proto.IAmount>|null} [amounts] SendCoinsMessage amounts
                     * @property {string|null} [typePrefix] SendCoinsMessage typePrefix
                     */
    
                    /**
                     * Constructs a new SendCoinsMessage.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents a SendCoinsMessage.
                     * @implements ISendCoinsMessage
                     * @constructor
                     * @param {TW.Cosmos.Proto.ISendCoinsMessage=} [properties] Properties to set
                     */
                    function SendCoinsMessage(properties) {
                        this.amounts = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SendCoinsMessage fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @instance
                     */
                    SendCoinsMessage.prototype.fromAddress = "";
    
                    /**
                     * SendCoinsMessage toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @instance
                     */
                    SendCoinsMessage.prototype.toAddress = "";
    
                    /**
                     * SendCoinsMessage amounts.
                     * @member {Array.<TW.Cosmos.Proto.IAmount>} amounts
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @instance
                     */
                    SendCoinsMessage.prototype.amounts = $util.emptyArray;
    
                    /**
                     * SendCoinsMessage typePrefix.
                     * @member {string} typePrefix
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @instance
                     */
                    SendCoinsMessage.prototype.typePrefix = "";
    
                    /**
                     * Creates a new SendCoinsMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @static
                     * @param {TW.Cosmos.Proto.ISendCoinsMessage=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.SendCoinsMessage} SendCoinsMessage instance
                     */
                    SendCoinsMessage.create = function create(properties) {
                        return new SendCoinsMessage(properties);
                    };
    
                    /**
                     * Encodes the specified SendCoinsMessage message. Does not implicitly {@link TW.Cosmos.Proto.SendCoinsMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @static
                     * @param {TW.Cosmos.Proto.ISendCoinsMessage} message SendCoinsMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SendCoinsMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.fromAddress);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.toAddress);
                        if (message.amounts != null && message.amounts.length)
                            for (var i = 0; i < message.amounts.length; ++i)
                                $root.TW.Cosmos.Proto.Amount.encode(message.amounts[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.typePrefix);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SendCoinsMessage message, length delimited. Does not implicitly {@link TW.Cosmos.Proto.SendCoinsMessage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @static
                     * @param {TW.Cosmos.Proto.ISendCoinsMessage} message SendCoinsMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SendCoinsMessage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SendCoinsMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.SendCoinsMessage} SendCoinsMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SendCoinsMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.SendCoinsMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromAddress = reader.string();
                                break;
                            case 2:
                                message.toAddress = reader.string();
                                break;
                            case 3:
                                if (!(message.amounts && message.amounts.length))
                                    message.amounts = [];
                                message.amounts.push($root.TW.Cosmos.Proto.Amount.decode(reader, reader.uint32()));
                                break;
                            case 4:
                                message.typePrefix = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SendCoinsMessage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Cosmos.Proto.SendCoinsMessage} SendCoinsMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SendCoinsMessage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SendCoinsMessage message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SendCoinsMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amounts != null && message.hasOwnProperty("amounts")) {
                            if (!Array.isArray(message.amounts))
                                return "amounts: array expected";
                            for (var i = 0; i < message.amounts.length; ++i) {
                                var error = $root.TW.Cosmos.Proto.Amount.verify(message.amounts[i]);
                                if (error)
                                    return "amounts." + error;
                            }
                        }
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            if (!$util.isString(message.typePrefix))
                                return "typePrefix: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SendCoinsMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.SendCoinsMessage} SendCoinsMessage
                     */
                    SendCoinsMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.SendCoinsMessage)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.SendCoinsMessage();
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amounts) {
                            if (!Array.isArray(object.amounts))
                                throw TypeError(".TW.Cosmos.Proto.SendCoinsMessage.amounts: array expected");
                            message.amounts = [];
                            for (var i = 0; i < object.amounts.length; ++i) {
                                if (typeof object.amounts[i] !== "object")
                                    throw TypeError(".TW.Cosmos.Proto.SendCoinsMessage.amounts: object expected");
                                message.amounts[i] = $root.TW.Cosmos.Proto.Amount.fromObject(object.amounts[i]);
                            }
                        }
                        if (object.typePrefix != null)
                            message.typePrefix = String(object.typePrefix);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SendCoinsMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @static
                     * @param {TW.Cosmos.Proto.SendCoinsMessage} message SendCoinsMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SendCoinsMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.amounts = [];
                        if (options.defaults) {
                            object.fromAddress = "";
                            object.toAddress = "";
                            object.typePrefix = "";
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amounts && message.amounts.length) {
                            object.amounts = [];
                            for (var j = 0; j < message.amounts.length; ++j)
                                object.amounts[j] = $root.TW.Cosmos.Proto.Amount.toObject(message.amounts[j], options);
                        }
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            object.typePrefix = message.typePrefix;
                        return object;
                    };
    
                    /**
                     * Converts this SendCoinsMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.SendCoinsMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SendCoinsMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SendCoinsMessage;
                })();
    
                Proto.StakeMessage = (function() {
    
                    /**
                     * Properties of a StakeMessage.
                     * @memberof TW.Cosmos.Proto
                     * @interface IStakeMessage
                     * @property {string|null} [delegatorAddress] StakeMessage delegatorAddress
                     * @property {string|null} [validatorAddress] StakeMessage validatorAddress
                     * @property {TW.Cosmos.Proto.IAmount|null} [amount] StakeMessage amount
                     * @property {string|null} [typePrefix] StakeMessage typePrefix
                     */
    
                    /**
                     * Constructs a new StakeMessage.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents a StakeMessage.
                     * @implements IStakeMessage
                     * @constructor
                     * @param {TW.Cosmos.Proto.IStakeMessage=} [properties] Properties to set
                     */
                    function StakeMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * StakeMessage delegatorAddress.
                     * @member {string} delegatorAddress
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @instance
                     */
                    StakeMessage.prototype.delegatorAddress = "";
    
                    /**
                     * StakeMessage validatorAddress.
                     * @member {string} validatorAddress
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @instance
                     */
                    StakeMessage.prototype.validatorAddress = "";
    
                    /**
                     * StakeMessage amount.
                     * @member {TW.Cosmos.Proto.IAmount|null|undefined} amount
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @instance
                     */
                    StakeMessage.prototype.amount = null;
    
                    /**
                     * StakeMessage typePrefix.
                     * @member {string} typePrefix
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @instance
                     */
                    StakeMessage.prototype.typePrefix = "";
    
                    /**
                     * Creates a new StakeMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @static
                     * @param {TW.Cosmos.Proto.IStakeMessage=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.StakeMessage} StakeMessage instance
                     */
                    StakeMessage.create = function create(properties) {
                        return new StakeMessage(properties);
                    };
    
                    /**
                     * Encodes the specified StakeMessage message. Does not implicitly {@link TW.Cosmos.Proto.StakeMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @static
                     * @param {TW.Cosmos.Proto.IStakeMessage} message StakeMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StakeMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegatorAddress);
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.validatorAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            $root.TW.Cosmos.Proto.Amount.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.typePrefix);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified StakeMessage message, length delimited. Does not implicitly {@link TW.Cosmos.Proto.StakeMessage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @static
                     * @param {TW.Cosmos.Proto.IStakeMessage} message StakeMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StakeMessage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a StakeMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.StakeMessage} StakeMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StakeMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.StakeMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.delegatorAddress = reader.string();
                                break;
                            case 2:
                                message.validatorAddress = reader.string();
                                break;
                            case 3:
                                message.amount = $root.TW.Cosmos.Proto.Amount.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.typePrefix = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a StakeMessage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Cosmos.Proto.StakeMessage} StakeMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StakeMessage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a StakeMessage message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StakeMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            if (!$util.isString(message.delegatorAddress))
                                return "delegatorAddress: string expected";
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            if (!$util.isString(message.validatorAddress))
                                return "validatorAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount")) {
                            var error = $root.TW.Cosmos.Proto.Amount.verify(message.amount);
                            if (error)
                                return "amount." + error;
                        }
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            if (!$util.isString(message.typePrefix))
                                return "typePrefix: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a StakeMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.StakeMessage} StakeMessage
                     */
                    StakeMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.StakeMessage)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.StakeMessage();
                        if (object.delegatorAddress != null)
                            message.delegatorAddress = String(object.delegatorAddress);
                        if (object.validatorAddress != null)
                            message.validatorAddress = String(object.validatorAddress);
                        if (object.amount != null) {
                            if (typeof object.amount !== "object")
                                throw TypeError(".TW.Cosmos.Proto.StakeMessage.amount: object expected");
                            message.amount = $root.TW.Cosmos.Proto.Amount.fromObject(object.amount);
                        }
                        if (object.typePrefix != null)
                            message.typePrefix = String(object.typePrefix);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a StakeMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @static
                     * @param {TW.Cosmos.Proto.StakeMessage} message StakeMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StakeMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.delegatorAddress = "";
                            object.validatorAddress = "";
                            object.amount = null;
                            object.typePrefix = "";
                        }
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            object.delegatorAddress = message.delegatorAddress;
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            object.validatorAddress = message.validatorAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = $root.TW.Cosmos.Proto.Amount.toObject(message.amount, options);
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            object.typePrefix = message.typePrefix;
                        return object;
                    };
    
                    /**
                     * Converts this StakeMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.StakeMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StakeMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return StakeMessage;
                })();
    
                Proto.WithdrawStakeRewardMessage = (function() {
    
                    /**
                     * Properties of a WithdrawStakeRewardMessage.
                     * @memberof TW.Cosmos.Proto
                     * @interface IWithdrawStakeRewardMessage
                     * @property {string|null} [delegatorAddress] WithdrawStakeRewardMessage delegatorAddress
                     * @property {string|null} [validatorAddress] WithdrawStakeRewardMessage validatorAddress
                     * @property {string|null} [typePrefix] WithdrawStakeRewardMessage typePrefix
                     */
    
                    /**
                     * Constructs a new WithdrawStakeRewardMessage.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents a WithdrawStakeRewardMessage.
                     * @implements IWithdrawStakeRewardMessage
                     * @constructor
                     * @param {TW.Cosmos.Proto.IWithdrawStakeRewardMessage=} [properties] Properties to set
                     */
                    function WithdrawStakeRewardMessage(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * WithdrawStakeRewardMessage delegatorAddress.
                     * @member {string} delegatorAddress
                     * @memberof TW.Cosmos.Proto.WithdrawStakeRewardMessage
                     * @instance
                     */
                    WithdrawStakeRewardMessage.prototype.delegatorAddress = "";
    
                    /**
                     * WithdrawStakeRewardMessage validatorAddress.
                     * @member {string} validatorAddress
                     * @memberof TW.Cosmos.Proto.WithdrawStakeRewardMessage
                     * @instance
                     */
                    WithdrawStakeRewardMessage.prototype.validatorAddress = "";
    
                    /**
                     * WithdrawStakeRewardMessage typePrefix.
                     * @member {string} typePrefix
                     * @memberof TW.Cosmos.Proto.WithdrawStakeRewardMessage
                     * @instance
                     */
                    WithdrawStakeRewardMessage.prototype.typePrefix = "";
    
                    /**
                     * Creates a new WithdrawStakeRewardMessage instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {TW.Cosmos.Proto.IWithdrawStakeRewardMessage=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.WithdrawStakeRewardMessage} WithdrawStakeRewardMessage instance
                     */
                    WithdrawStakeRewardMessage.create = function create(properties) {
                        return new WithdrawStakeRewardMessage(properties);
                    };
    
                    /**
                     * Encodes the specified WithdrawStakeRewardMessage message. Does not implicitly {@link TW.Cosmos.Proto.WithdrawStakeRewardMessage.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {TW.Cosmos.Proto.IWithdrawStakeRewardMessage} message WithdrawStakeRewardMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    WithdrawStakeRewardMessage.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegatorAddress);
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.validatorAddress);
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.typePrefix);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified WithdrawStakeRewardMessage message, length delimited. Does not implicitly {@link TW.Cosmos.Proto.WithdrawStakeRewardMessage.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Cosmos.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {TW.Cosmos.Proto.IWithdrawStakeRewardMessage} message WithdrawStakeRewardMessage message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    WithdrawStakeRewardMessage.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a WithdrawStakeRewardMessage message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.WithdrawStakeRewardMessage} WithdrawStakeRewardMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    WithdrawStakeRewardMessage.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.delegatorAddress = reader.string();
                                break;
                            case 2:
                                message.validatorAddress = reader.string();
                                break;
                            case 3:
                                message.typePrefix = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a WithdrawStakeRewardMessage message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Cosmos.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Cosmos.Proto.WithdrawStakeRewardMessage} WithdrawStakeRewardMessage
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    WithdrawStakeRewardMessage.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a WithdrawStakeRewardMessage message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    WithdrawStakeRewardMessage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            if (!$util.isString(message.delegatorAddress))
                                return "delegatorAddress: string expected";
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            if (!$util.isString(message.validatorAddress))
                                return "validatorAddress: string expected";
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            if (!$util.isString(message.typePrefix))
                                return "typePrefix: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a WithdrawStakeRewardMessage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.WithdrawStakeRewardMessage} WithdrawStakeRewardMessage
                     */
                    WithdrawStakeRewardMessage.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage();
                        if (object.delegatorAddress != null)
                            message.delegatorAddress = String(object.delegatorAddress);
                        if (object.validatorAddress != null)
                            message.validatorAddress = String(object.validatorAddress);
                        if (object.typePrefix != null)
                            message.typePrefix = String(object.typePrefix);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a WithdrawStakeRewardMessage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.WithdrawStakeRewardMessage
                     * @static
                     * @param {TW.Cosmos.Proto.WithdrawStakeRewardMessage} message WithdrawStakeRewardMessage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    WithdrawStakeRewardMessage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.delegatorAddress = "";
                            object.validatorAddress = "";
                            object.typePrefix = "";
                        }
                        if (message.delegatorAddress != null && message.hasOwnProperty("delegatorAddress"))
                            object.delegatorAddress = message.delegatorAddress;
                        if (message.validatorAddress != null && message.hasOwnProperty("validatorAddress"))
                            object.validatorAddress = message.validatorAddress;
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            object.typePrefix = message.typePrefix;
                        return object;
                    };
    
                    /**
                     * Converts this WithdrawStakeRewardMessage to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.WithdrawStakeRewardMessage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    WithdrawStakeRewardMessage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return WithdrawStakeRewardMessage;
                })();
    
                Proto.Signature = (function() {
    
                    /**
                     * Properties of a Signature.
                     * @memberof TW.Cosmos.Proto
                     * @interface ISignature
                     * @property {Uint8Array|null} [publicKey] Signature publicKey
                     * @property {Uint8Array|null} [signature] Signature signature
                     */
    
                    /**
                     * Constructs a new Signature.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents a Signature.
                     * @implements ISignature
                     * @constructor
                     * @param {TW.Cosmos.Proto.ISignature=} [properties] Properties to set
                     */
                    function Signature(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Signature publicKey.
                     * @member {Uint8Array} publicKey
                     * @memberof TW.Cosmos.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.publicKey = $util.newBuffer([]);
    
                    /**
                     * Signature signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Cosmos.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new Signature instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.Signature
                     * @static
                     * @param {TW.Cosmos.Proto.ISignature=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.Signature} Signature instance
                     */
                    Signature.create = function create(properties) {
                        return new Signature(properties);
                    };
    
                    /**
                     * Encodes the specified Signature message. Does not implicitly {@link TW.Cosmos.Proto.Signature.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.Signature
                     * @static
                     * @param {TW.Cosmos.Proto.ISignature} message Signature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Signature.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Signature message, length delimited. Does not implicitly {@link TW.Cosmos.Proto.Signature.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Cosmos.Proto.Signature
                     * @static
                     * @param {TW.Cosmos.Proto.ISignature} message Signature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Signature.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Signature message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.Signature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.Signature} Signature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Signature.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Signature();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.publicKey = reader.bytes();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Signature message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Cosmos.Proto.Signature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Cosmos.Proto.Signature} Signature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Signature.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Signature message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.Signature
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Signature.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                                return "publicKey: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Signature message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.Signature
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.Signature} Signature
                     */
                    Signature.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.Signature)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.Signature();
                        if (object.publicKey != null)
                            if (typeof object.publicKey === "string")
                                $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                            else if (object.publicKey.length)
                                message.publicKey = object.publicKey;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Signature message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.Signature
                     * @static
                     * @param {TW.Cosmos.Proto.Signature} message Signature
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Signature.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.publicKey = "";
                            else {
                                object.publicKey = [];
                                if (options.bytes !== Array)
                                    object.publicKey = $util.newBuffer(object.publicKey);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this Signature to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.Signature
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Signature.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Signature;
                })();
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.Cosmos.Proto
                     * @interface ITransaction
                     * @property {TW.Cosmos.Proto.IFee|null} [fee] Transaction fee
                     * @property {string|null} [memo] Transaction memo
                     * @property {TW.Cosmos.Proto.ISignature|null} [signature] Transaction signature
                     * @property {TW.Cosmos.Proto.ISendCoinsMessage|null} [sendCoinsMessage] Transaction sendCoinsMessage
                     * @property {TW.Cosmos.Proto.IStakeMessage|null} [stakeMessage] Transaction stakeMessage
                     * @property {TW.Cosmos.Proto.IStakeMessage|null} [unstakeMessage] Transaction unstakeMessage
                     * @property {TW.Cosmos.Proto.IWithdrawStakeRewardMessage|null} [withdrawStakeRewardMessage] Transaction withdrawStakeRewardMessage
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.Cosmos.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction fee.
                     * @member {TW.Cosmos.Proto.IFee|null|undefined} fee
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.fee = null;
    
                    /**
                     * Transaction memo.
                     * @member {string} memo
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.memo = "";
    
                    /**
                     * Transaction signature.
                     * @member {TW.Cosmos.Proto.ISignature|null|undefined} signature
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.signature = null;
    
                    /**
                     * Transaction sendCoinsMessage.
                     * @member {TW.Cosmos.Proto.ISendCoinsMessage|null|undefined} sendCoinsMessage
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.sendCoinsMessage = null;
    
                    /**
                     * Transaction stakeMessage.
                     * @member {TW.Cosmos.Proto.IStakeMessage|null|undefined} stakeMessage
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.stakeMessage = null;
    
                    /**
                     * Transaction unstakeMessage.
                     * @member {TW.Cosmos.Proto.IStakeMessage|null|undefined} unstakeMessage
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.unstakeMessage = null;
    
                    /**
                     * Transaction withdrawStakeRewardMessage.
                     * @member {TW.Cosmos.Proto.IWithdrawStakeRewardMessage|null|undefined} withdrawStakeRewardMessage
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.withdrawStakeRewardMessage = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Transaction messageOneof.
                     * @member {"sendCoinsMessage"|"stakeMessage"|"unstakeMessage"|"withdrawStakeRewardMessage"|undefined} messageOneof
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @instance
                     */
                    Object.defineProperty(Transaction.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["sendCoinsMessage", "stakeMessage", "unstakeMessage", "withdrawStakeRewardMessage"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @static
                     * @param {TW.Cosmos.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.Cosmos.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @static
                     * @param {TW.Cosmos.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            $root.TW.Cosmos.Proto.Fee.encode(message.fee, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.memo);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            $root.TW.Cosmos.Proto.Signature.encode(message.signature, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage"))
                            $root.TW.Cosmos.Proto.SendCoinsMessage.encode(message.sendCoinsMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage"))
                            $root.TW.Cosmos.Proto.StakeMessage.encode(message.stakeMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage"))
                            $root.TW.Cosmos.Proto.StakeMessage.encode(message.unstakeMessage, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage"))
                            $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage.encode(message.withdrawStakeRewardMessage, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Transaction message, length delimited. Does not implicitly {@link TW.Cosmos.Proto.Transaction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @static
                     * @param {TW.Cosmos.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fee = $root.TW.Cosmos.Proto.Fee.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.memo = reader.string();
                                break;
                            case 3:
                                message.signature = $root.TW.Cosmos.Proto.Signature.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.sendCoinsMessage = $root.TW.Cosmos.Proto.SendCoinsMessage.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.stakeMessage = $root.TW.Cosmos.Proto.StakeMessage.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.unstakeMessage = $root.TW.Cosmos.Proto.StakeMessage.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.withdrawStakeRewardMessage = $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Cosmos.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.fee != null && message.hasOwnProperty("fee")) {
                            var error = $root.TW.Cosmos.Proto.Fee.verify(message.fee);
                            if (error)
                                return "fee." + error;
                        }
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.signature != null && message.hasOwnProperty("signature")) {
                            var error = $root.TW.Cosmos.Proto.Signature.verify(message.signature);
                            if (error)
                                return "signature." + error;
                        }
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.SendCoinsMessage.verify(message.sendCoinsMessage);
                                if (error)
                                    return "sendCoinsMessage." + error;
                            }
                        }
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.StakeMessage.verify(message.stakeMessage);
                                if (error)
                                    return "stakeMessage." + error;
                            }
                        }
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.StakeMessage.verify(message.unstakeMessage);
                                if (error)
                                    return "unstakeMessage." + error;
                            }
                        }
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage.verify(message.withdrawStakeRewardMessage);
                                if (error)
                                    return "withdrawStakeRewardMessage." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.Transaction)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.Transaction();
                        if (object.fee != null) {
                            if (typeof object.fee !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Transaction.fee: object expected");
                            message.fee = $root.TW.Cosmos.Proto.Fee.fromObject(object.fee);
                        }
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.signature != null) {
                            if (typeof object.signature !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Transaction.signature: object expected");
                            message.signature = $root.TW.Cosmos.Proto.Signature.fromObject(object.signature);
                        }
                        if (object.sendCoinsMessage != null) {
                            if (typeof object.sendCoinsMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Transaction.sendCoinsMessage: object expected");
                            message.sendCoinsMessage = $root.TW.Cosmos.Proto.SendCoinsMessage.fromObject(object.sendCoinsMessage);
                        }
                        if (object.stakeMessage != null) {
                            if (typeof object.stakeMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Transaction.stakeMessage: object expected");
                            message.stakeMessage = $root.TW.Cosmos.Proto.StakeMessage.fromObject(object.stakeMessage);
                        }
                        if (object.unstakeMessage != null) {
                            if (typeof object.unstakeMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Transaction.unstakeMessage: object expected");
                            message.unstakeMessage = $root.TW.Cosmos.Proto.StakeMessage.fromObject(object.unstakeMessage);
                        }
                        if (object.withdrawStakeRewardMessage != null) {
                            if (typeof object.withdrawStakeRewardMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.Transaction.withdrawStakeRewardMessage: object expected");
                            message.withdrawStakeRewardMessage = $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage.fromObject(object.withdrawStakeRewardMessage);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @static
                     * @param {TW.Cosmos.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fee = null;
                            object.memo = "";
                            object.signature = null;
                        }
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            object.fee = $root.TW.Cosmos.Proto.Fee.toObject(message.fee, options);
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = $root.TW.Cosmos.Proto.Signature.toObject(message.signature, options);
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage")) {
                            object.sendCoinsMessage = $root.TW.Cosmos.Proto.SendCoinsMessage.toObject(message.sendCoinsMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "sendCoinsMessage";
                        }
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage")) {
                            object.stakeMessage = $root.TW.Cosmos.Proto.StakeMessage.toObject(message.stakeMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "stakeMessage";
                        }
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage")) {
                            object.unstakeMessage = $root.TW.Cosmos.Proto.StakeMessage.toObject(message.unstakeMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "unstakeMessage";
                        }
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage")) {
                            object.withdrawStakeRewardMessage = $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage.toObject(message.withdrawStakeRewardMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "withdrawStakeRewardMessage";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Cosmos.Proto
                     * @interface ISigningInput
                     * @property {Long|null} [accountNumber] SigningInput accountNumber
                     * @property {string|null} [chainId] SigningInput chainId
                     * @property {TW.Cosmos.Proto.IFee|null} [fee] SigningInput fee
                     * @property {string|null} [memo] SigningInput memo
                     * @property {Long|null} [sequence] SigningInput sequence
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.Cosmos.Proto.ISendCoinsMessage|null} [sendCoinsMessage] SigningInput sendCoinsMessage
                     * @property {TW.Cosmos.Proto.IStakeMessage|null} [stakeMessage] SigningInput stakeMessage
                     * @property {TW.Cosmos.Proto.IStakeMessage|null} [unstakeMessage] SigningInput unstakeMessage
                     * @property {TW.Cosmos.Proto.IWithdrawStakeRewardMessage|null} [withdrawStakeRewardMessage] SigningInput withdrawStakeRewardMessage
                     * @property {string|null} [typePrefix] SigningInput typePrefix
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Cosmos.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput accountNumber.
                     * @member {Long} accountNumber
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.accountNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput chainId.
                     * @member {string} chainId
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = "";
    
                    /**
                     * SigningInput fee.
                     * @member {TW.Cosmos.Proto.IFee|null|undefined} fee
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = null;
    
                    /**
                     * SigningInput memo.
                     * @member {string} memo
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memo = "";
    
                    /**
                     * SigningInput sequence.
                     * @member {Long} sequence
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput sendCoinsMessage.
                     * @member {TW.Cosmos.Proto.ISendCoinsMessage|null|undefined} sendCoinsMessage
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sendCoinsMessage = null;
    
                    /**
                     * SigningInput stakeMessage.
                     * @member {TW.Cosmos.Proto.IStakeMessage|null|undefined} stakeMessage
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stakeMessage = null;
    
                    /**
                     * SigningInput unstakeMessage.
                     * @member {TW.Cosmos.Proto.IStakeMessage|null|undefined} unstakeMessage
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.unstakeMessage = null;
    
                    /**
                     * SigningInput withdrawStakeRewardMessage.
                     * @member {TW.Cosmos.Proto.IWithdrawStakeRewardMessage|null|undefined} withdrawStakeRewardMessage
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.withdrawStakeRewardMessage = null;
    
                    /**
                     * SigningInput typePrefix.
                     * @member {string} typePrefix
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.typePrefix = "";
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput messageOneof.
                     * @member {"sendCoinsMessage"|"stakeMessage"|"unstakeMessage"|"withdrawStakeRewardMessage"|undefined} messageOneof
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "messageOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["sendCoinsMessage", "stakeMessage", "unstakeMessage", "withdrawStakeRewardMessage"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {TW.Cosmos.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Cosmos.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {TW.Cosmos.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.accountNumber);
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.chainId);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            $root.TW.Cosmos.Proto.Fee.encode(message.fee, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.memo);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.sequence);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.privateKey);
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage"))
                            $root.TW.Cosmos.Proto.SendCoinsMessage.encode(message.sendCoinsMessage, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage"))
                            $root.TW.Cosmos.Proto.StakeMessage.encode(message.stakeMessage, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage"))
                            $root.TW.Cosmos.Proto.StakeMessage.encode(message.unstakeMessage, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage"))
                            $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage.encode(message.withdrawStakeRewardMessage, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            writer.uint32(/* id 11, wireType 2 =*/90).string(message.typePrefix);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Cosmos.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {TW.Cosmos.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.accountNumber = reader.uint64();
                                break;
                            case 2:
                                message.chainId = reader.string();
                                break;
                            case 3:
                                message.fee = $root.TW.Cosmos.Proto.Fee.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.memo = reader.string();
                                break;
                            case 5:
                                message.sequence = reader.uint64();
                                break;
                            case 6:
                                message.privateKey = reader.bytes();
                                break;
                            case 7:
                                message.sendCoinsMessage = $root.TW.Cosmos.Proto.SendCoinsMessage.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.stakeMessage = $root.TW.Cosmos.Proto.StakeMessage.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.unstakeMessage = $root.TW.Cosmos.Proto.StakeMessage.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.withdrawStakeRewardMessage = $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.typePrefix = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Cosmos.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (!$util.isInteger(message.accountNumber) && !(message.accountNumber && $util.isInteger(message.accountNumber.low) && $util.isInteger(message.accountNumber.high)))
                                return "accountNumber: integer|Long expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isString(message.chainId))
                                return "chainId: string expected";
                        if (message.fee != null && message.hasOwnProperty("fee")) {
                            var error = $root.TW.Cosmos.Proto.Fee.verify(message.fee);
                            if (error)
                                return "fee." + error;
                        }
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                                return "sequence: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage")) {
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.SendCoinsMessage.verify(message.sendCoinsMessage);
                                if (error)
                                    return "sendCoinsMessage." + error;
                            }
                        }
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.StakeMessage.verify(message.stakeMessage);
                                if (error)
                                    return "stakeMessage." + error;
                            }
                        }
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.StakeMessage.verify(message.unstakeMessage);
                                if (error)
                                    return "unstakeMessage." + error;
                            }
                        }
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage")) {
                            if (properties.messageOneof === 1)
                                return "messageOneof: multiple values";
                            properties.messageOneof = 1;
                            {
                                var error = $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage.verify(message.withdrawStakeRewardMessage);
                                if (error)
                                    return "withdrawStakeRewardMessage." + error;
                            }
                        }
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            if (!$util.isString(message.typePrefix))
                                return "typePrefix: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.SigningInput();
                        if (object.accountNumber != null)
                            if ($util.Long)
                                (message.accountNumber = $util.Long.fromValue(object.accountNumber)).unsigned = true;
                            else if (typeof object.accountNumber === "string")
                                message.accountNumber = parseInt(object.accountNumber, 10);
                            else if (typeof object.accountNumber === "number")
                                message.accountNumber = object.accountNumber;
                            else if (typeof object.accountNumber === "object")
                                message.accountNumber = new $util.LongBits(object.accountNumber.low >>> 0, object.accountNumber.high >>> 0).toNumber(true);
                        if (object.chainId != null)
                            message.chainId = String(object.chainId);
                        if (object.fee != null) {
                            if (typeof object.fee !== "object")
                                throw TypeError(".TW.Cosmos.Proto.SigningInput.fee: object expected");
                            message.fee = $root.TW.Cosmos.Proto.Fee.fromObject(object.fee);
                        }
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.sequence != null)
                            if ($util.Long)
                                (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
                            else if (typeof object.sequence === "string")
                                message.sequence = parseInt(object.sequence, 10);
                            else if (typeof object.sequence === "number")
                                message.sequence = object.sequence;
                            else if (typeof object.sequence === "object")
                                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.sendCoinsMessage != null) {
                            if (typeof object.sendCoinsMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.SigningInput.sendCoinsMessage: object expected");
                            message.sendCoinsMessage = $root.TW.Cosmos.Proto.SendCoinsMessage.fromObject(object.sendCoinsMessage);
                        }
                        if (object.stakeMessage != null) {
                            if (typeof object.stakeMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.SigningInput.stakeMessage: object expected");
                            message.stakeMessage = $root.TW.Cosmos.Proto.StakeMessage.fromObject(object.stakeMessage);
                        }
                        if (object.unstakeMessage != null) {
                            if (typeof object.unstakeMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.SigningInput.unstakeMessage: object expected");
                            message.unstakeMessage = $root.TW.Cosmos.Proto.StakeMessage.fromObject(object.unstakeMessage);
                        }
                        if (object.withdrawStakeRewardMessage != null) {
                            if (typeof object.withdrawStakeRewardMessage !== "object")
                                throw TypeError(".TW.Cosmos.Proto.SigningInput.withdrawStakeRewardMessage: object expected");
                            message.withdrawStakeRewardMessage = $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage.fromObject(object.withdrawStakeRewardMessage);
                        }
                        if (object.typePrefix != null)
                            message.typePrefix = String(object.typePrefix);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @static
                     * @param {TW.Cosmos.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.accountNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.accountNumber = options.longs === String ? "0" : 0;
                            object.chainId = "";
                            object.fee = null;
                            object.memo = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sequence = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.typePrefix = "";
                        }
                        if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                            if (typeof message.accountNumber === "number")
                                object.accountNumber = options.longs === String ? String(message.accountNumber) : message.accountNumber;
                            else
                                object.accountNumber = options.longs === String ? $util.Long.prototype.toString.call(message.accountNumber) : options.longs === Number ? new $util.LongBits(message.accountNumber.low >>> 0, message.accountNumber.high >>> 0).toNumber(true) : message.accountNumber;
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            object.fee = $root.TW.Cosmos.Proto.Fee.toObject(message.fee, options);
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (typeof message.sequence === "number")
                                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                            else
                                object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true) : message.sequence;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.sendCoinsMessage != null && message.hasOwnProperty("sendCoinsMessage")) {
                            object.sendCoinsMessage = $root.TW.Cosmos.Proto.SendCoinsMessage.toObject(message.sendCoinsMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "sendCoinsMessage";
                        }
                        if (message.stakeMessage != null && message.hasOwnProperty("stakeMessage")) {
                            object.stakeMessage = $root.TW.Cosmos.Proto.StakeMessage.toObject(message.stakeMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "stakeMessage";
                        }
                        if (message.unstakeMessage != null && message.hasOwnProperty("unstakeMessage")) {
                            object.unstakeMessage = $root.TW.Cosmos.Proto.StakeMessage.toObject(message.unstakeMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "unstakeMessage";
                        }
                        if (message.withdrawStakeRewardMessage != null && message.hasOwnProperty("withdrawStakeRewardMessage")) {
                            object.withdrawStakeRewardMessage = $root.TW.Cosmos.Proto.WithdrawStakeRewardMessage.toObject(message.withdrawStakeRewardMessage, options);
                            if (options.oneofs)
                                object.messageOneof = "withdrawStakeRewardMessage";
                        }
                        if (message.typePrefix != null && message.hasOwnProperty("typePrefix"))
                            object.typePrefix = message.typePrefix;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Cosmos.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     * @property {string|null} [json] SigningOutput json
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Cosmos.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Cosmos.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * SigningOutput json.
                     * @member {string} json
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.json = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {TW.Cosmos.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Cosmos.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Cosmos.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {TW.Cosmos.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
                        if (message.json != null && message.hasOwnProperty("json"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.json);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Cosmos.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {TW.Cosmos.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Cosmos.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Cosmos.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signature = reader.bytes();
                                break;
                            case 2:
                                message.json = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Cosmos.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.json != null && message.hasOwnProperty("json"))
                            if (!$util.isString(message.json))
                                return "json: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Cosmos.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Cosmos.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Cosmos.Proto.SigningOutput();
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.json != null)
                            message.json = String(object.json);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @static
                     * @param {TW.Cosmos.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            object.json = "";
                        }
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.json != null && message.hasOwnProperty("json"))
                            object.json = message.json;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Cosmos.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Cosmos;
        })();
    
        TW.Decred = (function() {
    
            /**
             * Namespace Decred.
             * @memberof TW
             * @namespace
             */
            var Decred = {};
    
            Decred.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Decred
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.Decred.Proto
                     * @interface ITransaction
                     * @property {number|null} [serializeType] Serialization format
                     * @property {number|null} [version] Transaction data format version
                     * @property {Array.<TW.Decred.Proto.ITransactionInput>|null} [inputs] Transaction inputs
                     * @property {Array.<TW.Decred.Proto.ITransactionOutput>|null} [outputs] Transaction outputs
                     * @property {number|null} [lockTime] The time when a transaction can be spent (usually zero, in which case it has no effect).
                     * @property {number|null} [expiry] The block height at which the transaction expires and is no longer valid.
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.Decred.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.Decred.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        this.inputs = [];
                        this.outputs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Serialization format
                     * @member {number} serializeType
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.serializeType = 0;
    
                    /**
                     * Transaction data format version
                     * @member {number} version
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.version = 0;
    
                    /**
                     * Transaction inputs.
                     * @member {Array.<TW.Decred.Proto.ITransactionInput>} inputs
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.inputs = $util.emptyArray;
    
                    /**
                     * Transaction outputs.
                     * @member {Array.<TW.Decred.Proto.ITransactionOutput>} outputs
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.outputs = $util.emptyArray;
    
                    /**
                     * The time when a transaction can be spent (usually zero, in which case it has no effect).
                     * @member {number} lockTime
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.lockTime = 0;
    
                    /**
                     * The block height at which the transaction expires and is no longer valid.
                     * @member {number} expiry
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.expiry = 0;
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {TW.Decred.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.Decred.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.Decred.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {TW.Decred.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.serializeType != null && message.hasOwnProperty("serializeType"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.serializeType);
                        if (message.version != null && message.hasOwnProperty("version"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
                        if (message.inputs != null && message.inputs.length)
                            for (var i = 0; i < message.inputs.length; ++i)
                                $root.TW.Decred.Proto.TransactionInput.encode(message.inputs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.outputs != null && message.outputs.length)
                            for (var i = 0; i < message.outputs.length; ++i)
                                $root.TW.Decred.Proto.TransactionOutput.encode(message.outputs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.lockTime);
                        if (message.expiry != null && message.hasOwnProperty("expiry"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.expiry);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Transaction message, length delimited. Does not implicitly {@link TW.Decred.Proto.Transaction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {TW.Decred.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Decred.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Decred.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.serializeType = reader.uint32();
                                break;
                            case 2:
                                message.version = reader.uint32();
                                break;
                            case 3:
                                if (!(message.inputs && message.inputs.length))
                                    message.inputs = [];
                                message.inputs.push($root.TW.Decred.Proto.TransactionInput.decode(reader, reader.uint32()));
                                break;
                            case 4:
                                if (!(message.outputs && message.outputs.length))
                                    message.outputs = [];
                                message.outputs.push($root.TW.Decred.Proto.TransactionOutput.decode(reader, reader.uint32()));
                                break;
                            case 5:
                                message.lockTime = reader.uint32();
                                break;
                            case 6:
                                message.expiry = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Decred.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.serializeType != null && message.hasOwnProperty("serializeType"))
                            if (!$util.isInteger(message.serializeType))
                                return "serializeType: integer expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.inputs != null && message.hasOwnProperty("inputs")) {
                            if (!Array.isArray(message.inputs))
                                return "inputs: array expected";
                            for (var i = 0; i < message.inputs.length; ++i) {
                                var error = $root.TW.Decred.Proto.TransactionInput.verify(message.inputs[i]);
                                if (error)
                                    return "inputs." + error;
                            }
                        }
                        if (message.outputs != null && message.hasOwnProperty("outputs")) {
                            if (!Array.isArray(message.outputs))
                                return "outputs: array expected";
                            for (var i = 0; i < message.outputs.length; ++i) {
                                var error = $root.TW.Decred.Proto.TransactionOutput.verify(message.outputs[i]);
                                if (error)
                                    return "outputs." + error;
                            }
                        }
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (!$util.isInteger(message.lockTime))
                                return "lockTime: integer expected";
                        if (message.expiry != null && message.hasOwnProperty("expiry"))
                            if (!$util.isInteger(message.expiry))
                                return "expiry: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Decred.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Decred.Proto.Transaction)
                            return object;
                        var message = new $root.TW.Decred.Proto.Transaction();
                        if (object.serializeType != null)
                            message.serializeType = object.serializeType >>> 0;
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        if (object.inputs) {
                            if (!Array.isArray(object.inputs))
                                throw TypeError(".TW.Decred.Proto.Transaction.inputs: array expected");
                            message.inputs = [];
                            for (var i = 0; i < object.inputs.length; ++i) {
                                if (typeof object.inputs[i] !== "object")
                                    throw TypeError(".TW.Decred.Proto.Transaction.inputs: object expected");
                                message.inputs[i] = $root.TW.Decred.Proto.TransactionInput.fromObject(object.inputs[i]);
                            }
                        }
                        if (object.outputs) {
                            if (!Array.isArray(object.outputs))
                                throw TypeError(".TW.Decred.Proto.Transaction.outputs: array expected");
                            message.outputs = [];
                            for (var i = 0; i < object.outputs.length; ++i) {
                                if (typeof object.outputs[i] !== "object")
                                    throw TypeError(".TW.Decred.Proto.Transaction.outputs: object expected");
                                message.outputs[i] = $root.TW.Decred.Proto.TransactionOutput.fromObject(object.outputs[i]);
                            }
                        }
                        if (object.lockTime != null)
                            message.lockTime = object.lockTime >>> 0;
                        if (object.expiry != null)
                            message.expiry = object.expiry >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Decred.Proto.Transaction
                     * @static
                     * @param {TW.Decred.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.inputs = [];
                            object.outputs = [];
                        }
                        if (options.defaults) {
                            object.serializeType = 0;
                            object.version = 0;
                            object.lockTime = 0;
                            object.expiry = 0;
                        }
                        if (message.serializeType != null && message.hasOwnProperty("serializeType"))
                            object.serializeType = message.serializeType;
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.inputs && message.inputs.length) {
                            object.inputs = [];
                            for (var j = 0; j < message.inputs.length; ++j)
                                object.inputs[j] = $root.TW.Decred.Proto.TransactionInput.toObject(message.inputs[j], options);
                        }
                        if (message.outputs && message.outputs.length) {
                            object.outputs = [];
                            for (var j = 0; j < message.outputs.length; ++j)
                                object.outputs[j] = $root.TW.Decred.Proto.TransactionOutput.toObject(message.outputs[j], options);
                        }
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            object.lockTime = message.lockTime;
                        if (message.expiry != null && message.hasOwnProperty("expiry"))
                            object.expiry = message.expiry;
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.Decred.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.TransactionInput = (function() {
    
                    /**
                     * Properties of a TransactionInput.
                     * @memberof TW.Decred.Proto
                     * @interface ITransactionInput
                     * @property {TW.Bitcoin.Proto.IOutPoint|null} [previousOutput] TransactionInput previousOutput
                     * @property {number|null} [sequence] TransactionInput sequence
                     * @property {Long|null} [valueIn] TransactionInput valueIn
                     * @property {number|null} [blockHeight] TransactionInput blockHeight
                     * @property {number|null} [blockIndex] TransactionInput blockIndex
                     * @property {Uint8Array|null} [script] TransactionInput script
                     */
    
                    /**
                     * Constructs a new TransactionInput.
                     * @memberof TW.Decred.Proto
                     * @classdesc Represents a TransactionInput.
                     * @implements ITransactionInput
                     * @constructor
                     * @param {TW.Decred.Proto.ITransactionInput=} [properties] Properties to set
                     */
                    function TransactionInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionInput previousOutput.
                     * @member {TW.Bitcoin.Proto.IOutPoint|null|undefined} previousOutput
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.previousOutput = null;
    
                    /**
                     * TransactionInput sequence.
                     * @member {number} sequence
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.sequence = 0;
    
                    /**
                     * TransactionInput valueIn.
                     * @member {Long} valueIn
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.valueIn = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionInput blockHeight.
                     * @member {number} blockHeight
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.blockHeight = 0;
    
                    /**
                     * TransactionInput blockIndex.
                     * @member {number} blockIndex
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.blockIndex = 0;
    
                    /**
                     * TransactionInput script.
                     * @member {Uint8Array} script
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.script = $util.newBuffer([]);
    
                    /**
                     * Creates a new TransactionInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {TW.Decred.Proto.ITransactionInput=} [properties] Properties to set
                     * @returns {TW.Decred.Proto.TransactionInput} TransactionInput instance
                     */
                    TransactionInput.create = function create(properties) {
                        return new TransactionInput(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionInput message. Does not implicitly {@link TW.Decred.Proto.TransactionInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {TW.Decred.Proto.ITransactionInput} message TransactionInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.previousOutput != null && message.hasOwnProperty("previousOutput"))
                            $root.TW.Bitcoin.Proto.OutPoint.encode(message.previousOutput, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sequence);
                        if (message.valueIn != null && message.hasOwnProperty("valueIn"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.valueIn);
                        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockHeight);
                        if (message.blockIndex != null && message.hasOwnProperty("blockIndex"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.blockIndex);
                        if (message.script != null && message.hasOwnProperty("script"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.script);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TransactionInput message, length delimited. Does not implicitly {@link TW.Decred.Proto.TransactionInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {TW.Decred.Proto.ITransactionInput} message TransactionInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TransactionInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Decred.Proto.TransactionInput} TransactionInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Decred.Proto.TransactionInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.previousOutput = $root.TW.Bitcoin.Proto.OutPoint.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.sequence = reader.uint32();
                                break;
                            case 3:
                                message.valueIn = reader.int64();
                                break;
                            case 4:
                                message.blockHeight = reader.uint32();
                                break;
                            case 5:
                                message.blockIndex = reader.uint32();
                                break;
                            case 6:
                                message.script = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TransactionInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Decred.Proto.TransactionInput} TransactionInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TransactionInput message.
                     * @function verify
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.previousOutput != null && message.hasOwnProperty("previousOutput")) {
                            var error = $root.TW.Bitcoin.Proto.OutPoint.verify(message.previousOutput);
                            if (error)
                                return "previousOutput." + error;
                        }
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence))
                                return "sequence: integer expected";
                        if (message.valueIn != null && message.hasOwnProperty("valueIn"))
                            if (!$util.isInteger(message.valueIn) && !(message.valueIn && $util.isInteger(message.valueIn.low) && $util.isInteger(message.valueIn.high)))
                                return "valueIn: integer|Long expected";
                        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                            if (!$util.isInteger(message.blockHeight))
                                return "blockHeight: integer expected";
                        if (message.blockIndex != null && message.hasOwnProperty("blockIndex"))
                            if (!$util.isInteger(message.blockIndex))
                                return "blockIndex: integer expected";
                        if (message.script != null && message.hasOwnProperty("script"))
                            if (!(message.script && typeof message.script.length === "number" || $util.isString(message.script)))
                                return "script: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Decred.Proto.TransactionInput} TransactionInput
                     */
                    TransactionInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Decred.Proto.TransactionInput)
                            return object;
                        var message = new $root.TW.Decred.Proto.TransactionInput();
                        if (object.previousOutput != null) {
                            if (typeof object.previousOutput !== "object")
                                throw TypeError(".TW.Decred.Proto.TransactionInput.previousOutput: object expected");
                            message.previousOutput = $root.TW.Bitcoin.Proto.OutPoint.fromObject(object.previousOutput);
                        }
                        if (object.sequence != null)
                            message.sequence = object.sequence >>> 0;
                        if (object.valueIn != null)
                            if ($util.Long)
                                (message.valueIn = $util.Long.fromValue(object.valueIn)).unsigned = false;
                            else if (typeof object.valueIn === "string")
                                message.valueIn = parseInt(object.valueIn, 10);
                            else if (typeof object.valueIn === "number")
                                message.valueIn = object.valueIn;
                            else if (typeof object.valueIn === "object")
                                message.valueIn = new $util.LongBits(object.valueIn.low >>> 0, object.valueIn.high >>> 0).toNumber();
                        if (object.blockHeight != null)
                            message.blockHeight = object.blockHeight >>> 0;
                        if (object.blockIndex != null)
                            message.blockIndex = object.blockIndex >>> 0;
                        if (object.script != null)
                            if (typeof object.script === "string")
                                $util.base64.decode(object.script, message.script = $util.newBuffer($util.base64.length(object.script)), 0);
                            else if (object.script.length)
                                message.script = object.script;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @static
                     * @param {TW.Decred.Proto.TransactionInput} message TransactionInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.previousOutput = null;
                            object.sequence = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.valueIn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.valueIn = options.longs === String ? "0" : 0;
                            object.blockHeight = 0;
                            object.blockIndex = 0;
                            if (options.bytes === String)
                                object.script = "";
                            else {
                                object.script = [];
                                if (options.bytes !== Array)
                                    object.script = $util.newBuffer(object.script);
                            }
                        }
                        if (message.previousOutput != null && message.hasOwnProperty("previousOutput"))
                            object.previousOutput = $root.TW.Bitcoin.Proto.OutPoint.toObject(message.previousOutput, options);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            object.sequence = message.sequence;
                        if (message.valueIn != null && message.hasOwnProperty("valueIn"))
                            if (typeof message.valueIn === "number")
                                object.valueIn = options.longs === String ? String(message.valueIn) : message.valueIn;
                            else
                                object.valueIn = options.longs === String ? $util.Long.prototype.toString.call(message.valueIn) : options.longs === Number ? new $util.LongBits(message.valueIn.low >>> 0, message.valueIn.high >>> 0).toNumber() : message.valueIn;
                        if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                            object.blockHeight = message.blockHeight;
                        if (message.blockIndex != null && message.hasOwnProperty("blockIndex"))
                            object.blockIndex = message.blockIndex;
                        if (message.script != null && message.hasOwnProperty("script"))
                            object.script = options.bytes === String ? $util.base64.encode(message.script, 0, message.script.length) : options.bytes === Array ? Array.prototype.slice.call(message.script) : message.script;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionInput to JSON.
                     * @function toJSON
                     * @memberof TW.Decred.Proto.TransactionInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionInput;
                })();
    
                Proto.TransactionOutput = (function() {
    
                    /**
                     * Properties of a TransactionOutput.
                     * @memberof TW.Decred.Proto
                     * @interface ITransactionOutput
                     * @property {Long|null} [value] TransactionOutput value
                     * @property {number|null} [version] Transaction output version.
                     * @property {Uint8Array|null} [script] TransactionOutput script
                     */
    
                    /**
                     * Constructs a new TransactionOutput.
                     * @memberof TW.Decred.Proto
                     * @classdesc Represents a TransactionOutput.
                     * @implements ITransactionOutput
                     * @constructor
                     * @param {TW.Decred.Proto.ITransactionOutput=} [properties] Properties to set
                     */
                    function TransactionOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionOutput value.
                     * @member {Long} value
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Transaction output version.
                     * @member {number} version
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.version = 0;
    
                    /**
                     * TransactionOutput script.
                     * @member {Uint8Array} script
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.script = $util.newBuffer([]);
    
                    /**
                     * Creates a new TransactionOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {TW.Decred.Proto.ITransactionOutput=} [properties] Properties to set
                     * @returns {TW.Decred.Proto.TransactionOutput} TransactionOutput instance
                     */
                    TransactionOutput.create = function create(properties) {
                        return new TransactionOutput(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionOutput message. Does not implicitly {@link TW.Decred.Proto.TransactionOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {TW.Decred.Proto.ITransactionOutput} message TransactionOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
                        if (message.version != null && message.hasOwnProperty("version"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
                        if (message.script != null && message.hasOwnProperty("script"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.script);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TransactionOutput message, length delimited. Does not implicitly {@link TW.Decred.Proto.TransactionOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {TW.Decred.Proto.ITransactionOutput} message TransactionOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TransactionOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Decred.Proto.TransactionOutput} TransactionOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Decred.Proto.TransactionOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.int64();
                                break;
                            case 2:
                                message.version = reader.uint32();
                                break;
                            case 3:
                                message.script = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TransactionOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Decred.Proto.TransactionOutput} TransactionOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TransactionOutput message.
                     * @function verify
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.script != null && message.hasOwnProperty("script"))
                            if (!(message.script && typeof message.script.length === "number" || $util.isString(message.script)))
                                return "script: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Decred.Proto.TransactionOutput} TransactionOutput
                     */
                    TransactionOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Decred.Proto.TransactionOutput)
                            return object;
                        var message = new $root.TW.Decred.Proto.TransactionOutput();
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        if (object.script != null)
                            if (typeof object.script === "string")
                                $util.base64.decode(object.script, message.script = $util.newBuffer($util.base64.length(object.script)), 0);
                            else if (object.script.length)
                                message.script = object.script;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @static
                     * @param {TW.Decred.Proto.TransactionOutput} message TransactionOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                            object.version = 0;
                            if (options.bytes === String)
                                object.script = "";
                            else {
                                object.script = [];
                                if (options.bytes !== Array)
                                    object.script = $util.newBuffer(object.script);
                            }
                        }
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.script != null && message.hasOwnProperty("script"))
                            object.script = options.bytes === String ? $util.base64.encode(message.script, 0, message.script.length) : options.bytes === Array ? Array.prototype.slice.call(message.script) : message.script;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Decred.Proto.TransactionOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionOutput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Decred.Proto
                     * @interface ISigningOutput
                     * @property {TW.Decred.Proto.ITransaction|null} [transaction] SigningOutput transaction
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {Long|null} [fee] SigningOutput fee
                     * @property {Long|null} [maxAmount] SigningOutput maxAmount
                     * @property {string|null} [transactionId] SigningOutput transactionId
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Decred.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Decred.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput transaction.
                     * @member {TW.Decred.Proto.ITransaction|null|undefined} transaction
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.transaction = null;
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput fee.
                     * @member {Long} fee
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningOutput maxAmount.
                     * @member {Long} maxAmount
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.maxAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningOutput transactionId.
                     * @member {string} transactionId
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.transactionId = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {TW.Decred.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Decred.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Decred.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {TW.Decred.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            $root.TW.Decred.Proto.Transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encoded);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fee);
                        if (message.maxAmount != null && message.hasOwnProperty("maxAmount"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.maxAmount);
                        if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.transactionId);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Decred.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {TW.Decred.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Decred.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Decred.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transaction = $root.TW.Decred.Proto.Transaction.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.encoded = reader.bytes();
                                break;
                            case 3:
                                message.fee = reader.int64();
                                break;
                            case 4:
                                message.maxAmount = reader.int64();
                                break;
                            case 5:
                                message.transactionId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Decred.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.transaction != null && message.hasOwnProperty("transaction")) {
                            var error = $root.TW.Decred.Proto.Transaction.verify(message.transaction);
                            if (error)
                                return "transaction." + error;
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.maxAmount != null && message.hasOwnProperty("maxAmount"))
                            if (!$util.isInteger(message.maxAmount) && !(message.maxAmount && $util.isInteger(message.maxAmount.low) && $util.isInteger(message.maxAmount.high)))
                                return "maxAmount: integer|Long expected";
                        if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                            if (!$util.isString(message.transactionId))
                                return "transactionId: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Decred.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Decred.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Decred.Proto.SigningOutput();
                        if (object.transaction != null) {
                            if (typeof object.transaction !== "object")
                                throw TypeError(".TW.Decred.Proto.SigningOutput.transaction: object expected");
                            message.transaction = $root.TW.Decred.Proto.Transaction.fromObject(object.transaction);
                        }
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        if (object.maxAmount != null)
                            if ($util.Long)
                                (message.maxAmount = $util.Long.fromValue(object.maxAmount)).unsigned = false;
                            else if (typeof object.maxAmount === "string")
                                message.maxAmount = parseInt(object.maxAmount, 10);
                            else if (typeof object.maxAmount === "number")
                                message.maxAmount = object.maxAmount;
                            else if (typeof object.maxAmount === "object")
                                message.maxAmount = new $util.LongBits(object.maxAmount.low >>> 0, object.maxAmount.high >>> 0).toNumber();
                        if (object.transactionId != null)
                            message.transactionId = String(object.transactionId);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @static
                     * @param {TW.Decred.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.transaction = null;
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.maxAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.maxAmount = options.longs === String ? "0" : 0;
                            object.transactionId = "";
                        }
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            object.transaction = $root.TW.Decred.Proto.Transaction.toObject(message.transaction, options);
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.maxAmount != null && message.hasOwnProperty("maxAmount"))
                            if (typeof message.maxAmount === "number")
                                object.maxAmount = options.longs === String ? String(message.maxAmount) : message.maxAmount;
                            else
                                object.maxAmount = options.longs === String ? $util.Long.prototype.toString.call(message.maxAmount) : options.longs === Number ? new $util.LongBits(message.maxAmount.low >>> 0, message.maxAmount.high >>> 0).toNumber() : message.maxAmount;
                        if (message.transactionId != null && message.hasOwnProperty("transactionId"))
                            object.transactionId = message.transactionId;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Decred.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Decred;
        })();
    
        TW.EOS = (function() {
    
            /**
             * Namespace EOS.
             * @memberof TW
             * @namespace
             */
            var EOS = {};
    
            EOS.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.EOS
                 * @namespace
                 */
                var Proto = {};
    
                /**
                 * KeyType enum.
                 * @name TW.EOS.Proto.KeyType
                 * @enum {string}
                 * @property {number} LEGACY=0 LEGACY value
                 * @property {number} MODERNK1=1 MODERNK1 value
                 * @property {number} MODERNR1=2 MODERNR1 value
                 */
                Proto.KeyType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "LEGACY"] = 0;
                    values[valuesById[1] = "MODERNK1"] = 1;
                    values[valuesById[2] = "MODERNR1"] = 2;
                    return values;
                })();
    
                Proto.Asset = (function() {
    
                    /**
                     * Properties of an Asset.
                     * @memberof TW.EOS.Proto
                     * @interface IAsset
                     * @property {Long|null} [amount] Asset amount
                     * @property {number|null} [decimals] Asset decimals
                     * @property {string|null} [symbol] Asset symbol
                     */
    
                    /**
                     * Constructs a new Asset.
                     * @memberof TW.EOS.Proto
                     * @classdesc Represents an Asset.
                     * @implements IAsset
                     * @constructor
                     * @param {TW.EOS.Proto.IAsset=} [properties] Properties to set
                     */
                    function Asset(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Asset amount.
                     * @member {Long} amount
                     * @memberof TW.EOS.Proto.Asset
                     * @instance
                     */
                    Asset.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Asset decimals.
                     * @member {number} decimals
                     * @memberof TW.EOS.Proto.Asset
                     * @instance
                     */
                    Asset.prototype.decimals = 0;
    
                    /**
                     * Asset symbol.
                     * @member {string} symbol
                     * @memberof TW.EOS.Proto.Asset
                     * @instance
                     */
                    Asset.prototype.symbol = "";
    
                    /**
                     * Creates a new Asset instance using the specified properties.
                     * @function create
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {TW.EOS.Proto.IAsset=} [properties] Properties to set
                     * @returns {TW.EOS.Proto.Asset} Asset instance
                     */
                    Asset.create = function create(properties) {
                        return new Asset(properties);
                    };
    
                    /**
                     * Encodes the specified Asset message. Does not implicitly {@link TW.EOS.Proto.Asset.verify|verify} messages.
                     * @function encode
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {TW.EOS.Proto.IAsset} message Asset message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Asset.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.amount);
                        if (message.decimals != null && message.hasOwnProperty("decimals"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.decimals);
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.symbol);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Asset message, length delimited. Does not implicitly {@link TW.EOS.Proto.Asset.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {TW.EOS.Proto.IAsset} message Asset message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Asset.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an Asset message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.EOS.Proto.Asset} Asset
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Asset.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.EOS.Proto.Asset();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.int64();
                                break;
                            case 2:
                                message.decimals = reader.uint32();
                                break;
                            case 3:
                                message.symbol = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an Asset message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.EOS.Proto.Asset} Asset
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Asset.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an Asset message.
                     * @function verify
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Asset.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.decimals != null && message.hasOwnProperty("decimals"))
                            if (!$util.isInteger(message.decimals))
                                return "decimals: integer expected";
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            if (!$util.isString(message.symbol))
                                return "symbol: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an Asset message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.EOS.Proto.Asset} Asset
                     */
                    Asset.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.EOS.Proto.Asset)
                            return object;
                        var message = new $root.TW.EOS.Proto.Asset();
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.decimals != null)
                            message.decimals = object.decimals >>> 0;
                        if (object.symbol != null)
                            message.symbol = String(object.symbol);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Asset message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.EOS.Proto.Asset
                     * @static
                     * @param {TW.EOS.Proto.Asset} message Asset
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Asset.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.decimals = 0;
                            object.symbol = "";
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.decimals != null && message.hasOwnProperty("decimals"))
                            object.decimals = message.decimals;
                        if (message.symbol != null && message.hasOwnProperty("symbol"))
                            object.symbol = message.symbol;
                        return object;
                    };
    
                    /**
                     * Converts this Asset to JSON.
                     * @function toJSON
                     * @memberof TW.EOS.Proto.Asset
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Asset.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Asset;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.EOS.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [chainId] SigningInput chainId
                     * @property {Uint8Array|null} [referenceBlockId] SigningInput referenceBlockId
                     * @property {number|null} [referenceBlockTime] SigningInput referenceBlockTime
                     * @property {string|null} [currency] SigningInput currency
                     * @property {string|null} [sender] SigningInput sender
                     * @property {string|null} [recipient] SigningInput recipient
                     * @property {string|null} [memo] SigningInput memo
                     * @property {TW.EOS.Proto.IAsset|null} [asset] SigningInput asset
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.EOS.Proto.KeyType|null} [privateKeyType] SigningInput privateKeyType
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.EOS.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.EOS.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput chainId.
                     * @member {Uint8Array} chainId
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = $util.newBuffer([]);
    
                    /**
                     * SigningInput referenceBlockId.
                     * @member {Uint8Array} referenceBlockId
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.referenceBlockId = $util.newBuffer([]);
    
                    /**
                     * SigningInput referenceBlockTime.
                     * @member {number} referenceBlockTime
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.referenceBlockTime = 0;
    
                    /**
                     * SigningInput currency.
                     * @member {string} currency
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.currency = "";
    
                    /**
                     * SigningInput sender.
                     * @member {string} sender
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sender = "";
    
                    /**
                     * SigningInput recipient.
                     * @member {string} recipient
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.recipient = "";
    
                    /**
                     * SigningInput memo.
                     * @member {string} memo
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memo = "";
    
                    /**
                     * SigningInput asset.
                     * @member {TW.EOS.Proto.IAsset|null|undefined} asset
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.asset = null;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput privateKeyType.
                     * @member {TW.EOS.Proto.KeyType} privateKeyType
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKeyType = 0;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {TW.EOS.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.EOS.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.EOS.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {TW.EOS.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chainId);
                        if (message.referenceBlockId != null && message.hasOwnProperty("referenceBlockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.referenceBlockId);
                        if (message.referenceBlockTime != null && message.hasOwnProperty("referenceBlockTime"))
                            writer.uint32(/* id 3, wireType 5 =*/29).sfixed32(message.referenceBlockTime);
                        if (message.currency != null && message.hasOwnProperty("currency"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.currency);
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.sender);
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.recipient);
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
                        if (message.asset != null && message.hasOwnProperty("asset"))
                            $root.TW.EOS.Proto.Asset.encode(message.asset, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.privateKey);
                        if (message.privateKeyType != null && message.hasOwnProperty("privateKeyType"))
                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.privateKeyType);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.EOS.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {TW.EOS.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.EOS.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.EOS.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainId = reader.bytes();
                                break;
                            case 2:
                                message.referenceBlockId = reader.bytes();
                                break;
                            case 3:
                                message.referenceBlockTime = reader.sfixed32();
                                break;
                            case 4:
                                message.currency = reader.string();
                                break;
                            case 5:
                                message.sender = reader.string();
                                break;
                            case 6:
                                message.recipient = reader.string();
                                break;
                            case 7:
                                message.memo = reader.string();
                                break;
                            case 8:
                                message.asset = $root.TW.EOS.Proto.Asset.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.privateKey = reader.bytes();
                                break;
                            case 10:
                                message.privateKeyType = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.EOS.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!(message.chainId && typeof message.chainId.length === "number" || $util.isString(message.chainId)))
                                return "chainId: buffer expected";
                        if (message.referenceBlockId != null && message.hasOwnProperty("referenceBlockId"))
                            if (!(message.referenceBlockId && typeof message.referenceBlockId.length === "number" || $util.isString(message.referenceBlockId)))
                                return "referenceBlockId: buffer expected";
                        if (message.referenceBlockTime != null && message.hasOwnProperty("referenceBlockTime"))
                            if (!$util.isInteger(message.referenceBlockTime))
                                return "referenceBlockTime: integer expected";
                        if (message.currency != null && message.hasOwnProperty("currency"))
                            if (!$util.isString(message.currency))
                                return "currency: string expected";
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            if (!$util.isString(message.sender))
                                return "sender: string expected";
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            if (!$util.isString(message.recipient))
                                return "recipient: string expected";
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            if (!$util.isString(message.memo))
                                return "memo: string expected";
                        if (message.asset != null && message.hasOwnProperty("asset")) {
                            var error = $root.TW.EOS.Proto.Asset.verify(message.asset);
                            if (error)
                                return "asset." + error;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.privateKeyType != null && message.hasOwnProperty("privateKeyType"))
                            switch (message.privateKeyType) {
                            default:
                                return "privateKeyType: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.EOS.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.EOS.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.EOS.Proto.SigningInput();
                        if (object.chainId != null)
                            if (typeof object.chainId === "string")
                                $util.base64.decode(object.chainId, message.chainId = $util.newBuffer($util.base64.length(object.chainId)), 0);
                            else if (object.chainId.length)
                                message.chainId = object.chainId;
                        if (object.referenceBlockId != null)
                            if (typeof object.referenceBlockId === "string")
                                $util.base64.decode(object.referenceBlockId, message.referenceBlockId = $util.newBuffer($util.base64.length(object.referenceBlockId)), 0);
                            else if (object.referenceBlockId.length)
                                message.referenceBlockId = object.referenceBlockId;
                        if (object.referenceBlockTime != null)
                            message.referenceBlockTime = object.referenceBlockTime | 0;
                        if (object.currency != null)
                            message.currency = String(object.currency);
                        if (object.sender != null)
                            message.sender = String(object.sender);
                        if (object.recipient != null)
                            message.recipient = String(object.recipient);
                        if (object.memo != null)
                            message.memo = String(object.memo);
                        if (object.asset != null) {
                            if (typeof object.asset !== "object")
                                throw TypeError(".TW.EOS.Proto.SigningInput.asset: object expected");
                            message.asset = $root.TW.EOS.Proto.Asset.fromObject(object.asset);
                        }
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        switch (object.privateKeyType) {
                        case "LEGACY":
                        case 0:
                            message.privateKeyType = 0;
                            break;
                        case "MODERNK1":
                        case 1:
                            message.privateKeyType = 1;
                            break;
                        case "MODERNR1":
                        case 2:
                            message.privateKeyType = 2;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.EOS.Proto.SigningInput
                     * @static
                     * @param {TW.EOS.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.chainId = "";
                            else {
                                object.chainId = [];
                                if (options.bytes !== Array)
                                    object.chainId = $util.newBuffer(object.chainId);
                            }
                            if (options.bytes === String)
                                object.referenceBlockId = "";
                            else {
                                object.referenceBlockId = [];
                                if (options.bytes !== Array)
                                    object.referenceBlockId = $util.newBuffer(object.referenceBlockId);
                            }
                            object.referenceBlockTime = 0;
                            object.currency = "";
                            object.sender = "";
                            object.recipient = "";
                            object.memo = "";
                            object.asset = null;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.privateKeyType = options.enums === String ? "LEGACY" : 0;
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = options.bytes === String ? $util.base64.encode(message.chainId, 0, message.chainId.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainId) : message.chainId;
                        if (message.referenceBlockId != null && message.hasOwnProperty("referenceBlockId"))
                            object.referenceBlockId = options.bytes === String ? $util.base64.encode(message.referenceBlockId, 0, message.referenceBlockId.length) : options.bytes === Array ? Array.prototype.slice.call(message.referenceBlockId) : message.referenceBlockId;
                        if (message.referenceBlockTime != null && message.hasOwnProperty("referenceBlockTime"))
                            object.referenceBlockTime = message.referenceBlockTime;
                        if (message.currency != null && message.hasOwnProperty("currency"))
                            object.currency = message.currency;
                        if (message.sender != null && message.hasOwnProperty("sender"))
                            object.sender = message.sender;
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            object.recipient = message.recipient;
                        if (message.memo != null && message.hasOwnProperty("memo"))
                            object.memo = message.memo;
                        if (message.asset != null && message.hasOwnProperty("asset"))
                            object.asset = $root.TW.EOS.Proto.Asset.toObject(message.asset, options);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.privateKeyType != null && message.hasOwnProperty("privateKeyType"))
                            object.privateKeyType = options.enums === String ? $root.TW.EOS.Proto.KeyType[message.privateKeyType] : message.privateKeyType;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.EOS.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.EOS.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [jsonEncoded] SigningOutput jsonEncoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.EOS.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.EOS.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput jsonEncoded.
                     * @member {string} jsonEncoded
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.jsonEncoded = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {TW.EOS.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.EOS.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.EOS.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {TW.EOS.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.jsonEncoded != null && message.hasOwnProperty("jsonEncoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.jsonEncoded);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.EOS.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {TW.EOS.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.EOS.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.EOS.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.jsonEncoded = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.EOS.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.jsonEncoded != null && message.hasOwnProperty("jsonEncoded"))
                            if (!$util.isString(message.jsonEncoded))
                                return "jsonEncoded: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.EOS.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.EOS.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.EOS.Proto.SigningOutput();
                        if (object.jsonEncoded != null)
                            message.jsonEncoded = String(object.jsonEncoded);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @static
                     * @param {TW.EOS.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.jsonEncoded = "";
                        if (message.jsonEncoded != null && message.hasOwnProperty("jsonEncoded"))
                            object.jsonEncoded = message.jsonEncoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.EOS.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return EOS;
        })();
    
        TW.Ethereum = (function() {
    
            /**
             * Namespace Ethereum.
             * @memberof TW
             * @namespace
             */
            var Ethereum = {};
    
            Ethereum.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Ethereum
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Ethereum.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [chainId] SigningInput chainId
                     * @property {Uint8Array|null} [nonce] SigningInput nonce
                     * @property {Uint8Array|null} [gasPrice] SigningInput gasPrice
                     * @property {Uint8Array|null} [gasLimit] SigningInput gasLimit
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Uint8Array|null} [amount] SigningInput amount
                     * @property {Uint8Array|null} [payload] SigningInput payload
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Ethereum.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Ethereum.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput chainId.
                     * @member {Uint8Array} chainId
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = $util.newBuffer([]);
    
                    /**
                     * SigningInput nonce.
                     * @member {Uint8Array} nonce
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasPrice.
                     * @member {Uint8Array} gasPrice
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Uint8Array} gasLimit
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.newBuffer([]);
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * SigningInput payload.
                     * @member {Uint8Array} payload
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.payload = $util.newBuffer([]);
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {TW.Ethereum.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Ethereum.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Ethereum.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {TW.Ethereum.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chainId);
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nonce);
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.gasPrice);
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.gasLimit);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.toAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.amount);
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.payload);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Ethereum.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {TW.Ethereum.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ethereum.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ethereum.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainId = reader.bytes();
                                break;
                            case 2:
                                message.nonce = reader.bytes();
                                break;
                            case 3:
                                message.gasPrice = reader.bytes();
                                break;
                            case 4:
                                message.gasLimit = reader.bytes();
                                break;
                            case 5:
                                message.toAddress = reader.string();
                                break;
                            case 6:
                                message.amount = reader.bytes();
                                break;
                            case 7:
                                message.payload = reader.bytes();
                                break;
                            case 8:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Ethereum.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!(message.chainId && typeof message.chainId.length === "number" || $util.isString(message.chainId)))
                                return "chainId: buffer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!(message.gasPrice && typeof message.gasPrice.length === "number" || $util.isString(message.gasPrice)))
                                return "gasPrice: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!(message.gasLimit && typeof message.gasLimit.length === "number" || $util.isString(message.gasLimit)))
                                return "gasLimit: buffer expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                return "payload: buffer expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ethereum.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ethereum.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Ethereum.Proto.SigningInput();
                        if (object.chainId != null)
                            if (typeof object.chainId === "string")
                                $util.base64.decode(object.chainId, message.chainId = $util.newBuffer($util.base64.length(object.chainId)), 0);
                            else if (object.chainId.length)
                                message.chainId = object.chainId;
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        if (object.gasPrice != null)
                            if (typeof object.gasPrice === "string")
                                $util.base64.decode(object.gasPrice, message.gasPrice = $util.newBuffer($util.base64.length(object.gasPrice)), 0);
                            else if (object.gasPrice.length)
                                message.gasPrice = object.gasPrice;
                        if (object.gasLimit != null)
                            if (typeof object.gasLimit === "string")
                                $util.base64.decode(object.gasLimit, message.gasLimit = $util.newBuffer($util.base64.length(object.gasLimit)), 0);
                            else if (object.gasLimit.length)
                                message.gasLimit = object.gasLimit;
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        if (object.payload != null)
                            if (typeof object.payload === "string")
                                $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                            else if (object.payload.length)
                                message.payload = object.payload;
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @static
                     * @param {TW.Ethereum.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.chainId = "";
                            else {
                                object.chainId = [];
                                if (options.bytes !== Array)
                                    object.chainId = $util.newBuffer(object.chainId);
                            }
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            if (options.bytes === String)
                                object.gasPrice = "";
                            else {
                                object.gasPrice = [];
                                if (options.bytes !== Array)
                                    object.gasPrice = $util.newBuffer(object.gasPrice);
                            }
                            if (options.bytes === String)
                                object.gasLimit = "";
                            else {
                                object.gasLimit = [];
                                if (options.bytes !== Array)
                                    object.gasLimit = $util.newBuffer(object.gasLimit);
                            }
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                            if (options.bytes === String)
                                object.payload = "";
                            else {
                                object.payload = [];
                                if (options.bytes !== Array)
                                    object.payload = $util.newBuffer(object.payload);
                            }
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = options.bytes === String ? $util.base64.encode(message.chainId, 0, message.chainId.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainId) : message.chainId;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = options.bytes === String ? $util.base64.encode(message.gasPrice, 0, message.gasPrice.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPrice) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            object.gasLimit = options.bytes === String ? $util.base64.encode(message.gasLimit, 0, message.gasLimit.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasLimit) : message.gasLimit;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Ethereum.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Ethereum.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [v] SigningOutput v
                     * @property {Uint8Array|null} [r] SigningOutput r
                     * @property {Uint8Array|null} [s] SigningOutput s
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Ethereum.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Ethereum.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput v.
                     * @member {Uint8Array} v
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.v = $util.newBuffer([]);
    
                    /**
                     * SigningOutput r.
                     * @member {Uint8Array} r
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.r = $util.newBuffer([]);
    
                    /**
                     * SigningOutput s.
                     * @member {Uint8Array} s
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.s = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {TW.Ethereum.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Ethereum.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Ethereum.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {TW.Ethereum.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.v != null && message.hasOwnProperty("v"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.v);
                        if (message.r != null && message.hasOwnProperty("r"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.r);
                        if (message.s != null && message.hasOwnProperty("s"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.s);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Ethereum.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {TW.Ethereum.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ethereum.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ethereum.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.v = reader.bytes();
                                break;
                            case 3:
                                message.r = reader.bytes();
                                break;
                            case 4:
                                message.s = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Ethereum.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.v != null && message.hasOwnProperty("v"))
                            if (!(message.v && typeof message.v.length === "number" || $util.isString(message.v)))
                                return "v: buffer expected";
                        if (message.r != null && message.hasOwnProperty("r"))
                            if (!(message.r && typeof message.r.length === "number" || $util.isString(message.r)))
                                return "r: buffer expected";
                        if (message.s != null && message.hasOwnProperty("s"))
                            if (!(message.s && typeof message.s.length === "number" || $util.isString(message.s)))
                                return "s: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ethereum.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ethereum.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Ethereum.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.v != null)
                            if (typeof object.v === "string")
                                $util.base64.decode(object.v, message.v = $util.newBuffer($util.base64.length(object.v)), 0);
                            else if (object.v.length)
                                message.v = object.v;
                        if (object.r != null)
                            if (typeof object.r === "string")
                                $util.base64.decode(object.r, message.r = $util.newBuffer($util.base64.length(object.r)), 0);
                            else if (object.r.length)
                                message.r = object.r;
                        if (object.s != null)
                            if (typeof object.s === "string")
                                $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);
                            else if (object.s.length)
                                message.s = object.s;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @static
                     * @param {TW.Ethereum.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if (options.bytes === String)
                                object.v = "";
                            else {
                                object.v = [];
                                if (options.bytes !== Array)
                                    object.v = $util.newBuffer(object.v);
                            }
                            if (options.bytes === String)
                                object.r = "";
                            else {
                                object.r = [];
                                if (options.bytes !== Array)
                                    object.r = $util.newBuffer(object.r);
                            }
                            if (options.bytes === String)
                                object.s = "";
                            else {
                                object.s = [];
                                if (options.bytes !== Array)
                                    object.s = $util.newBuffer(object.s);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.v != null && message.hasOwnProperty("v"))
                            object.v = options.bytes === String ? $util.base64.encode(message.v, 0, message.v.length) : options.bytes === Array ? Array.prototype.slice.call(message.v) : message.v;
                        if (message.r != null && message.hasOwnProperty("r"))
                            object.r = options.bytes === String ? $util.base64.encode(message.r, 0, message.r.length) : options.bytes === Array ? Array.prototype.slice.call(message.r) : message.r;
                        if (message.s != null && message.hasOwnProperty("s"))
                            object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Ethereum.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Ethereum;
        })();
    
        TW.IOST = (function() {
    
            /**
             * Namespace IOST.
             * @memberof TW
             * @namespace
             */
            var IOST = {};
    
            IOST.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.IOST
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Action = (function() {
    
                    /**
                     * Properties of an Action.
                     * @memberof TW.IOST.Proto
                     * @interface IAction
                     * @property {string|null} [contract] Action contract
                     * @property {string|null} [actionName] Action actionName
                     * @property {string|null} [data] Action data
                     */
    
                    /**
                     * Constructs a new Action.
                     * @memberof TW.IOST.Proto
                     * @classdesc Represents an Action.
                     * @implements IAction
                     * @constructor
                     * @param {TW.IOST.Proto.IAction=} [properties] Properties to set
                     */
                    function Action(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Action contract.
                     * @member {string} contract
                     * @memberof TW.IOST.Proto.Action
                     * @instance
                     */
                    Action.prototype.contract = "";
    
                    /**
                     * Action actionName.
                     * @member {string} actionName
                     * @memberof TW.IOST.Proto.Action
                     * @instance
                     */
                    Action.prototype.actionName = "";
    
                    /**
                     * Action data.
                     * @member {string} data
                     * @memberof TW.IOST.Proto.Action
                     * @instance
                     */
                    Action.prototype.data = "";
    
                    /**
                     * Creates a new Action instance using the specified properties.
                     * @function create
                     * @memberof TW.IOST.Proto.Action
                     * @static
                     * @param {TW.IOST.Proto.IAction=} [properties] Properties to set
                     * @returns {TW.IOST.Proto.Action} Action instance
                     */
                    Action.create = function create(properties) {
                        return new Action(properties);
                    };
    
                    /**
                     * Encodes the specified Action message. Does not implicitly {@link TW.IOST.Proto.Action.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IOST.Proto.Action
                     * @static
                     * @param {TW.IOST.Proto.IAction} message Action message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Action.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contract);
                        if (message.actionName != null && message.hasOwnProperty("actionName"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.actionName);
                        if (message.data != null && message.hasOwnProperty("data"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.data);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Action message, length delimited. Does not implicitly {@link TW.IOST.Proto.Action.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IOST.Proto.Action
                     * @static
                     * @param {TW.IOST.Proto.IAction} message Action message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Action.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an Action message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IOST.Proto.Action
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IOST.Proto.Action} Action
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Action.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IOST.Proto.Action();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contract = reader.string();
                                break;
                            case 2:
                                message.actionName = reader.string();
                                break;
                            case 3:
                                message.data = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an Action message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IOST.Proto.Action
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IOST.Proto.Action} Action
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Action.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an Action message.
                     * @function verify
                     * @memberof TW.IOST.Proto.Action
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Action.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            if (!$util.isString(message.contract))
                                return "contract: string expected";
                        if (message.actionName != null && message.hasOwnProperty("actionName"))
                            if (!$util.isString(message.actionName))
                                return "actionName: string expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!$util.isString(message.data))
                                return "data: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an Action message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IOST.Proto.Action
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IOST.Proto.Action} Action
                     */
                    Action.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IOST.Proto.Action)
                            return object;
                        var message = new $root.TW.IOST.Proto.Action();
                        if (object.contract != null)
                            message.contract = String(object.contract);
                        if (object.actionName != null)
                            message.actionName = String(object.actionName);
                        if (object.data != null)
                            message.data = String(object.data);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Action message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IOST.Proto.Action
                     * @static
                     * @param {TW.IOST.Proto.Action} message Action
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Action.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contract = "";
                            object.actionName = "";
                            object.data = "";
                        }
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            object.contract = message.contract;
                        if (message.actionName != null && message.hasOwnProperty("actionName"))
                            object.actionName = message.actionName;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = message.data;
                        return object;
                    };
    
                    /**
                     * Converts this Action to JSON.
                     * @function toJSON
                     * @memberof TW.IOST.Proto.Action
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Action.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Action;
                })();
    
                Proto.AmountLimit = (function() {
    
                    /**
                     * Properties of an AmountLimit.
                     * @memberof TW.IOST.Proto
                     * @interface IAmountLimit
                     * @property {string|null} [token] AmountLimit token
                     * @property {string|null} [value] AmountLimit value
                     */
    
                    /**
                     * Constructs a new AmountLimit.
                     * @memberof TW.IOST.Proto
                     * @classdesc Represents an AmountLimit.
                     * @implements IAmountLimit
                     * @constructor
                     * @param {TW.IOST.Proto.IAmountLimit=} [properties] Properties to set
                     */
                    function AmountLimit(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * AmountLimit token.
                     * @member {string} token
                     * @memberof TW.IOST.Proto.AmountLimit
                     * @instance
                     */
                    AmountLimit.prototype.token = "";
    
                    /**
                     * AmountLimit value.
                     * @member {string} value
                     * @memberof TW.IOST.Proto.AmountLimit
                     * @instance
                     */
                    AmountLimit.prototype.value = "";
    
                    /**
                     * Creates a new AmountLimit instance using the specified properties.
                     * @function create
                     * @memberof TW.IOST.Proto.AmountLimit
                     * @static
                     * @param {TW.IOST.Proto.IAmountLimit=} [properties] Properties to set
                     * @returns {TW.IOST.Proto.AmountLimit} AmountLimit instance
                     */
                    AmountLimit.create = function create(properties) {
                        return new AmountLimit(properties);
                    };
    
                    /**
                     * Encodes the specified AmountLimit message. Does not implicitly {@link TW.IOST.Proto.AmountLimit.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IOST.Proto.AmountLimit
                     * @static
                     * @param {TW.IOST.Proto.IAmountLimit} message AmountLimit message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AmountLimit.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.token != null && message.hasOwnProperty("token"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified AmountLimit message, length delimited. Does not implicitly {@link TW.IOST.Proto.AmountLimit.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IOST.Proto.AmountLimit
                     * @static
                     * @param {TW.IOST.Proto.IAmountLimit} message AmountLimit message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AmountLimit.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an AmountLimit message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IOST.Proto.AmountLimit
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IOST.Proto.AmountLimit} AmountLimit
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AmountLimit.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IOST.Proto.AmountLimit();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.token = reader.string();
                                break;
                            case 2:
                                message.value = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an AmountLimit message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IOST.Proto.AmountLimit
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IOST.Proto.AmountLimit} AmountLimit
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AmountLimit.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an AmountLimit message.
                     * @function verify
                     * @memberof TW.IOST.Proto.AmountLimit
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AmountLimit.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.token != null && message.hasOwnProperty("token"))
                            if (!$util.isString(message.token))
                                return "token: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isString(message.value))
                                return "value: string expected";
                        return null;
                    };
    
                    /**
                     * Creates an AmountLimit message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IOST.Proto.AmountLimit
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IOST.Proto.AmountLimit} AmountLimit
                     */
                    AmountLimit.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IOST.Proto.AmountLimit)
                            return object;
                        var message = new $root.TW.IOST.Proto.AmountLimit();
                        if (object.token != null)
                            message.token = String(object.token);
                        if (object.value != null)
                            message.value = String(object.value);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an AmountLimit message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IOST.Proto.AmountLimit
                     * @static
                     * @param {TW.IOST.Proto.AmountLimit} message AmountLimit
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AmountLimit.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.token = "";
                            object.value = "";
                        }
                        if (message.token != null && message.hasOwnProperty("token"))
                            object.token = message.token;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = message.value;
                        return object;
                    };
    
                    /**
                     * Converts this AmountLimit to JSON.
                     * @function toJSON
                     * @memberof TW.IOST.Proto.AmountLimit
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AmountLimit.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return AmountLimit;
                })();
    
                /**
                 * Algorithm enum.
                 * @name TW.IOST.Proto.Algorithm
                 * @enum {string}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} SECP256K1=1 SECP256K1 value
                 * @property {number} ED25519=2 ED25519 value
                 */
                Proto.Algorithm = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "SECP256K1"] = 1;
                    values[valuesById[2] = "ED25519"] = 2;
                    return values;
                })();
    
                Proto.Signature = (function() {
    
                    /**
                     * Properties of a Signature.
                     * @memberof TW.IOST.Proto
                     * @interface ISignature
                     * @property {TW.IOST.Proto.Algorithm|null} [algorithm] Signature algorithm
                     * @property {Uint8Array|null} [signature] Signature signature
                     * @property {Uint8Array|null} [publicKey] Signature publicKey
                     */
    
                    /**
                     * Constructs a new Signature.
                     * @memberof TW.IOST.Proto
                     * @classdesc Represents a Signature.
                     * @implements ISignature
                     * @constructor
                     * @param {TW.IOST.Proto.ISignature=} [properties] Properties to set
                     */
                    function Signature(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Signature algorithm.
                     * @member {TW.IOST.Proto.Algorithm} algorithm
                     * @memberof TW.IOST.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.algorithm = 0;
    
                    /**
                     * Signature signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.IOST.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Signature publicKey.
                     * @member {Uint8Array} publicKey
                     * @memberof TW.IOST.Proto.Signature
                     * @instance
                     */
                    Signature.prototype.publicKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new Signature instance using the specified properties.
                     * @function create
                     * @memberof TW.IOST.Proto.Signature
                     * @static
                     * @param {TW.IOST.Proto.ISignature=} [properties] Properties to set
                     * @returns {TW.IOST.Proto.Signature} Signature instance
                     */
                    Signature.create = function create(properties) {
                        return new Signature(properties);
                    };
    
                    /**
                     * Encodes the specified Signature message. Does not implicitly {@link TW.IOST.Proto.Signature.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IOST.Proto.Signature
                     * @static
                     * @param {TW.IOST.Proto.ISignature} message Signature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Signature.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.algorithm);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.publicKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Signature message, length delimited. Does not implicitly {@link TW.IOST.Proto.Signature.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IOST.Proto.Signature
                     * @static
                     * @param {TW.IOST.Proto.ISignature} message Signature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Signature.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Signature message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IOST.Proto.Signature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IOST.Proto.Signature} Signature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Signature.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IOST.Proto.Signature();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.algorithm = reader.int32();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            case 3:
                                message.publicKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Signature message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IOST.Proto.Signature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IOST.Proto.Signature} Signature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Signature.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Signature message.
                     * @function verify
                     * @memberof TW.IOST.Proto.Signature
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Signature.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                            switch (message.algorithm) {
                            default:
                                return "algorithm: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                                return "publicKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Signature message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IOST.Proto.Signature
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IOST.Proto.Signature} Signature
                     */
                    Signature.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IOST.Proto.Signature)
                            return object;
                        var message = new $root.TW.IOST.Proto.Signature();
                        switch (object.algorithm) {
                        case "UNKNOWN":
                        case 0:
                            message.algorithm = 0;
                            break;
                        case "SECP256K1":
                        case 1:
                            message.algorithm = 1;
                            break;
                        case "ED25519":
                        case 2:
                            message.algorithm = 2;
                            break;
                        }
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.publicKey != null)
                            if (typeof object.publicKey === "string")
                                $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                            else if (object.publicKey.length)
                                message.publicKey = object.publicKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Signature message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IOST.Proto.Signature
                     * @static
                     * @param {TW.IOST.Proto.Signature} message Signature
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Signature.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.algorithm = options.enums === String ? "UNKNOWN" : 0;
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            if (options.bytes === String)
                                object.publicKey = "";
                            else {
                                object.publicKey = [];
                                if (options.bytes !== Array)
                                    object.publicKey = $util.newBuffer(object.publicKey);
                            }
                        }
                        if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                            object.algorithm = options.enums === String ? $root.TW.IOST.Proto.Algorithm[message.algorithm] : message.algorithm;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                        return object;
                    };
    
                    /**
                     * Converts this Signature to JSON.
                     * @function toJSON
                     * @memberof TW.IOST.Proto.Signature
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Signature.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Signature;
                })();
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.IOST.Proto
                     * @interface ITransaction
                     * @property {Long|null} [time] Transaction time
                     * @property {Long|null} [expiration] Transaction expiration
                     * @property {number|null} [gasRatio] Transaction gasRatio
                     * @property {number|null} [gasLimit] Transaction gasLimit
                     * @property {Long|null} [delay] Transaction delay
                     * @property {number|null} [chainId] Transaction chainId
                     * @property {Array.<TW.IOST.Proto.IAction>|null} [actions] Transaction actions
                     * @property {Array.<TW.IOST.Proto.IAmountLimit>|null} [amountLimit] Transaction amountLimit
                     * @property {Array.<string>|null} [signers] Transaction signers
                     * @property {Array.<TW.IOST.Proto.ISignature>|null} [signatures] Transaction signatures
                     * @property {string|null} [publisher] Transaction publisher
                     * @property {Array.<TW.IOST.Proto.ISignature>|null} [publisherSigs] Transaction publisherSigs
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.IOST.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.IOST.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        this.actions = [];
                        this.amountLimit = [];
                        this.signers = [];
                        this.signatures = [];
                        this.publisherSigs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction time.
                     * @member {Long} time
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Transaction expiration.
                     * @member {Long} expiration
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Transaction gasRatio.
                     * @member {number} gasRatio
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.gasRatio = 0;
    
                    /**
                     * Transaction gasLimit.
                     * @member {number} gasLimit
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.gasLimit = 0;
    
                    /**
                     * Transaction delay.
                     * @member {Long} delay
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.delay = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Transaction chainId.
                     * @member {number} chainId
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.chainId = 0;
    
                    /**
                     * Transaction actions.
                     * @member {Array.<TW.IOST.Proto.IAction>} actions
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.actions = $util.emptyArray;
    
                    /**
                     * Transaction amountLimit.
                     * @member {Array.<TW.IOST.Proto.IAmountLimit>} amountLimit
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.amountLimit = $util.emptyArray;
    
                    /**
                     * Transaction signers.
                     * @member {Array.<string>} signers
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.signers = $util.emptyArray;
    
                    /**
                     * Transaction signatures.
                     * @member {Array.<TW.IOST.Proto.ISignature>} signatures
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.signatures = $util.emptyArray;
    
                    /**
                     * Transaction publisher.
                     * @member {string} publisher
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.publisher = "";
    
                    /**
                     * Transaction publisherSigs.
                     * @member {Array.<TW.IOST.Proto.ISignature>} publisherSigs
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.publisherSigs = $util.emptyArray;
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.IOST.Proto.Transaction
                     * @static
                     * @param {TW.IOST.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.IOST.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.IOST.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IOST.Proto.Transaction
                     * @static
                     * @param {TW.IOST.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.time != null && message.hasOwnProperty("time"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
                        if (message.gasRatio != null && message.hasOwnProperty("gasRatio"))
                            writer.uint32(/* id 3, wireType 1 =*/25).double(message.gasRatio);
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            writer.uint32(/* id 4, wireType 1 =*/33).double(message.gasLimit);
                        if (message.delay != null && message.hasOwnProperty("delay"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.delay);
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.chainId);
                        if (message.actions != null && message.actions.length)
                            for (var i = 0; i < message.actions.length; ++i)
                                $root.TW.IOST.Proto.Action.encode(message.actions[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.amountLimit != null && message.amountLimit.length)
                            for (var i = 0; i < message.amountLimit.length; ++i)
                                $root.TW.IOST.Proto.AmountLimit.encode(message.amountLimit[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.signers != null && message.signers.length)
                            for (var i = 0; i < message.signers.length; ++i)
                                writer.uint32(/* id 9, wireType 2 =*/74).string(message.signers[i]);
                        if (message.signatures != null && message.signatures.length)
                            for (var i = 0; i < message.signatures.length; ++i)
                                $root.TW.IOST.Proto.Signature.encode(message.signatures[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.publisher != null && message.hasOwnProperty("publisher"))
                            writer.uint32(/* id 11, wireType 2 =*/90).string(message.publisher);
                        if (message.publisherSigs != null && message.publisherSigs.length)
                            for (var i = 0; i < message.publisherSigs.length; ++i)
                                $root.TW.IOST.Proto.Signature.encode(message.publisherSigs[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Transaction message, length delimited. Does not implicitly {@link TW.IOST.Proto.Transaction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IOST.Proto.Transaction
                     * @static
                     * @param {TW.IOST.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IOST.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IOST.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IOST.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.time = reader.int64();
                                break;
                            case 2:
                                message.expiration = reader.int64();
                                break;
                            case 3:
                                message.gasRatio = reader.double();
                                break;
                            case 4:
                                message.gasLimit = reader.double();
                                break;
                            case 5:
                                message.delay = reader.int64();
                                break;
                            case 6:
                                message.chainId = reader.uint32();
                                break;
                            case 7:
                                if (!(message.actions && message.actions.length))
                                    message.actions = [];
                                message.actions.push($root.TW.IOST.Proto.Action.decode(reader, reader.uint32()));
                                break;
                            case 8:
                                if (!(message.amountLimit && message.amountLimit.length))
                                    message.amountLimit = [];
                                message.amountLimit.push($root.TW.IOST.Proto.AmountLimit.decode(reader, reader.uint32()));
                                break;
                            case 9:
                                if (!(message.signers && message.signers.length))
                                    message.signers = [];
                                message.signers.push(reader.string());
                                break;
                            case 10:
                                if (!(message.signatures && message.signatures.length))
                                    message.signatures = [];
                                message.signatures.push($root.TW.IOST.Proto.Signature.decode(reader, reader.uint32()));
                                break;
                            case 11:
                                message.publisher = reader.string();
                                break;
                            case 12:
                                if (!(message.publisherSigs && message.publisherSigs.length))
                                    message.publisherSigs = [];
                                message.publisherSigs.push($root.TW.IOST.Proto.Signature.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IOST.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IOST.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.IOST.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.time != null && message.hasOwnProperty("time"))
                            if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                                return "time: integer|Long expected";
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                                return "expiration: integer|Long expected";
                        if (message.gasRatio != null && message.hasOwnProperty("gasRatio"))
                            if (typeof message.gasRatio !== "number")
                                return "gasRatio: number expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit !== "number")
                                return "gasLimit: number expected";
                        if (message.delay != null && message.hasOwnProperty("delay"))
                            if (!$util.isInteger(message.delay) && !(message.delay && $util.isInteger(message.delay.low) && $util.isInteger(message.delay.high)))
                                return "delay: integer|Long expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isInteger(message.chainId))
                                return "chainId: integer expected";
                        if (message.actions != null && message.hasOwnProperty("actions")) {
                            if (!Array.isArray(message.actions))
                                return "actions: array expected";
                            for (var i = 0; i < message.actions.length; ++i) {
                                var error = $root.TW.IOST.Proto.Action.verify(message.actions[i]);
                                if (error)
                                    return "actions." + error;
                            }
                        }
                        if (message.amountLimit != null && message.hasOwnProperty("amountLimit")) {
                            if (!Array.isArray(message.amountLimit))
                                return "amountLimit: array expected";
                            for (var i = 0; i < message.amountLimit.length; ++i) {
                                var error = $root.TW.IOST.Proto.AmountLimit.verify(message.amountLimit[i]);
                                if (error)
                                    return "amountLimit." + error;
                            }
                        }
                        if (message.signers != null && message.hasOwnProperty("signers")) {
                            if (!Array.isArray(message.signers))
                                return "signers: array expected";
                            for (var i = 0; i < message.signers.length; ++i)
                                if (!$util.isString(message.signers[i]))
                                    return "signers: string[] expected";
                        }
                        if (message.signatures != null && message.hasOwnProperty("signatures")) {
                            if (!Array.isArray(message.signatures))
                                return "signatures: array expected";
                            for (var i = 0; i < message.signatures.length; ++i) {
                                var error = $root.TW.IOST.Proto.Signature.verify(message.signatures[i]);
                                if (error)
                                    return "signatures." + error;
                            }
                        }
                        if (message.publisher != null && message.hasOwnProperty("publisher"))
                            if (!$util.isString(message.publisher))
                                return "publisher: string expected";
                        if (message.publisherSigs != null && message.hasOwnProperty("publisherSigs")) {
                            if (!Array.isArray(message.publisherSigs))
                                return "publisherSigs: array expected";
                            for (var i = 0; i < message.publisherSigs.length; ++i) {
                                var error = $root.TW.IOST.Proto.Signature.verify(message.publisherSigs[i]);
                                if (error)
                                    return "publisherSigs." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IOST.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IOST.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IOST.Proto.Transaction)
                            return object;
                        var message = new $root.TW.IOST.Proto.Transaction();
                        if (object.time != null)
                            if ($util.Long)
                                (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                            else if (typeof object.time === "string")
                                message.time = parseInt(object.time, 10);
                            else if (typeof object.time === "number")
                                message.time = object.time;
                            else if (typeof object.time === "object")
                                message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
                        if (object.expiration != null)
                            if ($util.Long)
                                (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                            else if (typeof object.expiration === "string")
                                message.expiration = parseInt(object.expiration, 10);
                            else if (typeof object.expiration === "number")
                                message.expiration = object.expiration;
                            else if (typeof object.expiration === "object")
                                message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
                        if (object.gasRatio != null)
                            message.gasRatio = Number(object.gasRatio);
                        if (object.gasLimit != null)
                            message.gasLimit = Number(object.gasLimit);
                        if (object.delay != null)
                            if ($util.Long)
                                (message.delay = $util.Long.fromValue(object.delay)).unsigned = false;
                            else if (typeof object.delay === "string")
                                message.delay = parseInt(object.delay, 10);
                            else if (typeof object.delay === "number")
                                message.delay = object.delay;
                            else if (typeof object.delay === "object")
                                message.delay = new $util.LongBits(object.delay.low >>> 0, object.delay.high >>> 0).toNumber();
                        if (object.chainId != null)
                            message.chainId = object.chainId >>> 0;
                        if (object.actions) {
                            if (!Array.isArray(object.actions))
                                throw TypeError(".TW.IOST.Proto.Transaction.actions: array expected");
                            message.actions = [];
                            for (var i = 0; i < object.actions.length; ++i) {
                                if (typeof object.actions[i] !== "object")
                                    throw TypeError(".TW.IOST.Proto.Transaction.actions: object expected");
                                message.actions[i] = $root.TW.IOST.Proto.Action.fromObject(object.actions[i]);
                            }
                        }
                        if (object.amountLimit) {
                            if (!Array.isArray(object.amountLimit))
                                throw TypeError(".TW.IOST.Proto.Transaction.amountLimit: array expected");
                            message.amountLimit = [];
                            for (var i = 0; i < object.amountLimit.length; ++i) {
                                if (typeof object.amountLimit[i] !== "object")
                                    throw TypeError(".TW.IOST.Proto.Transaction.amountLimit: object expected");
                                message.amountLimit[i] = $root.TW.IOST.Proto.AmountLimit.fromObject(object.amountLimit[i]);
                            }
                        }
                        if (object.signers) {
                            if (!Array.isArray(object.signers))
                                throw TypeError(".TW.IOST.Proto.Transaction.signers: array expected");
                            message.signers = [];
                            for (var i = 0; i < object.signers.length; ++i)
                                message.signers[i] = String(object.signers[i]);
                        }
                        if (object.signatures) {
                            if (!Array.isArray(object.signatures))
                                throw TypeError(".TW.IOST.Proto.Transaction.signatures: array expected");
                            message.signatures = [];
                            for (var i = 0; i < object.signatures.length; ++i) {
                                if (typeof object.signatures[i] !== "object")
                                    throw TypeError(".TW.IOST.Proto.Transaction.signatures: object expected");
                                message.signatures[i] = $root.TW.IOST.Proto.Signature.fromObject(object.signatures[i]);
                            }
                        }
                        if (object.publisher != null)
                            message.publisher = String(object.publisher);
                        if (object.publisherSigs) {
                            if (!Array.isArray(object.publisherSigs))
                                throw TypeError(".TW.IOST.Proto.Transaction.publisherSigs: array expected");
                            message.publisherSigs = [];
                            for (var i = 0; i < object.publisherSigs.length; ++i) {
                                if (typeof object.publisherSigs[i] !== "object")
                                    throw TypeError(".TW.IOST.Proto.Transaction.publisherSigs: object expected");
                                message.publisherSigs[i] = $root.TW.IOST.Proto.Signature.fromObject(object.publisherSigs[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IOST.Proto.Transaction
                     * @static
                     * @param {TW.IOST.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.actions = [];
                            object.amountLimit = [];
                            object.signers = [];
                            object.signatures = [];
                            object.publisherSigs = [];
                        }
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.time = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.expiration = options.longs === String ? "0" : 0;
                            object.gasRatio = 0;
                            object.gasLimit = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.delay = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.delay = options.longs === String ? "0" : 0;
                            object.chainId = 0;
                            object.publisher = "";
                        }
                        if (message.time != null && message.hasOwnProperty("time"))
                            if (typeof message.time === "number")
                                object.time = options.longs === String ? String(message.time) : message.time;
                            else
                                object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            if (typeof message.expiration === "number")
                                object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                            else
                                object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
                        if (message.gasRatio != null && message.hasOwnProperty("gasRatio"))
                            object.gasRatio = options.json && !isFinite(message.gasRatio) ? String(message.gasRatio) : message.gasRatio;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            object.gasLimit = options.json && !isFinite(message.gasLimit) ? String(message.gasLimit) : message.gasLimit;
                        if (message.delay != null && message.hasOwnProperty("delay"))
                            if (typeof message.delay === "number")
                                object.delay = options.longs === String ? String(message.delay) : message.delay;
                            else
                                object.delay = options.longs === String ? $util.Long.prototype.toString.call(message.delay) : options.longs === Number ? new $util.LongBits(message.delay.low >>> 0, message.delay.high >>> 0).toNumber() : message.delay;
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        if (message.actions && message.actions.length) {
                            object.actions = [];
                            for (var j = 0; j < message.actions.length; ++j)
                                object.actions[j] = $root.TW.IOST.Proto.Action.toObject(message.actions[j], options);
                        }
                        if (message.amountLimit && message.amountLimit.length) {
                            object.amountLimit = [];
                            for (var j = 0; j < message.amountLimit.length; ++j)
                                object.amountLimit[j] = $root.TW.IOST.Proto.AmountLimit.toObject(message.amountLimit[j], options);
                        }
                        if (message.signers && message.signers.length) {
                            object.signers = [];
                            for (var j = 0; j < message.signers.length; ++j)
                                object.signers[j] = message.signers[j];
                        }
                        if (message.signatures && message.signatures.length) {
                            object.signatures = [];
                            for (var j = 0; j < message.signatures.length; ++j)
                                object.signatures[j] = $root.TW.IOST.Proto.Signature.toObject(message.signatures[j], options);
                        }
                        if (message.publisher != null && message.hasOwnProperty("publisher"))
                            object.publisher = message.publisher;
                        if (message.publisherSigs && message.publisherSigs.length) {
                            object.publisherSigs = [];
                            for (var j = 0; j < message.publisherSigs.length; ++j)
                                object.publisherSigs[j] = $root.TW.IOST.Proto.Signature.toObject(message.publisherSigs[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.IOST.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.AccountInfo = (function() {
    
                    /**
                     * Properties of an AccountInfo.
                     * @memberof TW.IOST.Proto
                     * @interface IAccountInfo
                     * @property {string|null} [name] AccountInfo name
                     * @property {Uint8Array|null} [activeKey] AccountInfo activeKey
                     * @property {Uint8Array|null} [ownerKey] AccountInfo ownerKey
                     */
    
                    /**
                     * Constructs a new AccountInfo.
                     * @memberof TW.IOST.Proto
                     * @classdesc Represents an AccountInfo.
                     * @implements IAccountInfo
                     * @constructor
                     * @param {TW.IOST.Proto.IAccountInfo=} [properties] Properties to set
                     */
                    function AccountInfo(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * AccountInfo name.
                     * @member {string} name
                     * @memberof TW.IOST.Proto.AccountInfo
                     * @instance
                     */
                    AccountInfo.prototype.name = "";
    
                    /**
                     * AccountInfo activeKey.
                     * @member {Uint8Array} activeKey
                     * @memberof TW.IOST.Proto.AccountInfo
                     * @instance
                     */
                    AccountInfo.prototype.activeKey = $util.newBuffer([]);
    
                    /**
                     * AccountInfo ownerKey.
                     * @member {Uint8Array} ownerKey
                     * @memberof TW.IOST.Proto.AccountInfo
                     * @instance
                     */
                    AccountInfo.prototype.ownerKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new AccountInfo instance using the specified properties.
                     * @function create
                     * @memberof TW.IOST.Proto.AccountInfo
                     * @static
                     * @param {TW.IOST.Proto.IAccountInfo=} [properties] Properties to set
                     * @returns {TW.IOST.Proto.AccountInfo} AccountInfo instance
                     */
                    AccountInfo.create = function create(properties) {
                        return new AccountInfo(properties);
                    };
    
                    /**
                     * Encodes the specified AccountInfo message. Does not implicitly {@link TW.IOST.Proto.AccountInfo.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IOST.Proto.AccountInfo
                     * @static
                     * @param {TW.IOST.Proto.IAccountInfo} message AccountInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AccountInfo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.activeKey != null && message.hasOwnProperty("activeKey"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.activeKey);
                        if (message.ownerKey != null && message.hasOwnProperty("ownerKey"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ownerKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified AccountInfo message, length delimited. Does not implicitly {@link TW.IOST.Proto.AccountInfo.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IOST.Proto.AccountInfo
                     * @static
                     * @param {TW.IOST.Proto.IAccountInfo} message AccountInfo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AccountInfo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an AccountInfo message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IOST.Proto.AccountInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IOST.Proto.AccountInfo} AccountInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AccountInfo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IOST.Proto.AccountInfo();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.activeKey = reader.bytes();
                                break;
                            case 3:
                                message.ownerKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an AccountInfo message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IOST.Proto.AccountInfo
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IOST.Proto.AccountInfo} AccountInfo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AccountInfo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an AccountInfo message.
                     * @function verify
                     * @memberof TW.IOST.Proto.AccountInfo
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AccountInfo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.activeKey != null && message.hasOwnProperty("activeKey"))
                            if (!(message.activeKey && typeof message.activeKey.length === "number" || $util.isString(message.activeKey)))
                                return "activeKey: buffer expected";
                        if (message.ownerKey != null && message.hasOwnProperty("ownerKey"))
                            if (!(message.ownerKey && typeof message.ownerKey.length === "number" || $util.isString(message.ownerKey)))
                                return "ownerKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates an AccountInfo message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IOST.Proto.AccountInfo
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IOST.Proto.AccountInfo} AccountInfo
                     */
                    AccountInfo.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IOST.Proto.AccountInfo)
                            return object;
                        var message = new $root.TW.IOST.Proto.AccountInfo();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.activeKey != null)
                            if (typeof object.activeKey === "string")
                                $util.base64.decode(object.activeKey, message.activeKey = $util.newBuffer($util.base64.length(object.activeKey)), 0);
                            else if (object.activeKey.length)
                                message.activeKey = object.activeKey;
                        if (object.ownerKey != null)
                            if (typeof object.ownerKey === "string")
                                $util.base64.decode(object.ownerKey, message.ownerKey = $util.newBuffer($util.base64.length(object.ownerKey)), 0);
                            else if (object.ownerKey.length)
                                message.ownerKey = object.ownerKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an AccountInfo message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IOST.Proto.AccountInfo
                     * @static
                     * @param {TW.IOST.Proto.AccountInfo} message AccountInfo
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AccountInfo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name = "";
                            if (options.bytes === String)
                                object.activeKey = "";
                            else {
                                object.activeKey = [];
                                if (options.bytes !== Array)
                                    object.activeKey = $util.newBuffer(object.activeKey);
                            }
                            if (options.bytes === String)
                                object.ownerKey = "";
                            else {
                                object.ownerKey = [];
                                if (options.bytes !== Array)
                                    object.ownerKey = $util.newBuffer(object.ownerKey);
                            }
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.activeKey != null && message.hasOwnProperty("activeKey"))
                            object.activeKey = options.bytes === String ? $util.base64.encode(message.activeKey, 0, message.activeKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.activeKey) : message.activeKey;
                        if (message.ownerKey != null && message.hasOwnProperty("ownerKey"))
                            object.ownerKey = options.bytes === String ? $util.base64.encode(message.ownerKey, 0, message.ownerKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerKey) : message.ownerKey;
                        return object;
                    };
    
                    /**
                     * Converts this AccountInfo to JSON.
                     * @function toJSON
                     * @memberof TW.IOST.Proto.AccountInfo
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AccountInfo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return AccountInfo;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.IOST.Proto
                     * @interface ISigningInput
                     * @property {TW.IOST.Proto.IAccountInfo|null} [account] SigningInput account
                     * @property {TW.IOST.Proto.ITransaction|null} [transactionTemplate] SigningInput transactionTemplate
                     * @property {string|null} [transferDestination] SigningInput transferDestination
                     * @property {string|null} [transferAmount] SigningInput transferAmount
                     * @property {string|null} [transferMemo] SigningInput transferMemo
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.IOST.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.IOST.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput account.
                     * @member {TW.IOST.Proto.IAccountInfo|null|undefined} account
                     * @memberof TW.IOST.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.account = null;
    
                    /**
                     * SigningInput transactionTemplate.
                     * @member {TW.IOST.Proto.ITransaction|null|undefined} transactionTemplate
                     * @memberof TW.IOST.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transactionTemplate = null;
    
                    /**
                     * SigningInput transferDestination.
                     * @member {string} transferDestination
                     * @memberof TW.IOST.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transferDestination = "";
    
                    /**
                     * SigningInput transferAmount.
                     * @member {string} transferAmount
                     * @memberof TW.IOST.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transferAmount = "";
    
                    /**
                     * SigningInput transferMemo.
                     * @member {string} transferMemo
                     * @memberof TW.IOST.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transferMemo = "";
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.IOST.Proto.SigningInput
                     * @static
                     * @param {TW.IOST.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.IOST.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.IOST.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IOST.Proto.SigningInput
                     * @static
                     * @param {TW.IOST.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.account != null && message.hasOwnProperty("account"))
                            $root.TW.IOST.Proto.AccountInfo.encode(message.account, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.transactionTemplate != null && message.hasOwnProperty("transactionTemplate"))
                            $root.TW.IOST.Proto.Transaction.encode(message.transactionTemplate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.transferDestination != null && message.hasOwnProperty("transferDestination"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.transferDestination);
                        if (message.transferAmount != null && message.hasOwnProperty("transferAmount"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.transferAmount);
                        if (message.transferMemo != null && message.hasOwnProperty("transferMemo"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.transferMemo);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.IOST.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IOST.Proto.SigningInput
                     * @static
                     * @param {TW.IOST.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IOST.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IOST.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IOST.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.account = $root.TW.IOST.Proto.AccountInfo.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.transactionTemplate = $root.TW.IOST.Proto.Transaction.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.transferDestination = reader.string();
                                break;
                            case 4:
                                message.transferAmount = reader.string();
                                break;
                            case 5:
                                message.transferMemo = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IOST.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IOST.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.IOST.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.account != null && message.hasOwnProperty("account")) {
                            var error = $root.TW.IOST.Proto.AccountInfo.verify(message.account);
                            if (error)
                                return "account." + error;
                        }
                        if (message.transactionTemplate != null && message.hasOwnProperty("transactionTemplate")) {
                            var error = $root.TW.IOST.Proto.Transaction.verify(message.transactionTemplate);
                            if (error)
                                return "transactionTemplate." + error;
                        }
                        if (message.transferDestination != null && message.hasOwnProperty("transferDestination"))
                            if (!$util.isString(message.transferDestination))
                                return "transferDestination: string expected";
                        if (message.transferAmount != null && message.hasOwnProperty("transferAmount"))
                            if (!$util.isString(message.transferAmount))
                                return "transferAmount: string expected";
                        if (message.transferMemo != null && message.hasOwnProperty("transferMemo"))
                            if (!$util.isString(message.transferMemo))
                                return "transferMemo: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IOST.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IOST.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IOST.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.IOST.Proto.SigningInput();
                        if (object.account != null) {
                            if (typeof object.account !== "object")
                                throw TypeError(".TW.IOST.Proto.SigningInput.account: object expected");
                            message.account = $root.TW.IOST.Proto.AccountInfo.fromObject(object.account);
                        }
                        if (object.transactionTemplate != null) {
                            if (typeof object.transactionTemplate !== "object")
                                throw TypeError(".TW.IOST.Proto.SigningInput.transactionTemplate: object expected");
                            message.transactionTemplate = $root.TW.IOST.Proto.Transaction.fromObject(object.transactionTemplate);
                        }
                        if (object.transferDestination != null)
                            message.transferDestination = String(object.transferDestination);
                        if (object.transferAmount != null)
                            message.transferAmount = String(object.transferAmount);
                        if (object.transferMemo != null)
                            message.transferMemo = String(object.transferMemo);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IOST.Proto.SigningInput
                     * @static
                     * @param {TW.IOST.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.account = null;
                            object.transactionTemplate = null;
                            object.transferDestination = "";
                            object.transferAmount = "";
                            object.transferMemo = "";
                        }
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = $root.TW.IOST.Proto.AccountInfo.toObject(message.account, options);
                        if (message.transactionTemplate != null && message.hasOwnProperty("transactionTemplate"))
                            object.transactionTemplate = $root.TW.IOST.Proto.Transaction.toObject(message.transactionTemplate, options);
                        if (message.transferDestination != null && message.hasOwnProperty("transferDestination"))
                            object.transferDestination = message.transferDestination;
                        if (message.transferAmount != null && message.hasOwnProperty("transferAmount"))
                            object.transferAmount = message.transferAmount;
                        if (message.transferMemo != null && message.hasOwnProperty("transferMemo"))
                            object.transferMemo = message.transferMemo;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.IOST.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.IOST.Proto
                     * @interface ISigningOutput
                     * @property {TW.IOST.Proto.ITransaction|null} [transaction] SigningOutput transaction
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.IOST.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.IOST.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput transaction.
                     * @member {TW.IOST.Proto.ITransaction|null|undefined} transaction
                     * @memberof TW.IOST.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.transaction = null;
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.IOST.Proto.SigningOutput
                     * @static
                     * @param {TW.IOST.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.IOST.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.IOST.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IOST.Proto.SigningOutput
                     * @static
                     * @param {TW.IOST.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            $root.TW.IOST.Proto.Transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.IOST.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IOST.Proto.SigningOutput
                     * @static
                     * @param {TW.IOST.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IOST.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IOST.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IOST.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transaction = $root.TW.IOST.Proto.Transaction.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IOST.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IOST.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.IOST.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.transaction != null && message.hasOwnProperty("transaction")) {
                            var error = $root.TW.IOST.Proto.Transaction.verify(message.transaction);
                            if (error)
                                return "transaction." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IOST.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IOST.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IOST.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.IOST.Proto.SigningOutput();
                        if (object.transaction != null) {
                            if (typeof object.transaction !== "object")
                                throw TypeError(".TW.IOST.Proto.SigningOutput.transaction: object expected");
                            message.transaction = $root.TW.IOST.Proto.Transaction.fromObject(object.transaction);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IOST.Proto.SigningOutput
                     * @static
                     * @param {TW.IOST.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.transaction = null;
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            object.transaction = $root.TW.IOST.Proto.Transaction.toObject(message.transaction, options);
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.IOST.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return IOST;
        })();
    
        TW.Icon = (function() {
    
            /**
             * Namespace Icon.
             * @memberof TW
             * @namespace
             */
            var Icon = {};
    
            Icon.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Icon
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Icon.Proto
                     * @interface ISigningInput
                     * @property {string|null} [fromAddress] SigningInput fromAddress
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Uint8Array|null} [value] SigningInput value
                     * @property {Uint8Array|null} [stepLimit] SigningInput stepLimit
                     * @property {Long|null} [timestamp] SigningInput timestamp
                     * @property {Uint8Array|null} [nonce] SigningInput nonce
                     * @property {Uint8Array|null} [networkId] SigningInput networkId
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Icon.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Icon.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fromAddress = "";
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput value.
                     * @member {Uint8Array} value
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.value = $util.newBuffer([]);
    
                    /**
                     * SigningInput stepLimit.
                     * @member {Uint8Array} stepLimit
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.stepLimit = $util.newBuffer([]);
    
                    /**
                     * SigningInput timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput nonce.
                     * @member {Uint8Array} nonce
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * SigningInput networkId.
                     * @member {Uint8Array} networkId
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.networkId = $util.newBuffer([]);
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {TW.Icon.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Icon.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Icon.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {TW.Icon.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.fromAddress);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.toAddress);
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                        if (message.stepLimit != null && message.hasOwnProperty("stepLimit"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.stepLimit);
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.nonce);
                        if (message.networkId != null && message.hasOwnProperty("networkId"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.networkId);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Icon.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {TW.Icon.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Icon.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Icon.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromAddress = reader.string();
                                break;
                            case 2:
                                message.toAddress = reader.string();
                                break;
                            case 3:
                                message.value = reader.bytes();
                                break;
                            case 4:
                                message.stepLimit = reader.bytes();
                                break;
                            case 5:
                                message.timestamp = reader.int64();
                                break;
                            case 6:
                                message.nonce = reader.bytes();
                                break;
                            case 7:
                                message.networkId = reader.bytes();
                                break;
                            case 8:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Icon.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                return "value: buffer expected";
                        if (message.stepLimit != null && message.hasOwnProperty("stepLimit"))
                            if (!(message.stepLimit && typeof message.stepLimit.length === "number" || $util.isString(message.stepLimit)))
                                return "stepLimit: buffer expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.networkId != null && message.hasOwnProperty("networkId"))
                            if (!(message.networkId && typeof message.networkId.length === "number" || $util.isString(message.networkId)))
                                return "networkId: buffer expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Icon.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Icon.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Icon.Proto.SigningInput();
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.value != null)
                            if (typeof object.value === "string")
                                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                            else if (object.value.length)
                                message.value = object.value;
                        if (object.stepLimit != null)
                            if (typeof object.stepLimit === "string")
                                $util.base64.decode(object.stepLimit, message.stepLimit = $util.newBuffer($util.base64.length(object.stepLimit)), 0);
                            else if (object.stepLimit.length)
                                message.stepLimit = object.stepLimit;
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        if (object.networkId != null)
                            if (typeof object.networkId === "string")
                                $util.base64.decode(object.networkId, message.networkId = $util.newBuffer($util.base64.length(object.networkId)), 0);
                            else if (object.networkId.length)
                                message.networkId = object.networkId;
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Icon.Proto.SigningInput
                     * @static
                     * @param {TW.Icon.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fromAddress = "";
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.value = "";
                            else {
                                object.value = [];
                                if (options.bytes !== Array)
                                    object.value = $util.newBuffer(object.value);
                            }
                            if (options.bytes === String)
                                object.stepLimit = "";
                            else {
                                object.stepLimit = [];
                                if (options.bytes !== Array)
                                    object.stepLimit = $util.newBuffer(object.stepLimit);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            if (options.bytes === String)
                                object.networkId = "";
                            else {
                                object.networkId = [];
                                if (options.bytes !== Array)
                                    object.networkId = $util.newBuffer(object.networkId);
                            }
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                        if (message.stepLimit != null && message.hasOwnProperty("stepLimit"))
                            object.stepLimit = options.bytes === String ? $util.base64.encode(message.stepLimit, 0, message.stepLimit.length) : options.bytes === Array ? Array.prototype.slice.call(message.stepLimit) : message.stepLimit;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.networkId != null && message.hasOwnProperty("networkId"))
                            object.networkId = options.bytes === String ? $util.base64.encode(message.networkId, 0, message.networkId.length) : options.bytes === Array ? Array.prototype.slice.call(message.networkId) : message.networkId;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Icon.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Icon.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Icon.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Icon.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {string} encoded
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = "";
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {TW.Icon.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Icon.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Icon.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {TW.Icon.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.encoded);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Icon.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {TW.Icon.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Icon.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Icon.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.string();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Icon.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!$util.isString(message.encoded))
                                return "encoded: string expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Icon.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Icon.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Icon.Proto.SigningOutput();
                        if (object.encoded != null)
                            message.encoded = String(object.encoded);
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @static
                     * @param {TW.Icon.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.encoded = "";
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = message.encoded;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Icon.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Icon;
        })();
    
        TW.IoTeX = (function() {
    
            /**
             * Namespace IoTeX.
             * @memberof TW
             * @namespace
             */
            var IoTeX = {};
    
            IoTeX.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.IoTeX
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Transfer = (function() {
    
                    /**
                     * Properties of a Transfer.
                     * @memberof TW.IoTeX.Proto
                     * @interface ITransfer
                     * @property {string|null} [amount] Transfer amount
                     * @property {string|null} [recipient] Transfer recipient
                     * @property {Uint8Array|null} [payload] Transfer payload
                     */
    
                    /**
                     * Constructs a new Transfer.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents a Transfer.
                     * @implements ITransfer
                     * @constructor
                     * @param {TW.IoTeX.Proto.ITransfer=} [properties] Properties to set
                     */
                    function Transfer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transfer amount.
                     * @member {string} amount
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.amount = "";
    
                    /**
                     * Transfer recipient.
                     * @member {string} recipient
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.recipient = "";
    
                    /**
                     * Transfer payload.
                     * @member {Uint8Array} payload
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @instance
                     */
                    Transfer.prototype.payload = $util.newBuffer([]);
    
                    /**
                     * Creates a new Transfer instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {TW.IoTeX.Proto.ITransfer=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.Transfer} Transfer instance
                     */
                    Transfer.create = function create(properties) {
                        return new Transfer(properties);
                    };
    
                    /**
                     * Encodes the specified Transfer message. Does not implicitly {@link TW.IoTeX.Proto.Transfer.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {TW.IoTeX.Proto.ITransfer} message Transfer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transfer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.amount);
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.recipient);
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Transfer message, length delimited. Does not implicitly {@link TW.IoTeX.Proto.Transfer.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {TW.IoTeX.Proto.ITransfer} message Transfer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transfer.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Transfer message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.Transfer} Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transfer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Transfer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.string();
                                break;
                            case 2:
                                message.recipient = reader.string();
                                break;
                            case 3:
                                message.payload = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Transfer message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IoTeX.Proto.Transfer} Transfer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transfer.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Transfer message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transfer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            if (!$util.isString(message.recipient))
                                return "recipient: string expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                return "payload: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.Transfer} Transfer
                     */
                    Transfer.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.Transfer)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.Transfer();
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        if (object.recipient != null)
                            message.recipient = String(object.recipient);
                        if (object.payload != null)
                            if (typeof object.payload === "string")
                                $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                            else if (object.payload.length)
                                message.payload = object.payload;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transfer message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @static
                     * @param {TW.IoTeX.Proto.Transfer} message Transfer
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transfer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.amount = "";
                            object.recipient = "";
                            if (options.bytes === String)
                                object.payload = "";
                            else {
                                object.payload = [];
                                if (options.bytes !== Array)
                                    object.payload = $util.newBuffer(object.payload);
                            }
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        if (message.recipient != null && message.hasOwnProperty("recipient"))
                            object.recipient = message.recipient;
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                        return object;
                    };
    
                    /**
                     * Converts this Transfer to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.Transfer
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transfer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transfer;
                })();
    
                Proto.Execution = (function() {
    
                    /**
                     * Properties of an Execution.
                     * @memberof TW.IoTeX.Proto
                     * @interface IExecution
                     * @property {string|null} [amount] Execution amount
                     * @property {string|null} [contract] Execution contract
                     * @property {Uint8Array|null} [data] Execution data
                     */
    
                    /**
                     * Constructs a new Execution.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents an Execution.
                     * @implements IExecution
                     * @constructor
                     * @param {TW.IoTeX.Proto.IExecution=} [properties] Properties to set
                     */
                    function Execution(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Execution amount.
                     * @member {string} amount
                     * @memberof TW.IoTeX.Proto.Execution
                     * @instance
                     */
                    Execution.prototype.amount = "";
    
                    /**
                     * Execution contract.
                     * @member {string} contract
                     * @memberof TW.IoTeX.Proto.Execution
                     * @instance
                     */
                    Execution.prototype.contract = "";
    
                    /**
                     * Execution data.
                     * @member {Uint8Array} data
                     * @memberof TW.IoTeX.Proto.Execution
                     * @instance
                     */
                    Execution.prototype.data = $util.newBuffer([]);
    
                    /**
                     * Creates a new Execution instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.Execution
                     * @static
                     * @param {TW.IoTeX.Proto.IExecution=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.Execution} Execution instance
                     */
                    Execution.create = function create(properties) {
                        return new Execution(properties);
                    };
    
                    /**
                     * Encodes the specified Execution message. Does not implicitly {@link TW.IoTeX.Proto.Execution.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.Execution
                     * @static
                     * @param {TW.IoTeX.Proto.IExecution} message Execution message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Execution.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.amount);
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.contract);
                        if (message.data != null && message.hasOwnProperty("data"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Execution message, length delimited. Does not implicitly {@link TW.IoTeX.Proto.Execution.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IoTeX.Proto.Execution
                     * @static
                     * @param {TW.IoTeX.Proto.IExecution} message Execution message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Execution.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an Execution message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.Execution
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.Execution} Execution
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Execution.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Execution();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.string();
                                break;
                            case 2:
                                message.contract = reader.string();
                                break;
                            case 3:
                                message.data = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an Execution message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IoTeX.Proto.Execution
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IoTeX.Proto.Execution} Execution
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Execution.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an Execution message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.Execution
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Execution.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isString(message.amount))
                                return "amount: string expected";
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            if (!$util.isString(message.contract))
                                return "contract: string expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                return "data: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates an Execution message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.Execution
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.Execution} Execution
                     */
                    Execution.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.Execution)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.Execution();
                        if (object.amount != null)
                            message.amount = String(object.amount);
                        if (object.contract != null)
                            message.contract = String(object.contract);
                        if (object.data != null)
                            if (typeof object.data === "string")
                                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                            else if (object.data.length)
                                message.data = object.data;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Execution message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.Execution
                     * @static
                     * @param {TW.IoTeX.Proto.Execution} message Execution
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Execution.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.amount = "";
                            object.contract = "";
                            if (options.bytes === String)
                                object.data = "";
                            else {
                                object.data = [];
                                if (options.bytes !== Array)
                                    object.data = $util.newBuffer(object.data);
                            }
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = message.amount;
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            object.contract = message.contract;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                        return object;
                    };
    
                    /**
                     * Converts this Execution to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.Execution
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Execution.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Execution;
                })();
    
                Proto.ActionCore = (function() {
    
                    /**
                     * Properties of an ActionCore.
                     * @memberof TW.IoTeX.Proto
                     * @interface IActionCore
                     * @property {number|null} [version] ActionCore version
                     * @property {Long|null} [nonce] ActionCore nonce
                     * @property {Long|null} [gasLimit] ActionCore gasLimit
                     * @property {string|null} [gasPrice] ActionCore gasPrice
                     * @property {TW.IoTeX.Proto.ITransfer|null} [transfer] ActionCore transfer
                     * @property {TW.IoTeX.Proto.IExecution|null} [execution] ActionCore execution
                     */
    
                    /**
                     * Constructs a new ActionCore.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents an ActionCore.
                     * @implements IActionCore
                     * @constructor
                     * @param {TW.IoTeX.Proto.IActionCore=} [properties] Properties to set
                     */
                    function ActionCore(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ActionCore version.
                     * @member {number} version
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.version = 0;
    
                    /**
                     * ActionCore nonce.
                     * @member {Long} nonce
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * ActionCore gasLimit.
                     * @member {Long} gasLimit
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.gasLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * ActionCore gasPrice.
                     * @member {string} gasPrice
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.gasPrice = "";
    
                    /**
                     * ActionCore transfer.
                     * @member {TW.IoTeX.Proto.ITransfer|null|undefined} transfer
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.transfer = null;
    
                    /**
                     * ActionCore execution.
                     * @member {TW.IoTeX.Proto.IExecution|null|undefined} execution
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    ActionCore.prototype.execution = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * ActionCore action.
                     * @member {"transfer"|"execution"|undefined} action
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     */
                    Object.defineProperty(ActionCore.prototype, "action", {
                        get: $util.oneOfGetter($oneOfFields = ["transfer", "execution"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new ActionCore instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {TW.IoTeX.Proto.IActionCore=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.ActionCore} ActionCore instance
                     */
                    ActionCore.create = function create(properties) {
                        return new ActionCore(properties);
                    };
    
                    /**
                     * Encodes the specified ActionCore message. Does not implicitly {@link TW.IoTeX.Proto.ActionCore.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {TW.IoTeX.Proto.IActionCore} message ActionCore message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ActionCore.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.version != null && message.hasOwnProperty("version"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nonce);
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.gasLimit);
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.gasPrice);
                        if (message.transfer != null && message.hasOwnProperty("transfer"))
                            $root.TW.IoTeX.Proto.Transfer.encode(message.transfer, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.execution != null && message.hasOwnProperty("execution"))
                            $root.TW.IoTeX.Proto.Execution.encode(message.execution, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ActionCore message, length delimited. Does not implicitly {@link TW.IoTeX.Proto.ActionCore.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {TW.IoTeX.Proto.IActionCore} message ActionCore message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ActionCore.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an ActionCore message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.ActionCore} ActionCore
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ActionCore.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.ActionCore();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.version = reader.uint32();
                                break;
                            case 2:
                                message.nonce = reader.uint64();
                                break;
                            case 3:
                                message.gasLimit = reader.uint64();
                                break;
                            case 4:
                                message.gasPrice = reader.string();
                                break;
                            case 10:
                                message.transfer = $root.TW.IoTeX.Proto.Transfer.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.execution = $root.TW.IoTeX.Proto.Execution.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an ActionCore message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IoTeX.Proto.ActionCore} ActionCore
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ActionCore.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an ActionCore message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ActionCore.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!$util.isInteger(message.gasLimit) && !(message.gasLimit && $util.isInteger(message.gasLimit.low) && $util.isInteger(message.gasLimit.high)))
                                return "gasLimit: integer|Long expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!$util.isString(message.gasPrice))
                                return "gasPrice: string expected";
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Transfer.verify(message.transfer);
                                if (error)
                                    return "transfer." + error;
                            }
                        }
                        if (message.execution != null && message.hasOwnProperty("execution")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Execution.verify(message.execution);
                                if (error)
                                    return "execution." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates an ActionCore message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.ActionCore} ActionCore
                     */
                    ActionCore.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.ActionCore)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.ActionCore();
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.gasLimit != null)
                            if ($util.Long)
                                (message.gasLimit = $util.Long.fromValue(object.gasLimit)).unsigned = true;
                            else if (typeof object.gasLimit === "string")
                                message.gasLimit = parseInt(object.gasLimit, 10);
                            else if (typeof object.gasLimit === "number")
                                message.gasLimit = object.gasLimit;
                            else if (typeof object.gasLimit === "object")
                                message.gasLimit = new $util.LongBits(object.gasLimit.low >>> 0, object.gasLimit.high >>> 0).toNumber(true);
                        if (object.gasPrice != null)
                            message.gasPrice = String(object.gasPrice);
                        if (object.transfer != null) {
                            if (typeof object.transfer !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.transfer: object expected");
                            message.transfer = $root.TW.IoTeX.Proto.Transfer.fromObject(object.transfer);
                        }
                        if (object.execution != null) {
                            if (typeof object.execution !== "object")
                                throw TypeError(".TW.IoTeX.Proto.ActionCore.execution: object expected");
                            message.execution = $root.TW.IoTeX.Proto.Execution.fromObject(object.execution);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an ActionCore message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @static
                     * @param {TW.IoTeX.Proto.ActionCore} message ActionCore
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ActionCore.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.version = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasLimit = options.longs === String ? "0" : 0;
                            object.gasPrice = "";
                        }
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit === "number")
                                object.gasLimit = options.longs === String ? String(message.gasLimit) : message.gasLimit;
                            else
                                object.gasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.gasLimit) : options.longs === Number ? new $util.LongBits(message.gasLimit.low >>> 0, message.gasLimit.high >>> 0).toNumber(true) : message.gasLimit;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = message.gasPrice;
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            object.transfer = $root.TW.IoTeX.Proto.Transfer.toObject(message.transfer, options);
                            if (options.oneofs)
                                object.action = "transfer";
                        }
                        if (message.execution != null && message.hasOwnProperty("execution")) {
                            object.execution = $root.TW.IoTeX.Proto.Execution.toObject(message.execution, options);
                            if (options.oneofs)
                                object.action = "execution";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this ActionCore to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.ActionCore
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ActionCore.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ActionCore;
                })();
    
                Proto.Action = (function() {
    
                    /**
                     * Properties of an Action.
                     * @memberof TW.IoTeX.Proto
                     * @interface IAction
                     * @property {TW.IoTeX.Proto.IActionCore|null} [core] Action core
                     * @property {Uint8Array|null} [senderPubKey] Action senderPubKey
                     * @property {Uint8Array|null} [signature] Action signature
                     */
    
                    /**
                     * Constructs a new Action.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents an Action.
                     * @implements IAction
                     * @constructor
                     * @param {TW.IoTeX.Proto.IAction=} [properties] Properties to set
                     */
                    function Action(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Action core.
                     * @member {TW.IoTeX.Proto.IActionCore|null|undefined} core
                     * @memberof TW.IoTeX.Proto.Action
                     * @instance
                     */
                    Action.prototype.core = null;
    
                    /**
                     * Action senderPubKey.
                     * @member {Uint8Array} senderPubKey
                     * @memberof TW.IoTeX.Proto.Action
                     * @instance
                     */
                    Action.prototype.senderPubKey = $util.newBuffer([]);
    
                    /**
                     * Action signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.IoTeX.Proto.Action
                     * @instance
                     */
                    Action.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new Action instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {TW.IoTeX.Proto.IAction=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.Action} Action instance
                     */
                    Action.create = function create(properties) {
                        return new Action(properties);
                    };
    
                    /**
                     * Encodes the specified Action message. Does not implicitly {@link TW.IoTeX.Proto.Action.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {TW.IoTeX.Proto.IAction} message Action message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Action.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.core != null && message.hasOwnProperty("core"))
                            $root.TW.IoTeX.Proto.ActionCore.encode(message.core, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.senderPubKey != null && message.hasOwnProperty("senderPubKey"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPubKey);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Action message, length delimited. Does not implicitly {@link TW.IoTeX.Proto.Action.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {TW.IoTeX.Proto.IAction} message Action message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Action.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an Action message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.Action} Action
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Action.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.Action();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.core = $root.TW.IoTeX.Proto.ActionCore.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.senderPubKey = reader.bytes();
                                break;
                            case 3:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an Action message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IoTeX.Proto.Action} Action
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Action.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an Action message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Action.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.core != null && message.hasOwnProperty("core")) {
                            var error = $root.TW.IoTeX.Proto.ActionCore.verify(message.core);
                            if (error)
                                return "core." + error;
                        }
                        if (message.senderPubKey != null && message.hasOwnProperty("senderPubKey"))
                            if (!(message.senderPubKey && typeof message.senderPubKey.length === "number" || $util.isString(message.senderPubKey)))
                                return "senderPubKey: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates an Action message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.Action} Action
                     */
                    Action.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.Action)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.Action();
                        if (object.core != null) {
                            if (typeof object.core !== "object")
                                throw TypeError(".TW.IoTeX.Proto.Action.core: object expected");
                            message.core = $root.TW.IoTeX.Proto.ActionCore.fromObject(object.core);
                        }
                        if (object.senderPubKey != null)
                            if (typeof object.senderPubKey === "string")
                                $util.base64.decode(object.senderPubKey, message.senderPubKey = $util.newBuffer($util.base64.length(object.senderPubKey)), 0);
                            else if (object.senderPubKey.length)
                                message.senderPubKey = object.senderPubKey;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Action message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.Action
                     * @static
                     * @param {TW.IoTeX.Proto.Action} message Action
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Action.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.core = null;
                            if (options.bytes === String)
                                object.senderPubKey = "";
                            else {
                                object.senderPubKey = [];
                                if (options.bytes !== Array)
                                    object.senderPubKey = $util.newBuffer(object.senderPubKey);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.core != null && message.hasOwnProperty("core"))
                            object.core = $root.TW.IoTeX.Proto.ActionCore.toObject(message.core, options);
                        if (message.senderPubKey != null && message.hasOwnProperty("senderPubKey"))
                            object.senderPubKey = options.bytes === String ? $util.base64.encode(message.senderPubKey, 0, message.senderPubKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPubKey) : message.senderPubKey;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this Action to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.Action
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Action.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Action;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.IoTeX.Proto
                     * @interface ISigningInput
                     * @property {number|null} [version] SigningInput version
                     * @property {Long|null} [nonce] SigningInput nonce
                     * @property {Long|null} [gasLimit] SigningInput gasLimit
                     * @property {string|null} [gasPrice] SigningInput gasPrice
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.IoTeX.Proto.ITransfer|null} [transfer] SigningInput transfer
                     * @property {TW.IoTeX.Proto.IExecution|null} [execution] SigningInput execution
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.IoTeX.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput version.
                     * @member {number} version
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.version = 0;
    
                    /**
                     * SigningInput nonce.
                     * @member {Long} nonce
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Long} gasLimit
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput gasPrice.
                     * @member {string} gasPrice
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = "";
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput transfer.
                     * @member {TW.IoTeX.Proto.ITransfer|null|undefined} transfer
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transfer = null;
    
                    /**
                     * SigningInput execution.
                     * @member {TW.IoTeX.Proto.IExecution|null|undefined} execution
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.execution = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput action.
                     * @member {"transfer"|"execution"|undefined} action
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "action", {
                        get: $util.oneOfGetter($oneOfFields = ["transfer", "execution"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {TW.IoTeX.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.IoTeX.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {TW.IoTeX.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.version != null && message.hasOwnProperty("version"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nonce);
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.gasLimit);
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.gasPrice);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.privateKey);
                        if (message.transfer != null && message.hasOwnProperty("transfer"))
                            $root.TW.IoTeX.Proto.Transfer.encode(message.transfer, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.execution != null && message.hasOwnProperty("execution"))
                            $root.TW.IoTeX.Proto.Execution.encode(message.execution, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.IoTeX.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {TW.IoTeX.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.version = reader.uint32();
                                break;
                            case 2:
                                message.nonce = reader.uint64();
                                break;
                            case 3:
                                message.gasLimit = reader.uint64();
                                break;
                            case 4:
                                message.gasPrice = reader.string();
                                break;
                            case 5:
                                message.privateKey = reader.bytes();
                                break;
                            case 10:
                                message.transfer = $root.TW.IoTeX.Proto.Transfer.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.execution = $root.TW.IoTeX.Proto.Execution.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IoTeX.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!$util.isInteger(message.gasLimit) && !(message.gasLimit && $util.isInteger(message.gasLimit.low) && $util.isInteger(message.gasLimit.high)))
                                return "gasLimit: integer|Long expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!$util.isString(message.gasPrice))
                                return "gasPrice: string expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Transfer.verify(message.transfer);
                                if (error)
                                    return "transfer." + error;
                            }
                        }
                        if (message.execution != null && message.hasOwnProperty("execution")) {
                            if (properties.action === 1)
                                return "action: multiple values";
                            properties.action = 1;
                            {
                                var error = $root.TW.IoTeX.Proto.Execution.verify(message.execution);
                                if (error)
                                    return "execution." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.SigningInput();
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.gasLimit != null)
                            if ($util.Long)
                                (message.gasLimit = $util.Long.fromValue(object.gasLimit)).unsigned = true;
                            else if (typeof object.gasLimit === "string")
                                message.gasLimit = parseInt(object.gasLimit, 10);
                            else if (typeof object.gasLimit === "number")
                                message.gasLimit = object.gasLimit;
                            else if (typeof object.gasLimit === "object")
                                message.gasLimit = new $util.LongBits(object.gasLimit.low >>> 0, object.gasLimit.high >>> 0).toNumber(true);
                        if (object.gasPrice != null)
                            message.gasPrice = String(object.gasPrice);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.transfer != null) {
                            if (typeof object.transfer !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.transfer: object expected");
                            message.transfer = $root.TW.IoTeX.Proto.Transfer.fromObject(object.transfer);
                        }
                        if (object.execution != null) {
                            if (typeof object.execution !== "object")
                                throw TypeError(".TW.IoTeX.Proto.SigningInput.execution: object expected");
                            message.execution = $root.TW.IoTeX.Proto.Execution.fromObject(object.execution);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @static
                     * @param {TW.IoTeX.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.version = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasLimit = options.longs === String ? "0" : 0;
                            object.gasPrice = "";
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit === "number")
                                object.gasLimit = options.longs === String ? String(message.gasLimit) : message.gasLimit;
                            else
                                object.gasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.gasLimit) : options.longs === Number ? new $util.LongBits(message.gasLimit.low >>> 0, message.gasLimit.high >>> 0).toNumber(true) : message.gasLimit;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = message.gasPrice;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            object.transfer = $root.TW.IoTeX.Proto.Transfer.toObject(message.transfer, options);
                            if (options.oneofs)
                                object.action = "transfer";
                        }
                        if (message.execution != null && message.hasOwnProperty("execution")) {
                            object.execution = $root.TW.IoTeX.Proto.Execution.toObject(message.execution, options);
                            if (options.oneofs)
                                object.action = "execution";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.IoTeX.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [hash] SigningOutput hash
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.IoTeX.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.IoTeX.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput hash.
                     * @member {Uint8Array} hash
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.hash = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {TW.IoTeX.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.IoTeX.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.IoTeX.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {TW.IoTeX.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.IoTeX.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {TW.IoTeX.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.IoTeX.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.IoTeX.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.hash = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.IoTeX.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                                return "hash: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.IoTeX.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.IoTeX.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.IoTeX.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.hash != null)
                            if (typeof object.hash === "string")
                                $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                            else if (object.hash.length)
                                message.hash = object.hash;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @static
                     * @param {TW.IoTeX.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if (options.bytes === String)
                                object.hash = "";
                            else {
                                object.hash = [];
                                if (options.bytes !== Array)
                                    object.hash = $util.newBuffer(object.hash);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.IoTeX.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return IoTeX;
        })();
    
        TW.NULS = (function() {
    
            /**
             * Namespace NULS.
             * @memberof TW
             * @namespace
             */
            var NULS = {};
    
            NULS.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.NULS
                 * @namespace
                 */
                var Proto = {};
    
                Proto.TransactionInput = (function() {
    
                    /**
                     * Properties of a TransactionInput.
                     * @memberof TW.NULS.Proto
                     * @interface ITransactionInput
                     * @property {string|null} [fromHash] TransactionInput fromHash
                     * @property {number|null} [fromIndex] TransactionInput fromIndex
                     * @property {Long|null} [amount] TransactionInput amount
                     * @property {Long|null} [lockTime] TransactionInput lockTime
                     * @property {string|null} [address] TransactionInput address
                     */
    
                    /**
                     * Constructs a new TransactionInput.
                     * @memberof TW.NULS.Proto
                     * @classdesc Represents a TransactionInput.
                     * @implements ITransactionInput
                     * @constructor
                     * @param {TW.NULS.Proto.ITransactionInput=} [properties] Properties to set
                     */
                    function TransactionInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionInput fromHash.
                     * @member {string} fromHash
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.fromHash = "";
    
                    /**
                     * TransactionInput fromIndex.
                     * @member {number} fromIndex
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.fromIndex = 0;
    
                    /**
                     * TransactionInput amount.
                     * @member {Long} amount
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionInput lockTime.
                     * @member {Long} lockTime
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.lockTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionInput address.
                     * @member {string} address
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @instance
                     */
                    TransactionInput.prototype.address = "";
    
                    /**
                     * Creates a new TransactionInput instance using the specified properties.
                     * @function create
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @static
                     * @param {TW.NULS.Proto.ITransactionInput=} [properties] Properties to set
                     * @returns {TW.NULS.Proto.TransactionInput} TransactionInput instance
                     */
                    TransactionInput.create = function create(properties) {
                        return new TransactionInput(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionInput message. Does not implicitly {@link TW.NULS.Proto.TransactionInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @static
                     * @param {TW.NULS.Proto.ITransactionInput} message TransactionInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromHash != null && message.hasOwnProperty("fromHash"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.fromHash);
                        if (message.fromIndex != null && message.hasOwnProperty("fromIndex"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fromIndex);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.lockTime);
                        if (message.address != null && message.hasOwnProperty("address"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.address);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TransactionInput message, length delimited. Does not implicitly {@link TW.NULS.Proto.TransactionInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @static
                     * @param {TW.NULS.Proto.ITransactionInput} message TransactionInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TransactionInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NULS.Proto.TransactionInput} TransactionInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NULS.Proto.TransactionInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromHash = reader.string();
                                break;
                            case 2:
                                message.fromIndex = reader.int32();
                                break;
                            case 3:
                                message.amount = reader.int64();
                                break;
                            case 4:
                                message.lockTime = reader.int64();
                                break;
                            case 5:
                                message.address = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TransactionInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.NULS.Proto.TransactionInput} TransactionInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TransactionInput message.
                     * @function verify
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromHash != null && message.hasOwnProperty("fromHash"))
                            if (!$util.isString(message.fromHash))
                                return "fromHash: string expected";
                        if (message.fromIndex != null && message.hasOwnProperty("fromIndex"))
                            if (!$util.isInteger(message.fromIndex))
                                return "fromIndex: integer expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (!$util.isInteger(message.lockTime) && !(message.lockTime && $util.isInteger(message.lockTime.low) && $util.isInteger(message.lockTime.high)))
                                return "lockTime: integer|Long expected";
                        if (message.address != null && message.hasOwnProperty("address"))
                            if (!$util.isString(message.address))
                                return "address: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NULS.Proto.TransactionInput} TransactionInput
                     */
                    TransactionInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NULS.Proto.TransactionInput)
                            return object;
                        var message = new $root.TW.NULS.Proto.TransactionInput();
                        if (object.fromHash != null)
                            message.fromHash = String(object.fromHash);
                        if (object.fromIndex != null)
                            message.fromIndex = object.fromIndex | 0;
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.lockTime != null)
                            if ($util.Long)
                                (message.lockTime = $util.Long.fromValue(object.lockTime)).unsigned = false;
                            else if (typeof object.lockTime === "string")
                                message.lockTime = parseInt(object.lockTime, 10);
                            else if (typeof object.lockTime === "number")
                                message.lockTime = object.lockTime;
                            else if (typeof object.lockTime === "object")
                                message.lockTime = new $util.LongBits(object.lockTime.low >>> 0, object.lockTime.high >>> 0).toNumber();
                        if (object.address != null)
                            message.address = String(object.address);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @static
                     * @param {TW.NULS.Proto.TransactionInput} message TransactionInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fromHash = "";
                            object.fromIndex = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.lockTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.lockTime = options.longs === String ? "0" : 0;
                            object.address = "";
                        }
                        if (message.fromHash != null && message.hasOwnProperty("fromHash"))
                            object.fromHash = message.fromHash;
                        if (message.fromIndex != null && message.hasOwnProperty("fromIndex"))
                            object.fromIndex = message.fromIndex;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (typeof message.lockTime === "number")
                                object.lockTime = options.longs === String ? String(message.lockTime) : message.lockTime;
                            else
                                object.lockTime = options.longs === String ? $util.Long.prototype.toString.call(message.lockTime) : options.longs === Number ? new $util.LongBits(message.lockTime.low >>> 0, message.lockTime.high >>> 0).toNumber() : message.lockTime;
                        if (message.address != null && message.hasOwnProperty("address"))
                            object.address = message.address;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionInput to JSON.
                     * @function toJSON
                     * @memberof TW.NULS.Proto.TransactionInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionInput;
                })();
    
                Proto.TransactionOutput = (function() {
    
                    /**
                     * Properties of a TransactionOutput.
                     * @memberof TW.NULS.Proto
                     * @interface ITransactionOutput
                     * @property {string|null} [toAddress] TransactionOutput toAddress
                     * @property {Long|null} [amount] TransactionOutput amount
                     * @property {Long|null} [lockTime] TransactionOutput lockTime
                     * @property {number|null} [index] TransactionOutput index
                     */
    
                    /**
                     * Constructs a new TransactionOutput.
                     * @memberof TW.NULS.Proto
                     * @classdesc Represents a TransactionOutput.
                     * @implements ITransactionOutput
                     * @constructor
                     * @param {TW.NULS.Proto.ITransactionOutput=} [properties] Properties to set
                     */
                    function TransactionOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionOutput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.toAddress = "";
    
                    /**
                     * TransactionOutput amount.
                     * @member {Long} amount
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionOutput lockTime.
                     * @member {Long} lockTime
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.lockTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionOutput index.
                     * @member {number} index
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @instance
                     */
                    TransactionOutput.prototype.index = 0;
    
                    /**
                     * Creates a new TransactionOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @static
                     * @param {TW.NULS.Proto.ITransactionOutput=} [properties] Properties to set
                     * @returns {TW.NULS.Proto.TransactionOutput} TransactionOutput instance
                     */
                    TransactionOutput.create = function create(properties) {
                        return new TransactionOutput(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionOutput message. Does not implicitly {@link TW.NULS.Proto.TransactionOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @static
                     * @param {TW.NULS.Proto.ITransactionOutput} message TransactionOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.toAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.lockTime);
                        if (message.index != null && message.hasOwnProperty("index"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.index);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TransactionOutput message, length delimited. Does not implicitly {@link TW.NULS.Proto.TransactionOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @static
                     * @param {TW.NULS.Proto.ITransactionOutput} message TransactionOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TransactionOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NULS.Proto.TransactionOutput} TransactionOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NULS.Proto.TransactionOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.toAddress = reader.string();
                                break;
                            case 2:
                                message.amount = reader.int64();
                                break;
                            case 3:
                                message.lockTime = reader.int64();
                                break;
                            case 4:
                                message.index = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TransactionOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.NULS.Proto.TransactionOutput} TransactionOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TransactionOutput message.
                     * @function verify
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (!$util.isInteger(message.lockTime) && !(message.lockTime && $util.isInteger(message.lockTime.low) && $util.isInteger(message.lockTime.high)))
                                return "lockTime: integer|Long expected";
                        if (message.index != null && message.hasOwnProperty("index"))
                            if (!$util.isInteger(message.index))
                                return "index: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NULS.Proto.TransactionOutput} TransactionOutput
                     */
                    TransactionOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NULS.Proto.TransactionOutput)
                            return object;
                        var message = new $root.TW.NULS.Proto.TransactionOutput();
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.lockTime != null)
                            if ($util.Long)
                                (message.lockTime = $util.Long.fromValue(object.lockTime)).unsigned = false;
                            else if (typeof object.lockTime === "string")
                                message.lockTime = parseInt(object.lockTime, 10);
                            else if (typeof object.lockTime === "number")
                                message.lockTime = object.lockTime;
                            else if (typeof object.lockTime === "object")
                                message.lockTime = new $util.LongBits(object.lockTime.low >>> 0, object.lockTime.high >>> 0).toNumber();
                        if (object.index != null)
                            message.index = object.index | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @static
                     * @param {TW.NULS.Proto.TransactionOutput} message TransactionOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.lockTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.lockTime = options.longs === String ? "0" : 0;
                            object.index = 0;
                        }
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.lockTime != null && message.hasOwnProperty("lockTime"))
                            if (typeof message.lockTime === "number")
                                object.lockTime = options.longs === String ? String(message.lockTime) : message.lockTime;
                            else
                                object.lockTime = options.longs === String ? $util.Long.prototype.toString.call(message.lockTime) : options.longs === Number ? new $util.LongBits(message.lockTime.low >>> 0, message.lockTime.high >>> 0).toNumber() : message.lockTime;
                        if (message.index != null && message.hasOwnProperty("index"))
                            object.index = message.index;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionOutput to JSON.
                     * @function toJSON
                     * @memberof TW.NULS.Proto.TransactionOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionOutput;
                })();
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.NULS.Proto
                     * @interface ITransaction
                     * @property {string|null} [fromAddress] Transaction fromAddress
                     * @property {string|null} [toAddress] Transaction toAddress
                     * @property {Long|null} [amount] Transaction amount
                     * @property {string|null} [remark] UTF-8 encode strings
                     * @property {Long|null} [timestamp] Transaction timestamp
                     * @property {Array.<TW.NULS.Proto.ITransactionInput>|null} [inputs] Unspent input list
                     * @property {Array.<TW.NULS.Proto.ITransactionOutput>|null} [outputs] Output list
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.NULS.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.NULS.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        this.inputs = [];
                        this.outputs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.fromAddress = "";
    
                    /**
                     * Transaction toAddress.
                     * @member {string} toAddress
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.toAddress = "";
    
                    /**
                     * Transaction amount.
                     * @member {Long} amount
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * UTF-8 encode strings
                     * @member {string} remark
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.remark = "";
    
                    /**
                     * Transaction timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Unspent input list
                     * @member {Array.<TW.NULS.Proto.ITransactionInput>} inputs
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.inputs = $util.emptyArray;
    
                    /**
                     * Output list
                     * @member {Array.<TW.NULS.Proto.ITransactionOutput>} outputs
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.outputs = $util.emptyArray;
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {TW.NULS.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.NULS.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.NULS.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {TW.NULS.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.fromAddress);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.toAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.amount);
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.remark);
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
                        if (message.inputs != null && message.inputs.length)
                            for (var i = 0; i < message.inputs.length; ++i)
                                $root.TW.NULS.Proto.TransactionInput.encode(message.inputs[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.outputs != null && message.outputs.length)
                            for (var i = 0; i < message.outputs.length; ++i)
                                $root.TW.NULS.Proto.TransactionOutput.encode(message.outputs[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Transaction message, length delimited. Does not implicitly {@link TW.NULS.Proto.Transaction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {TW.NULS.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NULS.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NULS.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 2:
                                message.fromAddress = reader.string();
                                break;
                            case 3:
                                message.toAddress = reader.string();
                                break;
                            case 4:
                                message.amount = reader.int64();
                                break;
                            case 5:
                                message.remark = reader.string();
                                break;
                            case 6:
                                message.timestamp = reader.int64();
                                break;
                            case 7:
                                if (!(message.inputs && message.inputs.length))
                                    message.inputs = [];
                                message.inputs.push($root.TW.NULS.Proto.TransactionInput.decode(reader, reader.uint32()));
                                break;
                            case 8:
                                if (!(message.outputs && message.outputs.length))
                                    message.outputs = [];
                                message.outputs.push($root.TW.NULS.Proto.TransactionOutput.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.NULS.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            if (!$util.isString(message.remark))
                                return "remark: string expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.inputs != null && message.hasOwnProperty("inputs")) {
                            if (!Array.isArray(message.inputs))
                                return "inputs: array expected";
                            for (var i = 0; i < message.inputs.length; ++i) {
                                var error = $root.TW.NULS.Proto.TransactionInput.verify(message.inputs[i]);
                                if (error)
                                    return "inputs." + error;
                            }
                        }
                        if (message.outputs != null && message.hasOwnProperty("outputs")) {
                            if (!Array.isArray(message.outputs))
                                return "outputs: array expected";
                            for (var i = 0; i < message.outputs.length; ++i) {
                                var error = $root.TW.NULS.Proto.TransactionOutput.verify(message.outputs[i]);
                                if (error)
                                    return "outputs." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NULS.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NULS.Proto.Transaction)
                            return object;
                        var message = new $root.TW.NULS.Proto.Transaction();
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.remark != null)
                            message.remark = String(object.remark);
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.inputs) {
                            if (!Array.isArray(object.inputs))
                                throw TypeError(".TW.NULS.Proto.Transaction.inputs: array expected");
                            message.inputs = [];
                            for (var i = 0; i < object.inputs.length; ++i) {
                                if (typeof object.inputs[i] !== "object")
                                    throw TypeError(".TW.NULS.Proto.Transaction.inputs: object expected");
                                message.inputs[i] = $root.TW.NULS.Proto.TransactionInput.fromObject(object.inputs[i]);
                            }
                        }
                        if (object.outputs) {
                            if (!Array.isArray(object.outputs))
                                throw TypeError(".TW.NULS.Proto.Transaction.outputs: array expected");
                            message.outputs = [];
                            for (var i = 0; i < object.outputs.length; ++i) {
                                if (typeof object.outputs[i] !== "object")
                                    throw TypeError(".TW.NULS.Proto.Transaction.outputs: object expected");
                                message.outputs[i] = $root.TW.NULS.Proto.TransactionOutput.fromObject(object.outputs[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NULS.Proto.Transaction
                     * @static
                     * @param {TW.NULS.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.inputs = [];
                            object.outputs = [];
                        }
                        if (options.defaults) {
                            object.fromAddress = "";
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.remark = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            object.remark = message.remark;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.inputs && message.inputs.length) {
                            object.inputs = [];
                            for (var j = 0; j < message.inputs.length; ++j)
                                object.inputs[j] = $root.TW.NULS.Proto.TransactionInput.toObject(message.inputs[j], options);
                        }
                        if (message.outputs && message.outputs.length) {
                            object.outputs = [];
                            for (var j = 0; j < message.outputs.length; ++j)
                                object.outputs[j] = $root.TW.NULS.Proto.TransactionOutput.toObject(message.outputs[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.NULS.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.TransactionPurpose = (function() {
    
                    /**
                     * Properties of a TransactionPurpose.
                     * @memberof TW.NULS.Proto
                     * @interface ITransactionPurpose
                     * @property {Uint8Array|null} [privateKey] TransactionPurpose privateKey
                     * @property {string|null} [fromAddress] TransactionPurpose fromAddress
                     * @property {string|null} [toAddress] TransactionPurpose toAddress
                     * @property {Long|null} [amount] TransactionPurpose amount
                     * @property {string|null} [remark] UTF-8 encode strings
                     * @property {Long|null} [timestamp] TransactionPurpose timestamp
                     * @property {Array.<TW.NULS.Proto.ITransactionInput>|null} [utxos] Unspent input list
                     * @property {boolean|null} [useMaxAmount] TransactionPurpose useMaxAmount
                     */
    
                    /**
                     * Constructs a new TransactionPurpose.
                     * @memberof TW.NULS.Proto
                     * @classdesc Represents a TransactionPurpose.
                     * @implements ITransactionPurpose
                     * @constructor
                     * @param {TW.NULS.Proto.ITransactionPurpose=} [properties] Properties to set
                     */
                    function TransactionPurpose(properties) {
                        this.utxos = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionPurpose privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @instance
                     */
                    TransactionPurpose.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * TransactionPurpose fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @instance
                     */
                    TransactionPurpose.prototype.fromAddress = "";
    
                    /**
                     * TransactionPurpose toAddress.
                     * @member {string} toAddress
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @instance
                     */
                    TransactionPurpose.prototype.toAddress = "";
    
                    /**
                     * TransactionPurpose amount.
                     * @member {Long} amount
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @instance
                     */
                    TransactionPurpose.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * UTF-8 encode strings
                     * @member {string} remark
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @instance
                     */
                    TransactionPurpose.prototype.remark = "";
    
                    /**
                     * TransactionPurpose timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @instance
                     */
                    TransactionPurpose.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Unspent input list
                     * @member {Array.<TW.NULS.Proto.ITransactionInput>} utxos
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @instance
                     */
                    TransactionPurpose.prototype.utxos = $util.emptyArray;
    
                    /**
                     * TransactionPurpose useMaxAmount.
                     * @member {boolean} useMaxAmount
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @instance
                     */
                    TransactionPurpose.prototype.useMaxAmount = false;
    
                    /**
                     * Creates a new TransactionPurpose instance using the specified properties.
                     * @function create
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @static
                     * @param {TW.NULS.Proto.ITransactionPurpose=} [properties] Properties to set
                     * @returns {TW.NULS.Proto.TransactionPurpose} TransactionPurpose instance
                     */
                    TransactionPurpose.create = function create(properties) {
                        return new TransactionPurpose(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionPurpose message. Does not implicitly {@link TW.NULS.Proto.TransactionPurpose.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @static
                     * @param {TW.NULS.Proto.ITransactionPurpose} message TransactionPurpose message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionPurpose.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.fromAddress);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.toAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.amount);
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.remark);
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
                        if (message.utxos != null && message.utxos.length)
                            for (var i = 0; i < message.utxos.length; ++i)
                                $root.TW.NULS.Proto.TransactionInput.encode(message.utxos[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.useMaxAmount != null && message.hasOwnProperty("useMaxAmount"))
                            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.useMaxAmount);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TransactionPurpose message, length delimited. Does not implicitly {@link TW.NULS.Proto.TransactionPurpose.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @static
                     * @param {TW.NULS.Proto.ITransactionPurpose} message TransactionPurpose message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionPurpose.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TransactionPurpose message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NULS.Proto.TransactionPurpose} TransactionPurpose
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionPurpose.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NULS.Proto.TransactionPurpose();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.privateKey = reader.bytes();
                                break;
                            case 2:
                                message.fromAddress = reader.string();
                                break;
                            case 3:
                                message.toAddress = reader.string();
                                break;
                            case 4:
                                message.amount = reader.int64();
                                break;
                            case 5:
                                message.remark = reader.string();
                                break;
                            case 6:
                                message.timestamp = reader.int64();
                                break;
                            case 7:
                                if (!(message.utxos && message.utxos.length))
                                    message.utxos = [];
                                message.utxos.push($root.TW.NULS.Proto.TransactionInput.decode(reader, reader.uint32()));
                                break;
                            case 8:
                                message.useMaxAmount = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TransactionPurpose message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.NULS.Proto.TransactionPurpose} TransactionPurpose
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionPurpose.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TransactionPurpose message.
                     * @function verify
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionPurpose.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            if (!$util.isString(message.remark))
                                return "remark: string expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.utxos != null && message.hasOwnProperty("utxos")) {
                            if (!Array.isArray(message.utxos))
                                return "utxos: array expected";
                            for (var i = 0; i < message.utxos.length; ++i) {
                                var error = $root.TW.NULS.Proto.TransactionInput.verify(message.utxos[i]);
                                if (error)
                                    return "utxos." + error;
                            }
                        }
                        if (message.useMaxAmount != null && message.hasOwnProperty("useMaxAmount"))
                            if (typeof message.useMaxAmount !== "boolean")
                                return "useMaxAmount: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionPurpose message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NULS.Proto.TransactionPurpose} TransactionPurpose
                     */
                    TransactionPurpose.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NULS.Proto.TransactionPurpose)
                            return object;
                        var message = new $root.TW.NULS.Proto.TransactionPurpose();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.remark != null)
                            message.remark = String(object.remark);
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.utxos) {
                            if (!Array.isArray(object.utxos))
                                throw TypeError(".TW.NULS.Proto.TransactionPurpose.utxos: array expected");
                            message.utxos = [];
                            for (var i = 0; i < object.utxos.length; ++i) {
                                if (typeof object.utxos[i] !== "object")
                                    throw TypeError(".TW.NULS.Proto.TransactionPurpose.utxos: object expected");
                                message.utxos[i] = $root.TW.NULS.Proto.TransactionInput.fromObject(object.utxos[i]);
                            }
                        }
                        if (object.useMaxAmount != null)
                            message.useMaxAmount = Boolean(object.useMaxAmount);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionPurpose message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @static
                     * @param {TW.NULS.Proto.TransactionPurpose} message TransactionPurpose
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionPurpose.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.utxos = [];
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.fromAddress = "";
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.remark = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            object.useMaxAmount = false;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            object.remark = message.remark;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.utxos && message.utxos.length) {
                            object.utxos = [];
                            for (var j = 0; j < message.utxos.length; ++j)
                                object.utxos[j] = $root.TW.NULS.Proto.TransactionInput.toObject(message.utxos[j], options);
                        }
                        if (message.useMaxAmount != null && message.hasOwnProperty("useMaxAmount"))
                            object.useMaxAmount = message.useMaxAmount;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionPurpose to JSON.
                     * @function toJSON
                     * @memberof TW.NULS.Proto.TransactionPurpose
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionPurpose.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionPurpose;
                })();
    
                Proto.TransactionPlan = (function() {
    
                    /**
                     * Properties of a TransactionPlan.
                     * @memberof TW.NULS.Proto
                     * @interface ITransactionPlan
                     * @property {Uint8Array|null} [privateKey] TransactionPlan privateKey
                     * @property {string|null} [fromAddress] TransactionPlan fromAddress
                     * @property {string|null} [toAddress] TransactionPlan toAddress
                     * @property {Long|null} [amount] TransactionPlan amount
                     * @property {string|null} [remark] UTF-8 encode strings
                     * @property {Long|null} [timestamp] TransactionPlan timestamp
                     * @property {Long|null} [fee] TransactionPlan fee
                     * @property {Long|null} [change] TransactionPlan change
                     * @property {Long|null} [availableAmount] TransactionPlan availableAmount
                     * @property {Array.<TW.NULS.Proto.ITransactionInput>|null} [inputs] Selected Unspent input list
                     * @property {Array.<TW.NULS.Proto.ITransactionOutput>|null} [outputs] TransactionPlan outputs
                     */
    
                    /**
                     * Constructs a new TransactionPlan.
                     * @memberof TW.NULS.Proto
                     * @classdesc Represents a TransactionPlan.
                     * @implements ITransactionPlan
                     * @constructor
                     * @param {TW.NULS.Proto.ITransactionPlan=} [properties] Properties to set
                     */
                    function TransactionPlan(properties) {
                        this.inputs = [];
                        this.outputs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionPlan privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * TransactionPlan fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.fromAddress = "";
    
                    /**
                     * TransactionPlan toAddress.
                     * @member {string} toAddress
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.toAddress = "";
    
                    /**
                     * TransactionPlan amount.
                     * @member {Long} amount
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * UTF-8 encode strings
                     * @member {string} remark
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.remark = "";
    
                    /**
                     * TransactionPlan timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionPlan fee.
                     * @member {Long} fee
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionPlan change.
                     * @member {Long} change
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.change = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * TransactionPlan availableAmount.
                     * @member {Long} availableAmount
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.availableAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Selected Unspent input list
                     * @member {Array.<TW.NULS.Proto.ITransactionInput>} inputs
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.inputs = $util.emptyArray;
    
                    /**
                     * TransactionPlan outputs.
                     * @member {Array.<TW.NULS.Proto.ITransactionOutput>} outputs
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @instance
                     */
                    TransactionPlan.prototype.outputs = $util.emptyArray;
    
                    /**
                     * Creates a new TransactionPlan instance using the specified properties.
                     * @function create
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @static
                     * @param {TW.NULS.Proto.ITransactionPlan=} [properties] Properties to set
                     * @returns {TW.NULS.Proto.TransactionPlan} TransactionPlan instance
                     */
                    TransactionPlan.create = function create(properties) {
                        return new TransactionPlan(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionPlan message. Does not implicitly {@link TW.NULS.Proto.TransactionPlan.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @static
                     * @param {TW.NULS.Proto.ITransactionPlan} message TransactionPlan message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionPlan.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.fromAddress);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.toAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.amount);
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.remark);
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.fee);
                        if (message.change != null && message.hasOwnProperty("change"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.change);
                        if (message.availableAmount != null && message.hasOwnProperty("availableAmount"))
                            writer.uint32(/* id 9, wireType 0 =*/72).int64(message.availableAmount);
                        if (message.inputs != null && message.inputs.length)
                            for (var i = 0; i < message.inputs.length; ++i)
                                $root.TW.NULS.Proto.TransactionInput.encode(message.inputs[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.outputs != null && message.outputs.length)
                            for (var i = 0; i < message.outputs.length; ++i)
                                $root.TW.NULS.Proto.TransactionOutput.encode(message.outputs[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TransactionPlan message, length delimited. Does not implicitly {@link TW.NULS.Proto.TransactionPlan.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @static
                     * @param {TW.NULS.Proto.ITransactionPlan} message TransactionPlan message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionPlan.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TransactionPlan message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NULS.Proto.TransactionPlan} TransactionPlan
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionPlan.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NULS.Proto.TransactionPlan();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.privateKey = reader.bytes();
                                break;
                            case 2:
                                message.fromAddress = reader.string();
                                break;
                            case 3:
                                message.toAddress = reader.string();
                                break;
                            case 4:
                                message.amount = reader.int64();
                                break;
                            case 5:
                                message.remark = reader.string();
                                break;
                            case 6:
                                message.timestamp = reader.int64();
                                break;
                            case 7:
                                message.fee = reader.int64();
                                break;
                            case 8:
                                message.change = reader.int64();
                                break;
                            case 9:
                                message.availableAmount = reader.int64();
                                break;
                            case 10:
                                if (!(message.inputs && message.inputs.length))
                                    message.inputs = [];
                                message.inputs.push($root.TW.NULS.Proto.TransactionInput.decode(reader, reader.uint32()));
                                break;
                            case 11:
                                if (!(message.outputs && message.outputs.length))
                                    message.outputs = [];
                                message.outputs.push($root.TW.NULS.Proto.TransactionOutput.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TransactionPlan message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.NULS.Proto.TransactionPlan} TransactionPlan
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionPlan.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TransactionPlan message.
                     * @function verify
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionPlan.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            if (!$util.isString(message.remark))
                                return "remark: string expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.change != null && message.hasOwnProperty("change"))
                            if (!$util.isInteger(message.change) && !(message.change && $util.isInteger(message.change.low) && $util.isInteger(message.change.high)))
                                return "change: integer|Long expected";
                        if (message.availableAmount != null && message.hasOwnProperty("availableAmount"))
                            if (!$util.isInteger(message.availableAmount) && !(message.availableAmount && $util.isInteger(message.availableAmount.low) && $util.isInteger(message.availableAmount.high)))
                                return "availableAmount: integer|Long expected";
                        if (message.inputs != null && message.hasOwnProperty("inputs")) {
                            if (!Array.isArray(message.inputs))
                                return "inputs: array expected";
                            for (var i = 0; i < message.inputs.length; ++i) {
                                var error = $root.TW.NULS.Proto.TransactionInput.verify(message.inputs[i]);
                                if (error)
                                    return "inputs." + error;
                            }
                        }
                        if (message.outputs != null && message.hasOwnProperty("outputs")) {
                            if (!Array.isArray(message.outputs))
                                return "outputs: array expected";
                            for (var i = 0; i < message.outputs.length; ++i) {
                                var error = $root.TW.NULS.Proto.TransactionOutput.verify(message.outputs[i]);
                                if (error)
                                    return "outputs." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a TransactionPlan message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NULS.Proto.TransactionPlan} TransactionPlan
                     */
                    TransactionPlan.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NULS.Proto.TransactionPlan)
                            return object;
                        var message = new $root.TW.NULS.Proto.TransactionPlan();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.remark != null)
                            message.remark = String(object.remark);
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        if (object.change != null)
                            if ($util.Long)
                                (message.change = $util.Long.fromValue(object.change)).unsigned = false;
                            else if (typeof object.change === "string")
                                message.change = parseInt(object.change, 10);
                            else if (typeof object.change === "number")
                                message.change = object.change;
                            else if (typeof object.change === "object")
                                message.change = new $util.LongBits(object.change.low >>> 0, object.change.high >>> 0).toNumber();
                        if (object.availableAmount != null)
                            if ($util.Long)
                                (message.availableAmount = $util.Long.fromValue(object.availableAmount)).unsigned = false;
                            else if (typeof object.availableAmount === "string")
                                message.availableAmount = parseInt(object.availableAmount, 10);
                            else if (typeof object.availableAmount === "number")
                                message.availableAmount = object.availableAmount;
                            else if (typeof object.availableAmount === "object")
                                message.availableAmount = new $util.LongBits(object.availableAmount.low >>> 0, object.availableAmount.high >>> 0).toNumber();
                        if (object.inputs) {
                            if (!Array.isArray(object.inputs))
                                throw TypeError(".TW.NULS.Proto.TransactionPlan.inputs: array expected");
                            message.inputs = [];
                            for (var i = 0; i < object.inputs.length; ++i) {
                                if (typeof object.inputs[i] !== "object")
                                    throw TypeError(".TW.NULS.Proto.TransactionPlan.inputs: object expected");
                                message.inputs[i] = $root.TW.NULS.Proto.TransactionInput.fromObject(object.inputs[i]);
                            }
                        }
                        if (object.outputs) {
                            if (!Array.isArray(object.outputs))
                                throw TypeError(".TW.NULS.Proto.TransactionPlan.outputs: array expected");
                            message.outputs = [];
                            for (var i = 0; i < object.outputs.length; ++i) {
                                if (typeof object.outputs[i] !== "object")
                                    throw TypeError(".TW.NULS.Proto.TransactionPlan.outputs: object expected");
                                message.outputs[i] = $root.TW.NULS.Proto.TransactionOutput.fromObject(object.outputs[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionPlan message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @static
                     * @param {TW.NULS.Proto.TransactionPlan} message TransactionPlan
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionPlan.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.inputs = [];
                            object.outputs = [];
                        }
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.fromAddress = "";
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.remark = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.change = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.change = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.availableAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.availableAmount = options.longs === String ? "0" : 0;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.remark != null && message.hasOwnProperty("remark"))
                            object.remark = message.remark;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.change != null && message.hasOwnProperty("change"))
                            if (typeof message.change === "number")
                                object.change = options.longs === String ? String(message.change) : message.change;
                            else
                                object.change = options.longs === String ? $util.Long.prototype.toString.call(message.change) : options.longs === Number ? new $util.LongBits(message.change.low >>> 0, message.change.high >>> 0).toNumber() : message.change;
                        if (message.availableAmount != null && message.hasOwnProperty("availableAmount"))
                            if (typeof message.availableAmount === "number")
                                object.availableAmount = options.longs === String ? String(message.availableAmount) : message.availableAmount;
                            else
                                object.availableAmount = options.longs === String ? $util.Long.prototype.toString.call(message.availableAmount) : options.longs === Number ? new $util.LongBits(message.availableAmount.low >>> 0, message.availableAmount.high >>> 0).toNumber() : message.availableAmount;
                        if (message.inputs && message.inputs.length) {
                            object.inputs = [];
                            for (var j = 0; j < message.inputs.length; ++j)
                                object.inputs[j] = $root.TW.NULS.Proto.TransactionInput.toObject(message.inputs[j], options);
                        }
                        if (message.outputs && message.outputs.length) {
                            object.outputs = [];
                            for (var j = 0; j < message.outputs.length; ++j)
                                object.outputs[j] = $root.TW.NULS.Proto.TransactionOutput.toObject(message.outputs[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this TransactionPlan to JSON.
                     * @function toJSON
                     * @memberof TW.NULS.Proto.TransactionPlan
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionPlan.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionPlan;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.NULS.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.NULS.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.NULS.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {TW.NULS.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.NULS.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.NULS.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {TW.NULS.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.NULS.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {TW.NULS.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.NULS.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.NULS.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.NULS.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.NULS.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.NULS.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.NULS.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @static
                     * @param {TW.NULS.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.NULS.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return NULS;
        })();
    
        TW.Nano = (function() {
    
            /**
             * Namespace Nano.
             * @memberof TW
             * @namespace
             */
            var Nano = {};
    
            Nano.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Nano
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Nano.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {Uint8Array|null} [parentBlock] SigningInput parentBlock
                     * @property {Uint8Array|null} [linkBlock] SigningInput linkBlock
                     * @property {string|null} [linkRecipient] SigningInput linkRecipient
                     * @property {string|null} [representative] SigningInput representative
                     * @property {string|null} [balance] SigningInput balance
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Nano.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Nano.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput parentBlock.
                     * @member {Uint8Array} parentBlock
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.parentBlock = $util.newBuffer([]);
    
                    /**
                     * SigningInput linkBlock.
                     * @member {Uint8Array} linkBlock
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.linkBlock = $util.newBuffer([]);
    
                    /**
                     * SigningInput linkRecipient.
                     * @member {string} linkRecipient
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.linkRecipient = "";
    
                    /**
                     * SigningInput representative.
                     * @member {string} representative
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.representative = "";
    
                    /**
                     * SigningInput balance.
                     * @member {string} balance
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.balance = "";
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput linkOneof.
                     * @member {"linkBlock"|"linkRecipient"|undefined} linkOneof
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "linkOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["linkBlock", "linkRecipient"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {TW.Nano.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Nano.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Nano.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {TW.Nano.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
                        if (message.parentBlock != null && message.hasOwnProperty("parentBlock"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.parentBlock);
                        if (message.linkBlock != null && message.hasOwnProperty("linkBlock"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.linkBlock);
                        if (message.linkRecipient != null && message.hasOwnProperty("linkRecipient"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.linkRecipient);
                        if (message.representative != null && message.hasOwnProperty("representative"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.representative);
                        if (message.balance != null && message.hasOwnProperty("balance"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.balance);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Nano.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {TW.Nano.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nano.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nano.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.privateKey = reader.bytes();
                                break;
                            case 2:
                                message.parentBlock = reader.bytes();
                                break;
                            case 3:
                                message.linkBlock = reader.bytes();
                                break;
                            case 4:
                                message.linkRecipient = reader.string();
                                break;
                            case 5:
                                message.representative = reader.string();
                                break;
                            case 6:
                                message.balance = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Nano.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.parentBlock != null && message.hasOwnProperty("parentBlock"))
                            if (!(message.parentBlock && typeof message.parentBlock.length === "number" || $util.isString(message.parentBlock)))
                                return "parentBlock: buffer expected";
                        if (message.linkBlock != null && message.hasOwnProperty("linkBlock")) {
                            properties.linkOneof = 1;
                            if (!(message.linkBlock && typeof message.linkBlock.length === "number" || $util.isString(message.linkBlock)))
                                return "linkBlock: buffer expected";
                        }
                        if (message.linkRecipient != null && message.hasOwnProperty("linkRecipient")) {
                            if (properties.linkOneof === 1)
                                return "linkOneof: multiple values";
                            properties.linkOneof = 1;
                            if (!$util.isString(message.linkRecipient))
                                return "linkRecipient: string expected";
                        }
                        if (message.representative != null && message.hasOwnProperty("representative"))
                            if (!$util.isString(message.representative))
                                return "representative: string expected";
                        if (message.balance != null && message.hasOwnProperty("balance"))
                            if (!$util.isString(message.balance))
                                return "balance: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nano.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nano.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Nano.Proto.SigningInput();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.parentBlock != null)
                            if (typeof object.parentBlock === "string")
                                $util.base64.decode(object.parentBlock, message.parentBlock = $util.newBuffer($util.base64.length(object.parentBlock)), 0);
                            else if (object.parentBlock.length)
                                message.parentBlock = object.parentBlock;
                        if (object.linkBlock != null)
                            if (typeof object.linkBlock === "string")
                                $util.base64.decode(object.linkBlock, message.linkBlock = $util.newBuffer($util.base64.length(object.linkBlock)), 0);
                            else if (object.linkBlock.length)
                                message.linkBlock = object.linkBlock;
                        if (object.linkRecipient != null)
                            message.linkRecipient = String(object.linkRecipient);
                        if (object.representative != null)
                            message.representative = String(object.representative);
                        if (object.balance != null)
                            message.balance = String(object.balance);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nano.Proto.SigningInput
                     * @static
                     * @param {TW.Nano.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            if (options.bytes === String)
                                object.parentBlock = "";
                            else {
                                object.parentBlock = [];
                                if (options.bytes !== Array)
                                    object.parentBlock = $util.newBuffer(object.parentBlock);
                            }
                            object.representative = "";
                            object.balance = "";
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.parentBlock != null && message.hasOwnProperty("parentBlock"))
                            object.parentBlock = options.bytes === String ? $util.base64.encode(message.parentBlock, 0, message.parentBlock.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentBlock) : message.parentBlock;
                        if (message.linkBlock != null && message.hasOwnProperty("linkBlock")) {
                            object.linkBlock = options.bytes === String ? $util.base64.encode(message.linkBlock, 0, message.linkBlock.length) : options.bytes === Array ? Array.prototype.slice.call(message.linkBlock) : message.linkBlock;
                            if (options.oneofs)
                                object.linkOneof = "linkBlock";
                        }
                        if (message.linkRecipient != null && message.hasOwnProperty("linkRecipient")) {
                            object.linkRecipient = message.linkRecipient;
                            if (options.oneofs)
                                object.linkOneof = "linkRecipient";
                        }
                        if (message.representative != null && message.hasOwnProperty("representative"))
                            object.representative = message.representative;
                        if (message.balance != null && message.hasOwnProperty("balance"))
                            object.balance = message.balance;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Nano.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Nano.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     * @property {Uint8Array|null} [blockHash] SigningOutput blockHash
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Nano.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Nano.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * SigningOutput blockHash.
                     * @member {Uint8Array} blockHash
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.blockHash = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {TW.Nano.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Nano.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Nano.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {TW.Nano.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
                        if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.blockHash);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Nano.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {TW.Nano.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nano.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nano.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signature = reader.bytes();
                                break;
                            case 2:
                                message.blockHash = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Nano.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                            if (!(message.blockHash && typeof message.blockHash.length === "number" || $util.isString(message.blockHash)))
                                return "blockHash: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nano.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nano.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Nano.Proto.SigningOutput();
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.blockHash != null)
                            if (typeof object.blockHash === "string")
                                $util.base64.decode(object.blockHash, message.blockHash = $util.newBuffer($util.base64.length(object.blockHash)), 0);
                            else if (object.blockHash.length)
                                message.blockHash = object.blockHash;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @static
                     * @param {TW.Nano.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            if (options.bytes === String)
                                object.blockHash = "";
                            else {
                                object.blockHash = [];
                                if (options.bytes !== Array)
                                    object.blockHash = $util.newBuffer(object.blockHash);
                            }
                        }
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                            object.blockHash = options.bytes === String ? $util.base64.encode(message.blockHash, 0, message.blockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockHash) : message.blockHash;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Nano.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Nano;
        })();
    
        TW.Nebulas = (function() {
    
            /**
             * Namespace Nebulas.
             * @memberof TW
             * @namespace
             */
            var Nebulas = {};
    
            Nebulas.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Nebulas
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Nebulas.Proto
                     * @interface ISigningInput
                     * @property {string|null} [fromAddress] SigningInput fromAddress
                     * @property {Uint8Array|null} [chainId] SigningInput chainId
                     * @property {Uint8Array|null} [nonce] SigningInput nonce
                     * @property {Uint8Array|null} [gasPrice] SigningInput gasPrice
                     * @property {Uint8Array|null} [gasLimit] SigningInput gasLimit
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Uint8Array|null} [amount] SigningInput amount
                     * @property {Uint8Array|null} [timestamp] SigningInput timestamp
                     * @property {string|null} [payload] SigningInput payload
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Nebulas.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Nebulas.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput fromAddress.
                     * @member {string} fromAddress
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fromAddress = "";
    
                    /**
                     * SigningInput chainId.
                     * @member {Uint8Array} chainId
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = $util.newBuffer([]);
    
                    /**
                     * SigningInput nonce.
                     * @member {Uint8Array} nonce
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasPrice.
                     * @member {Uint8Array} gasPrice
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Uint8Array} gasLimit
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.newBuffer([]);
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * SigningInput timestamp.
                     * @member {Uint8Array} timestamp
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timestamp = $util.newBuffer([]);
    
                    /**
                     * SigningInput payload.
                     * @member {string} payload
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.payload = "";
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {TW.Nebulas.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Nebulas.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Nebulas.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {TW.Nebulas.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.fromAddress);
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.chainId);
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nonce);
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.gasPrice);
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.gasLimit);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.toAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.amount);
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.timestamp);
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            writer.uint32(/* id 9, wireType 2 =*/74).string(message.payload);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Nebulas.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {TW.Nebulas.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nebulas.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nebulas.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fromAddress = reader.string();
                                break;
                            case 2:
                                message.chainId = reader.bytes();
                                break;
                            case 3:
                                message.nonce = reader.bytes();
                                break;
                            case 4:
                                message.gasPrice = reader.bytes();
                                break;
                            case 5:
                                message.gasLimit = reader.bytes();
                                break;
                            case 6:
                                message.toAddress = reader.string();
                                break;
                            case 7:
                                message.amount = reader.bytes();
                                break;
                            case 8:
                                message.timestamp = reader.bytes();
                                break;
                            case 9:
                                message.payload = reader.string();
                                break;
                            case 10:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Nebulas.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            if (!$util.isString(message.fromAddress))
                                return "fromAddress: string expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!(message.chainId && typeof message.chainId.length === "number" || $util.isString(message.chainId)))
                                return "chainId: buffer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!(message.gasPrice && typeof message.gasPrice.length === "number" || $util.isString(message.gasPrice)))
                                return "gasPrice: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!(message.gasLimit && typeof message.gasLimit.length === "number" || $util.isString(message.gasLimit)))
                                return "gasLimit: buffer expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!(message.timestamp && typeof message.timestamp.length === "number" || $util.isString(message.timestamp)))
                                return "timestamp: buffer expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!$util.isString(message.payload))
                                return "payload: string expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nebulas.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nebulas.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Nebulas.Proto.SigningInput();
                        if (object.fromAddress != null)
                            message.fromAddress = String(object.fromAddress);
                        if (object.chainId != null)
                            if (typeof object.chainId === "string")
                                $util.base64.decode(object.chainId, message.chainId = $util.newBuffer($util.base64.length(object.chainId)), 0);
                            else if (object.chainId.length)
                                message.chainId = object.chainId;
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        if (object.gasPrice != null)
                            if (typeof object.gasPrice === "string")
                                $util.base64.decode(object.gasPrice, message.gasPrice = $util.newBuffer($util.base64.length(object.gasPrice)), 0);
                            else if (object.gasPrice.length)
                                message.gasPrice = object.gasPrice;
                        if (object.gasLimit != null)
                            if (typeof object.gasLimit === "string")
                                $util.base64.decode(object.gasLimit, message.gasLimit = $util.newBuffer($util.base64.length(object.gasLimit)), 0);
                            else if (object.gasLimit.length)
                                message.gasLimit = object.gasLimit;
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        if (object.timestamp != null)
                            if (typeof object.timestamp === "string")
                                $util.base64.decode(object.timestamp, message.timestamp = $util.newBuffer($util.base64.length(object.timestamp)), 0);
                            else if (object.timestamp.length)
                                message.timestamp = object.timestamp;
                        if (object.payload != null)
                            message.payload = String(object.payload);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @static
                     * @param {TW.Nebulas.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fromAddress = "";
                            if (options.bytes === String)
                                object.chainId = "";
                            else {
                                object.chainId = [];
                                if (options.bytes !== Array)
                                    object.chainId = $util.newBuffer(object.chainId);
                            }
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            if (options.bytes === String)
                                object.gasPrice = "";
                            else {
                                object.gasPrice = [];
                                if (options.bytes !== Array)
                                    object.gasPrice = $util.newBuffer(object.gasPrice);
                            }
                            if (options.bytes === String)
                                object.gasLimit = "";
                            else {
                                object.gasLimit = [];
                                if (options.bytes !== Array)
                                    object.gasLimit = $util.newBuffer(object.gasLimit);
                            }
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                            if (options.bytes === String)
                                object.timestamp = "";
                            else {
                                object.timestamp = [];
                                if (options.bytes !== Array)
                                    object.timestamp = $util.newBuffer(object.timestamp);
                            }
                            object.payload = "";
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.fromAddress != null && message.hasOwnProperty("fromAddress"))
                            object.fromAddress = message.fromAddress;
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = options.bytes === String ? $util.base64.encode(message.chainId, 0, message.chainId.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainId) : message.chainId;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = options.bytes === String ? $util.base64.encode(message.gasPrice, 0, message.gasPrice.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPrice) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            object.gasLimit = options.bytes === String ? $util.base64.encode(message.gasLimit, 0, message.gasLimit.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasLimit) : message.gasLimit;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            object.timestamp = options.bytes === String ? $util.base64.encode(message.timestamp, 0, message.timestamp.length) : options.bytes === Array ? Array.prototype.slice.call(message.timestamp) : message.timestamp;
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = message.payload;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Nebulas.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Nebulas.Proto
                     * @interface ISigningOutput
                     * @property {number|null} [algorithm] SigningOutput algorithm
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     * @property {string|null} [raw] SigningOutput raw
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Nebulas.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Nebulas.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput algorithm.
                     * @member {number} algorithm
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.algorithm = 0;
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * SigningOutput raw.
                     * @member {string} raw
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.raw = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {TW.Nebulas.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Nebulas.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Nebulas.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {TW.Nebulas.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.algorithm);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        if (message.raw != null && message.hasOwnProperty("raw"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.raw);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Nebulas.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {TW.Nebulas.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nebulas.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nebulas.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.algorithm = reader.uint32();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            case 3:
                                message.raw = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Nebulas.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                            if (!$util.isInteger(message.algorithm))
                                return "algorithm: integer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.raw != null && message.hasOwnProperty("raw"))
                            if (!$util.isString(message.raw))
                                return "raw: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nebulas.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nebulas.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Nebulas.Proto.SigningOutput();
                        if (object.algorithm != null)
                            message.algorithm = object.algorithm >>> 0;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.raw != null)
                            message.raw = String(object.raw);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @static
                     * @param {TW.Nebulas.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.algorithm = 0;
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            object.raw = "";
                        }
                        if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                            object.algorithm = message.algorithm;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.raw != null && message.hasOwnProperty("raw"))
                            object.raw = message.raw;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Nebulas.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                Proto.Data = (function() {
    
                    /**
                     * Properties of a Data.
                     * @memberof TW.Nebulas.Proto
                     * @interface IData
                     * @property {string|null} [type] Data type
                     * @property {Uint8Array|null} [payload] Data payload
                     */
    
                    /**
                     * Constructs a new Data.
                     * @memberof TW.Nebulas.Proto
                     * @classdesc Represents a Data.
                     * @implements IData
                     * @constructor
                     * @param {TW.Nebulas.Proto.IData=} [properties] Properties to set
                     */
                    function Data(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Data type.
                     * @member {string} type
                     * @memberof TW.Nebulas.Proto.Data
                     * @instance
                     */
                    Data.prototype.type = "";
    
                    /**
                     * Data payload.
                     * @member {Uint8Array} payload
                     * @memberof TW.Nebulas.Proto.Data
                     * @instance
                     */
                    Data.prototype.payload = $util.newBuffer([]);
    
                    /**
                     * Creates a new Data instance using the specified properties.
                     * @function create
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {TW.Nebulas.Proto.IData=} [properties] Properties to set
                     * @returns {TW.Nebulas.Proto.Data} Data instance
                     */
                    Data.create = function create(properties) {
                        return new Data(properties);
                    };
    
                    /**
                     * Encodes the specified Data message. Does not implicitly {@link TW.Nebulas.Proto.Data.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {TW.Nebulas.Proto.IData} message Data message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Data.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && message.hasOwnProperty("type"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Data message, length delimited. Does not implicitly {@link TW.Nebulas.Proto.Data.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {TW.Nebulas.Proto.IData} message Data message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Data.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Data message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nebulas.Proto.Data} Data
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Data.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nebulas.Proto.Data();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.type = reader.string();
                                break;
                            case 2:
                                message.payload = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Data message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Nebulas.Proto.Data} Data
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Data.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Data message.
                     * @function verify
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Data.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                                return "payload: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Data message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nebulas.Proto.Data} Data
                     */
                    Data.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nebulas.Proto.Data)
                            return object;
                        var message = new $root.TW.Nebulas.Proto.Data();
                        if (object.type != null)
                            message.type = String(object.type);
                        if (object.payload != null)
                            if (typeof object.payload === "string")
                                $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                            else if (object.payload.length)
                                message.payload = object.payload;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Data message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nebulas.Proto.Data
                     * @static
                     * @param {TW.Nebulas.Proto.Data} message Data
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Data.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.type = "";
                            if (options.bytes === String)
                                object.payload = "";
                            else {
                                object.payload = [];
                                if (options.bytes !== Array)
                                    object.payload = $util.newBuffer(object.payload);
                            }
                        }
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        if (message.payload != null && message.hasOwnProperty("payload"))
                            object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                        return object;
                    };
    
                    /**
                     * Converts this Data to JSON.
                     * @function toJSON
                     * @memberof TW.Nebulas.Proto.Data
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Data.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Data;
                })();
    
                Proto.RawTransaction = (function() {
    
                    /**
                     * Properties of a RawTransaction.
                     * @memberof TW.Nebulas.Proto
                     * @interface IRawTransaction
                     * @property {Uint8Array|null} [hash] RawTransaction hash
                     * @property {Uint8Array|null} [from] RawTransaction from
                     * @property {Uint8Array|null} [to] RawTransaction to
                     * @property {Uint8Array|null} [value] RawTransaction value
                     * @property {Long|null} [nonce] RawTransaction nonce
                     * @property {Long|null} [timestamp] RawTransaction timestamp
                     * @property {TW.Nebulas.Proto.IData|null} [data] RawTransaction data
                     * @property {number|null} [chainId] RawTransaction chainId
                     * @property {Uint8Array|null} [gasPrice] RawTransaction gasPrice
                     * @property {Uint8Array|null} [gasLimit] RawTransaction gasLimit
                     * @property {number|null} [alg] RawTransaction alg
                     * @property {Uint8Array|null} [sign] RawTransaction sign
                     */
    
                    /**
                     * Constructs a new RawTransaction.
                     * @memberof TW.Nebulas.Proto
                     * @classdesc Represents a RawTransaction.
                     * @implements IRawTransaction
                     * @constructor
                     * @param {TW.Nebulas.Proto.IRawTransaction=} [properties] Properties to set
                     */
                    function RawTransaction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * RawTransaction hash.
                     * @member {Uint8Array} hash
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.hash = $util.newBuffer([]);
    
                    /**
                     * RawTransaction from.
                     * @member {Uint8Array} from
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.from = $util.newBuffer([]);
    
                    /**
                     * RawTransaction to.
                     * @member {Uint8Array} to
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.to = $util.newBuffer([]);
    
                    /**
                     * RawTransaction value.
                     * @member {Uint8Array} value
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.value = $util.newBuffer([]);
    
                    /**
                     * RawTransaction nonce.
                     * @member {Long} nonce
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * RawTransaction timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * RawTransaction data.
                     * @member {TW.Nebulas.Proto.IData|null|undefined} data
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.data = null;
    
                    /**
                     * RawTransaction chainId.
                     * @member {number} chainId
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.chainId = 0;
    
                    /**
                     * RawTransaction gasPrice.
                     * @member {Uint8Array} gasPrice
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.gasPrice = $util.newBuffer([]);
    
                    /**
                     * RawTransaction gasLimit.
                     * @member {Uint8Array} gasLimit
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.gasLimit = $util.newBuffer([]);
    
                    /**
                     * RawTransaction alg.
                     * @member {number} alg
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.alg = 0;
    
                    /**
                     * RawTransaction sign.
                     * @member {Uint8Array} sign
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     */
                    RawTransaction.prototype.sign = $util.newBuffer([]);
    
                    /**
                     * Creates a new RawTransaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {TW.Nebulas.Proto.IRawTransaction=} [properties] Properties to set
                     * @returns {TW.Nebulas.Proto.RawTransaction} RawTransaction instance
                     */
                    RawTransaction.create = function create(properties) {
                        return new RawTransaction(properties);
                    };
    
                    /**
                     * Encodes the specified RawTransaction message. Does not implicitly {@link TW.Nebulas.Proto.RawTransaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {TW.Nebulas.Proto.IRawTransaction} message RawTransaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RawTransaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                        if (message.from != null && message.hasOwnProperty("from"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.from);
                        if (message.to != null && message.hasOwnProperty("to"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.to);
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.value);
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.nonce);
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timestamp);
                        if (message.data != null && message.hasOwnProperty("data"))
                            $root.TW.Nebulas.Proto.Data.encode(message.data, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.chainId);
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.gasPrice);
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.gasLimit);
                        if (message.alg != null && message.hasOwnProperty("alg"))
                            writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.alg);
                        if (message.sign != null && message.hasOwnProperty("sign"))
                            writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.sign);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified RawTransaction message, length delimited. Does not implicitly {@link TW.Nebulas.Proto.RawTransaction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {TW.Nebulas.Proto.IRawTransaction} message RawTransaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RawTransaction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a RawTransaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nebulas.Proto.RawTransaction} RawTransaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RawTransaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nebulas.Proto.RawTransaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.hash = reader.bytes();
                                break;
                            case 2:
                                message.from = reader.bytes();
                                break;
                            case 3:
                                message.to = reader.bytes();
                                break;
                            case 4:
                                message.value = reader.bytes();
                                break;
                            case 5:
                                message.nonce = reader.uint64();
                                break;
                            case 6:
                                message.timestamp = reader.int64();
                                break;
                            case 7:
                                message.data = $root.TW.Nebulas.Proto.Data.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.chainId = reader.uint32();
                                break;
                            case 9:
                                message.gasPrice = reader.bytes();
                                break;
                            case 10:
                                message.gasLimit = reader.bytes();
                                break;
                            case 11:
                                message.alg = reader.uint32();
                                break;
                            case 12:
                                message.sign = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a RawTransaction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Nebulas.Proto.RawTransaction} RawTransaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RawTransaction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a RawTransaction message.
                     * @function verify
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RawTransaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                                return "hash: buffer expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!(message.to && typeof message.to.length === "number" || $util.isString(message.to)))
                                return "to: buffer expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                return "value: buffer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.data != null && message.hasOwnProperty("data")) {
                            var error = $root.TW.Nebulas.Proto.Data.verify(message.data);
                            if (error)
                                return "data." + error;
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isInteger(message.chainId))
                                return "chainId: integer expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!(message.gasPrice && typeof message.gasPrice.length === "number" || $util.isString(message.gasPrice)))
                                return "gasPrice: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!(message.gasLimit && typeof message.gasLimit.length === "number" || $util.isString(message.gasLimit)))
                                return "gasLimit: buffer expected";
                        if (message.alg != null && message.hasOwnProperty("alg"))
                            if (!$util.isInteger(message.alg))
                                return "alg: integer expected";
                        if (message.sign != null && message.hasOwnProperty("sign"))
                            if (!(message.sign && typeof message.sign.length === "number" || $util.isString(message.sign)))
                                return "sign: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a RawTransaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nebulas.Proto.RawTransaction} RawTransaction
                     */
                    RawTransaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nebulas.Proto.RawTransaction)
                            return object;
                        var message = new $root.TW.Nebulas.Proto.RawTransaction();
                        if (object.hash != null)
                            if (typeof object.hash === "string")
                                $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                            else if (object.hash.length)
                                message.hash = object.hash;
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.to != null)
                            if (typeof object.to === "string")
                                $util.base64.decode(object.to, message.to = $util.newBuffer($util.base64.length(object.to)), 0);
                            else if (object.to.length)
                                message.to = object.to;
                        if (object.value != null)
                            if (typeof object.value === "string")
                                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                            else if (object.value.length)
                                message.value = object.value;
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.data != null) {
                            if (typeof object.data !== "object")
                                throw TypeError(".TW.Nebulas.Proto.RawTransaction.data: object expected");
                            message.data = $root.TW.Nebulas.Proto.Data.fromObject(object.data);
                        }
                        if (object.chainId != null)
                            message.chainId = object.chainId >>> 0;
                        if (object.gasPrice != null)
                            if (typeof object.gasPrice === "string")
                                $util.base64.decode(object.gasPrice, message.gasPrice = $util.newBuffer($util.base64.length(object.gasPrice)), 0);
                            else if (object.gasPrice.length)
                                message.gasPrice = object.gasPrice;
                        if (object.gasLimit != null)
                            if (typeof object.gasLimit === "string")
                                $util.base64.decode(object.gasLimit, message.gasLimit = $util.newBuffer($util.base64.length(object.gasLimit)), 0);
                            else if (object.gasLimit.length)
                                message.gasLimit = object.gasLimit;
                        if (object.alg != null)
                            message.alg = object.alg >>> 0;
                        if (object.sign != null)
                            if (typeof object.sign === "string")
                                $util.base64.decode(object.sign, message.sign = $util.newBuffer($util.base64.length(object.sign)), 0);
                            else if (object.sign.length)
                                message.sign = object.sign;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a RawTransaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @static
                     * @param {TW.Nebulas.Proto.RawTransaction} message RawTransaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RawTransaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.hash = "";
                            else {
                                object.hash = [];
                                if (options.bytes !== Array)
                                    object.hash = $util.newBuffer(object.hash);
                            }
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            if (options.bytes === String)
                                object.to = "";
                            else {
                                object.to = [];
                                if (options.bytes !== Array)
                                    object.to = $util.newBuffer(object.to);
                            }
                            if (options.bytes === String)
                                object.value = "";
                            else {
                                object.value = [];
                                if (options.bytes !== Array)
                                    object.value = $util.newBuffer(object.value);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            object.data = null;
                            object.chainId = 0;
                            if (options.bytes === String)
                                object.gasPrice = "";
                            else {
                                object.gasPrice = [];
                                if (options.bytes !== Array)
                                    object.gasPrice = $util.newBuffer(object.gasPrice);
                            }
                            if (options.bytes === String)
                                object.gasLimit = "";
                            else {
                                object.gasLimit = [];
                                if (options.bytes !== Array)
                                    object.gasLimit = $util.newBuffer(object.gasLimit);
                            }
                            object.alg = 0;
                            if (options.bytes === String)
                                object.sign = "";
                            else {
                                object.sign = [];
                                if (options.bytes !== Array)
                                    object.sign = $util.newBuffer(object.sign);
                            }
                        }
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = options.bytes === String ? $util.base64.encode(message.to, 0, message.to.length) : options.bytes === Array ? Array.prototype.slice.call(message.to) : message.to;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = $root.TW.Nebulas.Proto.Data.toObject(message.data, options);
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = options.bytes === String ? $util.base64.encode(message.gasPrice, 0, message.gasPrice.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPrice) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            object.gasLimit = options.bytes === String ? $util.base64.encode(message.gasLimit, 0, message.gasLimit.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasLimit) : message.gasLimit;
                        if (message.alg != null && message.hasOwnProperty("alg"))
                            object.alg = message.alg;
                        if (message.sign != null && message.hasOwnProperty("sign"))
                            object.sign = options.bytes === String ? $util.base64.encode(message.sign, 0, message.sign.length) : options.bytes === Array ? Array.prototype.slice.call(message.sign) : message.sign;
                        return object;
                    };
    
                    /**
                     * Converts this RawTransaction to JSON.
                     * @function toJSON
                     * @memberof TW.Nebulas.Proto.RawTransaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RawTransaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return RawTransaction;
                })();
    
                return Proto;
            })();
    
            return Nebulas;
        })();
    
        TW.Nimiq = (function() {
    
            /**
             * Namespace Nimiq.
             * @memberof TW
             * @namespace
             */
            var Nimiq = {};
    
            Nimiq.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Nimiq
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Nimiq.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {string|null} [destination] SigningInput destination
                     * @property {Long|null} [value] SigningInput value
                     * @property {Long|null} [fee] SigningInput fee
                     * @property {number|null} [validityStartHeight] SigningInput validityStartHeight
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Nimiq.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Nimiq.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput destination.
                     * @member {string} destination
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.destination = "";
    
                    /**
                     * SigningInput value.
                     * @member {Long} value
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput fee.
                     * @member {Long} fee
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput validityStartHeight.
                     * @member {number} validityStartHeight
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.validityStartHeight = 0;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {TW.Nimiq.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Nimiq.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Nimiq.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {TW.Nimiq.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.destination);
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.value);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fee);
                        if (message.validityStartHeight != null && message.hasOwnProperty("validityStartHeight"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.validityStartHeight);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Nimiq.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {TW.Nimiq.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nimiq.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nimiq.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.privateKey = reader.bytes();
                                break;
                            case 2:
                                message.destination = reader.string();
                                break;
                            case 3:
                                message.value = reader.uint64();
                                break;
                            case 4:
                                message.fee = reader.uint64();
                                break;
                            case 5:
                                message.validityStartHeight = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Nimiq.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            if (!$util.isString(message.destination))
                                return "destination: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.validityStartHeight != null && message.hasOwnProperty("validityStartHeight"))
                            if (!$util.isInteger(message.validityStartHeight))
                                return "validityStartHeight: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nimiq.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nimiq.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Nimiq.Proto.SigningInput();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.destination != null)
                            message.destination = String(object.destination);
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                        if (object.validityStartHeight != null)
                            message.validityStartHeight = object.validityStartHeight >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @static
                     * @param {TW.Nimiq.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.destination = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            object.validityStartHeight = 0;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            object.destination = message.destination;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                        if (message.validityStartHeight != null && message.hasOwnProperty("validityStartHeight"))
                            object.validityStartHeight = message.validityStartHeight;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Nimiq.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Nimiq.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Nimiq.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Nimiq.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {TW.Nimiq.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Nimiq.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Nimiq.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {TW.Nimiq.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Nimiq.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {TW.Nimiq.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Nimiq.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Nimiq.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Nimiq.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Nimiq.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Nimiq.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Nimiq.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @static
                     * @param {TW.Nimiq.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Nimiq.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Nimiq;
        })();
    
        TW.Ontology = (function() {
    
            /**
             * Namespace Ontology.
             * @memberof TW
             * @namespace
             */
            var Ontology = {};
    
            Ontology.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Ontology
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Ontology.Proto
                     * @interface ISigningInput
                     * @property {string|null} [contract] SigningInput contract
                     * @property {string|null} [method] SigningInput method
                     * @property {Uint8Array|null} [ownerPrivateKey] SigningInput ownerPrivateKey
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Long|null} [amount] SigningInput amount
                     * @property {Uint8Array|null} [payerPrivateKey] SigningInput payerPrivateKey
                     * @property {Long|null} [gasPrice] SigningInput gasPrice
                     * @property {Long|null} [gasLimit] SigningInput gasLimit
                     * @property {string|null} [queryAddress] SigningInput queryAddress
                     * @property {number|null} [nonce] SigningInput nonce
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Ontology.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Ontology.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput contract.
                     * @member {string} contract
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.contract = "";
    
                    /**
                     * SigningInput method.
                     * @member {string} method
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.method = "";
    
                    /**
                     * SigningInput ownerPrivateKey.
                     * @member {Uint8Array} ownerPrivateKey
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.ownerPrivateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput amount.
                     * @member {Long} amount
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput payerPrivateKey.
                     * @member {Uint8Array} payerPrivateKey
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.payerPrivateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasPrice.
                     * @member {Long} gasPrice
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Long} gasLimit
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput queryAddress.
                     * @member {string} queryAddress
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.queryAddress = "";
    
                    /**
                     * SigningInput nonce.
                     * @member {number} nonce
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = 0;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {TW.Ontology.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Ontology.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Ontology.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {TW.Ontology.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contract);
                        if (message.method != null && message.hasOwnProperty("method"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.method);
                        if (message.ownerPrivateKey != null && message.hasOwnProperty("ownerPrivateKey"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ownerPrivateKey);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.toAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.amount);
                        if (message.payerPrivateKey != null && message.hasOwnProperty("payerPrivateKey"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payerPrivateKey);
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.gasPrice);
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.gasLimit);
                        if (message.queryAddress != null && message.hasOwnProperty("queryAddress"))
                            writer.uint32(/* id 9, wireType 2 =*/74).string(message.queryAddress);
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.nonce);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Ontology.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {TW.Ontology.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ontology.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ontology.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contract = reader.string();
                                break;
                            case 2:
                                message.method = reader.string();
                                break;
                            case 3:
                                message.ownerPrivateKey = reader.bytes();
                                break;
                            case 4:
                                message.toAddress = reader.string();
                                break;
                            case 5:
                                message.amount = reader.uint64();
                                break;
                            case 6:
                                message.payerPrivateKey = reader.bytes();
                                break;
                            case 7:
                                message.gasPrice = reader.uint64();
                                break;
                            case 8:
                                message.gasLimit = reader.uint64();
                                break;
                            case 9:
                                message.queryAddress = reader.string();
                                break;
                            case 10:
                                message.nonce = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Ontology.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            if (!$util.isString(message.contract))
                                return "contract: string expected";
                        if (message.method != null && message.hasOwnProperty("method"))
                            if (!$util.isString(message.method))
                                return "method: string expected";
                        if (message.ownerPrivateKey != null && message.hasOwnProperty("ownerPrivateKey"))
                            if (!(message.ownerPrivateKey && typeof message.ownerPrivateKey.length === "number" || $util.isString(message.ownerPrivateKey)))
                                return "ownerPrivateKey: buffer expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.payerPrivateKey != null && message.hasOwnProperty("payerPrivateKey"))
                            if (!(message.payerPrivateKey && typeof message.payerPrivateKey.length === "number" || $util.isString(message.payerPrivateKey)))
                                return "payerPrivateKey: buffer expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!$util.isInteger(message.gasPrice) && !(message.gasPrice && $util.isInteger(message.gasPrice.low) && $util.isInteger(message.gasPrice.high)))
                                return "gasPrice: integer|Long expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!$util.isInteger(message.gasLimit) && !(message.gasLimit && $util.isInteger(message.gasLimit.low) && $util.isInteger(message.gasLimit.high)))
                                return "gasLimit: integer|Long expected";
                        if (message.queryAddress != null && message.hasOwnProperty("queryAddress"))
                            if (!$util.isString(message.queryAddress))
                                return "queryAddress: string expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce))
                                return "nonce: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ontology.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ontology.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Ontology.Proto.SigningInput();
                        if (object.contract != null)
                            message.contract = String(object.contract);
                        if (object.method != null)
                            message.method = String(object.method);
                        if (object.ownerPrivateKey != null)
                            if (typeof object.ownerPrivateKey === "string")
                                $util.base64.decode(object.ownerPrivateKey, message.ownerPrivateKey = $util.newBuffer($util.base64.length(object.ownerPrivateKey)), 0);
                            else if (object.ownerPrivateKey.length)
                                message.ownerPrivateKey = object.ownerPrivateKey;
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                        if (object.payerPrivateKey != null)
                            if (typeof object.payerPrivateKey === "string")
                                $util.base64.decode(object.payerPrivateKey, message.payerPrivateKey = $util.newBuffer($util.base64.length(object.payerPrivateKey)), 0);
                            else if (object.payerPrivateKey.length)
                                message.payerPrivateKey = object.payerPrivateKey;
                        if (object.gasPrice != null)
                            if ($util.Long)
                                (message.gasPrice = $util.Long.fromValue(object.gasPrice)).unsigned = true;
                            else if (typeof object.gasPrice === "string")
                                message.gasPrice = parseInt(object.gasPrice, 10);
                            else if (typeof object.gasPrice === "number")
                                message.gasPrice = object.gasPrice;
                            else if (typeof object.gasPrice === "object")
                                message.gasPrice = new $util.LongBits(object.gasPrice.low >>> 0, object.gasPrice.high >>> 0).toNumber(true);
                        if (object.gasLimit != null)
                            if ($util.Long)
                                (message.gasLimit = $util.Long.fromValue(object.gasLimit)).unsigned = true;
                            else if (typeof object.gasLimit === "string")
                                message.gasLimit = parseInt(object.gasLimit, 10);
                            else if (typeof object.gasLimit === "number")
                                message.gasLimit = object.gasLimit;
                            else if (typeof object.gasLimit === "object")
                                message.gasLimit = new $util.LongBits(object.gasLimit.low >>> 0, object.gasLimit.high >>> 0).toNumber(true);
                        if (object.queryAddress != null)
                            message.queryAddress = String(object.queryAddress);
                        if (object.nonce != null)
                            message.nonce = object.nonce >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @static
                     * @param {TW.Ontology.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contract = "";
                            object.method = "";
                            if (options.bytes === String)
                                object.ownerPrivateKey = "";
                            else {
                                object.ownerPrivateKey = [];
                                if (options.bytes !== Array)
                                    object.ownerPrivateKey = $util.newBuffer(object.ownerPrivateKey);
                            }
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.payerPrivateKey = "";
                            else {
                                object.payerPrivateKey = [];
                                if (options.bytes !== Array)
                                    object.payerPrivateKey = $util.newBuffer(object.payerPrivateKey);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasPrice = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasPrice = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasLimit = options.longs === String ? "0" : 0;
                            object.queryAddress = "";
                            object.nonce = 0;
                        }
                        if (message.contract != null && message.hasOwnProperty("contract"))
                            object.contract = message.contract;
                        if (message.method != null && message.hasOwnProperty("method"))
                            object.method = message.method;
                        if (message.ownerPrivateKey != null && message.hasOwnProperty("ownerPrivateKey"))
                            object.ownerPrivateKey = options.bytes === String ? $util.base64.encode(message.ownerPrivateKey, 0, message.ownerPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerPrivateKey) : message.ownerPrivateKey;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                        if (message.payerPrivateKey != null && message.hasOwnProperty("payerPrivateKey"))
                            object.payerPrivateKey = options.bytes === String ? $util.base64.encode(message.payerPrivateKey, 0, message.payerPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.payerPrivateKey) : message.payerPrivateKey;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (typeof message.gasPrice === "number")
                                object.gasPrice = options.longs === String ? String(message.gasPrice) : message.gasPrice;
                            else
                                object.gasPrice = options.longs === String ? $util.Long.prototype.toString.call(message.gasPrice) : options.longs === Number ? new $util.LongBits(message.gasPrice.low >>> 0, message.gasPrice.high >>> 0).toNumber(true) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit === "number")
                                object.gasLimit = options.longs === String ? String(message.gasLimit) : message.gasLimit;
                            else
                                object.gasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.gasLimit) : options.longs === Number ? new $util.LongBits(message.gasLimit.low >>> 0, message.gasLimit.high >>> 0).toNumber(true) : message.gasLimit;
                        if (message.queryAddress != null && message.hasOwnProperty("queryAddress"))
                            object.queryAddress = message.queryAddress;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = message.nonce;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Ontology.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Ontology.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Ontology.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Ontology.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {TW.Ontology.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Ontology.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Ontology.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {TW.Ontology.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Ontology.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {TW.Ontology.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ontology.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ontology.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Ontology.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ontology.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ontology.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Ontology.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @static
                     * @param {TW.Ontology.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Ontology.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Ontology;
        })();
    
        TW.Ripple = (function() {
    
            /**
             * Namespace Ripple.
             * @memberof TW
             * @namespace
             */
            var Ripple = {};
    
            Ripple.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Ripple
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Ripple.Proto
                     * @interface ISigningInput
                     * @property {Long|null} [amount] SigningInput amount
                     * @property {Long|null} [fee] SigningInput fee
                     * @property {number|null} [sequence] SigningInput sequence
                     * @property {number|null} [lastLedgerSequence] SigningInput lastLedgerSequence
                     * @property {string|null} [account] SigningInput account
                     * @property {string|null} [destination] SigningInput destination
                     * @property {Long|null} [destinationTag] SigningInput destinationTag
                     * @property {Long|null} [flags] SigningInput flags
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Ripple.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Ripple.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput amount.
                     * @member {Long} amount
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput fee.
                     * @member {Long} fee
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput sequence.
                     * @member {number} sequence
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sequence = 0;
    
                    /**
                     * SigningInput lastLedgerSequence.
                     * @member {number} lastLedgerSequence
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.lastLedgerSequence = 0;
    
                    /**
                     * SigningInput account.
                     * @member {string} account
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.account = "";
    
                    /**
                     * SigningInput destination.
                     * @member {string} destination
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.destination = "";
    
                    /**
                     * SigningInput destinationTag.
                     * @member {Long} destinationTag
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.destinationTag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput flags.
                     * @member {Long} flags
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.flags = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {TW.Ripple.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Ripple.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Ripple.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {TW.Ripple.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.amount);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.fee);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sequence);
                        if (message.lastLedgerSequence != null && message.hasOwnProperty("lastLedgerSequence"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lastLedgerSequence);
                        if (message.account != null && message.hasOwnProperty("account"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.account);
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.destination);
                        if (message.destinationTag != null && message.hasOwnProperty("destinationTag"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.destinationTag);
                        if (message.flags != null && message.hasOwnProperty("flags"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int64(message.flags);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Ripple.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {TW.Ripple.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ripple.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ripple.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.int64();
                                break;
                            case 2:
                                message.fee = reader.int64();
                                break;
                            case 3:
                                message.sequence = reader.int32();
                                break;
                            case 4:
                                message.lastLedgerSequence = reader.int32();
                                break;
                            case 5:
                                message.account = reader.string();
                                break;
                            case 6:
                                message.destination = reader.string();
                                break;
                            case 7:
                                message.destinationTag = reader.int64();
                                break;
                            case 8:
                                message.flags = reader.int64();
                                break;
                            case 9:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Ripple.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence))
                                return "sequence: integer expected";
                        if (message.lastLedgerSequence != null && message.hasOwnProperty("lastLedgerSequence"))
                            if (!$util.isInteger(message.lastLedgerSequence))
                                return "lastLedgerSequence: integer expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            if (!$util.isString(message.destination))
                                return "destination: string expected";
                        if (message.destinationTag != null && message.hasOwnProperty("destinationTag"))
                            if (!$util.isInteger(message.destinationTag) && !(message.destinationTag && $util.isInteger(message.destinationTag.low) && $util.isInteger(message.destinationTag.high)))
                                return "destinationTag: integer|Long expected";
                        if (message.flags != null && message.hasOwnProperty("flags"))
                            if (!$util.isInteger(message.flags) && !(message.flags && $util.isInteger(message.flags.low) && $util.isInteger(message.flags.high)))
                                return "flags: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ripple.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ripple.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Ripple.Proto.SigningInput();
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        if (object.sequence != null)
                            message.sequence = object.sequence | 0;
                        if (object.lastLedgerSequence != null)
                            message.lastLedgerSequence = object.lastLedgerSequence | 0;
                        if (object.account != null)
                            message.account = String(object.account);
                        if (object.destination != null)
                            message.destination = String(object.destination);
                        if (object.destinationTag != null)
                            if ($util.Long)
                                (message.destinationTag = $util.Long.fromValue(object.destinationTag)).unsigned = false;
                            else if (typeof object.destinationTag === "string")
                                message.destinationTag = parseInt(object.destinationTag, 10);
                            else if (typeof object.destinationTag === "number")
                                message.destinationTag = object.destinationTag;
                            else if (typeof object.destinationTag === "object")
                                message.destinationTag = new $util.LongBits(object.destinationTag.low >>> 0, object.destinationTag.high >>> 0).toNumber();
                        if (object.flags != null)
                            if ($util.Long)
                                (message.flags = $util.Long.fromValue(object.flags)).unsigned = false;
                            else if (typeof object.flags === "string")
                                message.flags = parseInt(object.flags, 10);
                            else if (typeof object.flags === "number")
                                message.flags = object.flags;
                            else if (typeof object.flags === "object")
                                message.flags = new $util.LongBits(object.flags.low >>> 0, object.flags.high >>> 0).toNumber();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @static
                     * @param {TW.Ripple.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            object.sequence = 0;
                            object.lastLedgerSequence = 0;
                            object.account = "";
                            object.destination = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.destinationTag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.destinationTag = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.flags = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.flags = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            object.sequence = message.sequence;
                        if (message.lastLedgerSequence != null && message.hasOwnProperty("lastLedgerSequence"))
                            object.lastLedgerSequence = message.lastLedgerSequence;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            object.destination = message.destination;
                        if (message.destinationTag != null && message.hasOwnProperty("destinationTag"))
                            if (typeof message.destinationTag === "number")
                                object.destinationTag = options.longs === String ? String(message.destinationTag) : message.destinationTag;
                            else
                                object.destinationTag = options.longs === String ? $util.Long.prototype.toString.call(message.destinationTag) : options.longs === Number ? new $util.LongBits(message.destinationTag.low >>> 0, message.destinationTag.high >>> 0).toNumber() : message.destinationTag;
                        if (message.flags != null && message.hasOwnProperty("flags"))
                            if (typeof message.flags === "number")
                                object.flags = options.longs === String ? String(message.flags) : message.flags;
                            else
                                object.flags = options.longs === String ? $util.Long.prototype.toString.call(message.flags) : options.longs === Number ? new $util.LongBits(message.flags.low >>> 0, message.flags.high >>> 0).toNumber() : message.flags;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Ripple.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Ripple.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Ripple.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Ripple.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {TW.Ripple.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Ripple.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Ripple.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {TW.Ripple.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Ripple.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {TW.Ripple.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Ripple.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Ripple.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Ripple.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Ripple.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Ripple.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Ripple.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @static
                     * @param {TW.Ripple.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Ripple.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Ripple;
        })();
    
        TW.Semux = (function() {
    
            /**
             * Namespace Semux.
             * @memberof TW
             * @namespace
             */
            var Semux = {};
    
            Semux.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Semux
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Semux.Proto
                     * @interface ISigningInput
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {string|null} [destination] SigningInput destination
                     * @property {Long|null} [value] SigningInput value
                     * @property {Long|null} [fee] SigningInput fee
                     * @property {Long|null} [nonce] SigningInput nonce
                     * @property {Long|null} [timestamp] SigningInput timestamp
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Semux.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Semux.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Semux.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput destination.
                     * @member {string} destination
                     * @memberof TW.Semux.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.destination = "";
    
                    /**
                     * SigningInput value.
                     * @member {Long} value
                     * @memberof TW.Semux.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput fee.
                     * @member {Long} fee
                     * @memberof TW.Semux.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput nonce.
                     * @member {Long} nonce
                     * @memberof TW.Semux.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Semux.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Semux.Proto.SigningInput
                     * @static
                     * @param {TW.Semux.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Semux.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Semux.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Semux.Proto.SigningInput
                     * @static
                     * @param {TW.Semux.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.destination);
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.value);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fee);
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.nonce);
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.timestamp);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Semux.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Semux.Proto.SigningInput
                     * @static
                     * @param {TW.Semux.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Semux.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Semux.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Semux.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.privateKey = reader.bytes();
                                break;
                            case 2:
                                message.destination = reader.string();
                                break;
                            case 3:
                                message.value = reader.uint64();
                                break;
                            case 4:
                                message.fee = reader.uint64();
                                break;
                            case 5:
                                message.nonce = reader.uint64();
                                break;
                            case 6:
                                message.timestamp = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Semux.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Semux.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Semux.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            if (!$util.isString(message.destination))
                                return "destination: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Semux.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Semux.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Semux.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Semux.Proto.SigningInput();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.destination != null)
                            message.destination = String(object.destination);
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Semux.Proto.SigningInput
                     * @static
                     * @param {TW.Semux.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.destination = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            object.destination = message.destination;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Semux.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Semux.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Semux.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Semux.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.Semux.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Semux.Proto.SigningOutput
                     * @static
                     * @param {TW.Semux.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Semux.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Semux.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Semux.Proto.SigningOutput
                     * @static
                     * @param {TW.Semux.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Semux.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Semux.Proto.SigningOutput
                     * @static
                     * @param {TW.Semux.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Semux.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Semux.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Semux.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Semux.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Semux.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Semux.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Semux.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Semux.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Semux.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Semux.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Semux.Proto.SigningOutput
                     * @static
                     * @param {TW.Semux.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Semux.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Semux;
        })();
    
        TW.Stellar = (function() {
    
            /**
             * Namespace Stellar.
             * @memberof TW
             * @namespace
             */
            var Stellar = {};
    
            Stellar.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Stellar
                 * @namespace
                 */
                var Proto = {};
    
                Proto.MemoVoid = (function() {
    
                    /**
                     * Properties of a MemoVoid.
                     * @memberof TW.Stellar.Proto
                     * @interface IMemoVoid
                     */
    
                    /**
                     * Constructs a new MemoVoid.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a MemoVoid.
                     * @implements IMemoVoid
                     * @constructor
                     * @param {TW.Stellar.Proto.IMemoVoid=} [properties] Properties to set
                     */
                    function MemoVoid(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new MemoVoid instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {TW.Stellar.Proto.IMemoVoid=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.MemoVoid} MemoVoid instance
                     */
                    MemoVoid.create = function create(properties) {
                        return new MemoVoid(properties);
                    };
    
                    /**
                     * Encodes the specified MemoVoid message. Does not implicitly {@link TW.Stellar.Proto.MemoVoid.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {TW.Stellar.Proto.IMemoVoid} message MemoVoid message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoVoid.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified MemoVoid message, length delimited. Does not implicitly {@link TW.Stellar.Proto.MemoVoid.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {TW.Stellar.Proto.IMemoVoid} message MemoVoid message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoVoid.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a MemoVoid message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.MemoVoid} MemoVoid
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoVoid.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.MemoVoid();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a MemoVoid message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Stellar.Proto.MemoVoid} MemoVoid
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoVoid.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a MemoVoid message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MemoVoid.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a MemoVoid message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.MemoVoid} MemoVoid
                     */
                    MemoVoid.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.MemoVoid)
                            return object;
                        return new $root.TW.Stellar.Proto.MemoVoid();
                    };
    
                    /**
                     * Creates a plain object from a MemoVoid message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @static
                     * @param {TW.Stellar.Proto.MemoVoid} message MemoVoid
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MemoVoid.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this MemoVoid to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.MemoVoid
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MemoVoid.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return MemoVoid;
                })();
    
                Proto.MemoText = (function() {
    
                    /**
                     * Properties of a MemoText.
                     * @memberof TW.Stellar.Proto
                     * @interface IMemoText
                     * @property {string|null} [text] MemoText text
                     */
    
                    /**
                     * Constructs a new MemoText.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a MemoText.
                     * @implements IMemoText
                     * @constructor
                     * @param {TW.Stellar.Proto.IMemoText=} [properties] Properties to set
                     */
                    function MemoText(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * MemoText text.
                     * @member {string} text
                     * @memberof TW.Stellar.Proto.MemoText
                     * @instance
                     */
                    MemoText.prototype.text = "";
    
                    /**
                     * Creates a new MemoText instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {TW.Stellar.Proto.IMemoText=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.MemoText} MemoText instance
                     */
                    MemoText.create = function create(properties) {
                        return new MemoText(properties);
                    };
    
                    /**
                     * Encodes the specified MemoText message. Does not implicitly {@link TW.Stellar.Proto.MemoText.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {TW.Stellar.Proto.IMemoText} message MemoText message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoText.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.text != null && message.hasOwnProperty("text"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified MemoText message, length delimited. Does not implicitly {@link TW.Stellar.Proto.MemoText.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {TW.Stellar.Proto.IMemoText} message MemoText message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoText.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a MemoText message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.MemoText} MemoText
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoText.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.MemoText();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.text = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a MemoText message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Stellar.Proto.MemoText} MemoText
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoText.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a MemoText message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MemoText.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.text != null && message.hasOwnProperty("text"))
                            if (!$util.isString(message.text))
                                return "text: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a MemoText message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.MemoText} MemoText
                     */
                    MemoText.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.MemoText)
                            return object;
                        var message = new $root.TW.Stellar.Proto.MemoText();
                        if (object.text != null)
                            message.text = String(object.text);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a MemoText message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.MemoText
                     * @static
                     * @param {TW.Stellar.Proto.MemoText} message MemoText
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MemoText.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.text = "";
                        if (message.text != null && message.hasOwnProperty("text"))
                            object.text = message.text;
                        return object;
                    };
    
                    /**
                     * Converts this MemoText to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.MemoText
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MemoText.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return MemoText;
                })();
    
                Proto.MemoId = (function() {
    
                    /**
                     * Properties of a MemoId.
                     * @memberof TW.Stellar.Proto
                     * @interface IMemoId
                     * @property {Long|null} [id] MemoId id
                     */
    
                    /**
                     * Constructs a new MemoId.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a MemoId.
                     * @implements IMemoId
                     * @constructor
                     * @param {TW.Stellar.Proto.IMemoId=} [properties] Properties to set
                     */
                    function MemoId(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * MemoId id.
                     * @member {Long} id
                     * @memberof TW.Stellar.Proto.MemoId
                     * @instance
                     */
                    MemoId.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new MemoId instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {TW.Stellar.Proto.IMemoId=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.MemoId} MemoId instance
                     */
                    MemoId.create = function create(properties) {
                        return new MemoId(properties);
                    };
    
                    /**
                     * Encodes the specified MemoId message. Does not implicitly {@link TW.Stellar.Proto.MemoId.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {TW.Stellar.Proto.IMemoId} message MemoId message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoId.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified MemoId message, length delimited. Does not implicitly {@link TW.Stellar.Proto.MemoId.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {TW.Stellar.Proto.IMemoId} message MemoId message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoId.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a MemoId message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.MemoId} MemoId
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoId.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.MemoId();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a MemoId message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Stellar.Proto.MemoId} MemoId
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoId.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a MemoId message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MemoId.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                                return "id: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a MemoId message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.MemoId} MemoId
                     */
                    MemoId.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.MemoId)
                            return object;
                        var message = new $root.TW.Stellar.Proto.MemoId();
                        if (object.id != null)
                            if ($util.Long)
                                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                            else if (typeof object.id === "string")
                                message.id = parseInt(object.id, 10);
                            else if (typeof object.id === "number")
                                message.id = object.id;
                            else if (typeof object.id === "object")
                                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a MemoId message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.MemoId
                     * @static
                     * @param {TW.Stellar.Proto.MemoId} message MemoId
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MemoId.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.id = options.longs === String ? "0" : 0;
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (typeof message.id === "number")
                                object.id = options.longs === String ? String(message.id) : message.id;
                            else
                                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
                        return object;
                    };
    
                    /**
                     * Converts this MemoId to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.MemoId
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MemoId.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return MemoId;
                })();
    
                Proto.MemoHash = (function() {
    
                    /**
                     * Properties of a MemoHash.
                     * @memberof TW.Stellar.Proto
                     * @interface IMemoHash
                     * @property {Uint8Array|null} [hash] MemoHash hash
                     */
    
                    /**
                     * Constructs a new MemoHash.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a MemoHash.
                     * @implements IMemoHash
                     * @constructor
                     * @param {TW.Stellar.Proto.IMemoHash=} [properties] Properties to set
                     */
                    function MemoHash(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * MemoHash hash.
                     * @member {Uint8Array} hash
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @instance
                     */
                    MemoHash.prototype.hash = $util.newBuffer([]);
    
                    /**
                     * Creates a new MemoHash instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {TW.Stellar.Proto.IMemoHash=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.MemoHash} MemoHash instance
                     */
                    MemoHash.create = function create(properties) {
                        return new MemoHash(properties);
                    };
    
                    /**
                     * Encodes the specified MemoHash message. Does not implicitly {@link TW.Stellar.Proto.MemoHash.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {TW.Stellar.Proto.IMemoHash} message MemoHash message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoHash.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified MemoHash message, length delimited. Does not implicitly {@link TW.Stellar.Proto.MemoHash.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {TW.Stellar.Proto.IMemoHash} message MemoHash message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MemoHash.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a MemoHash message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.MemoHash} MemoHash
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoHash.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.MemoHash();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.hash = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a MemoHash message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Stellar.Proto.MemoHash} MemoHash
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MemoHash.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a MemoHash message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MemoHash.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                                return "hash: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a MemoHash message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.MemoHash} MemoHash
                     */
                    MemoHash.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.MemoHash)
                            return object;
                        var message = new $root.TW.Stellar.Proto.MemoHash();
                        if (object.hash != null)
                            if (typeof object.hash === "string")
                                $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                            else if (object.hash.length)
                                message.hash = object.hash;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a MemoHash message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @static
                     * @param {TW.Stellar.Proto.MemoHash} message MemoHash
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MemoHash.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.hash = "";
                            else {
                                object.hash = [];
                                if (options.bytes !== Array)
                                    object.hash = $util.newBuffer(object.hash);
                            }
                        if (message.hash != null && message.hasOwnProperty("hash"))
                            object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                        return object;
                    };
    
                    /**
                     * Converts this MemoHash to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.MemoHash
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MemoHash.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return MemoHash;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Stellar.Proto
                     * @interface ISigningInput
                     * @property {Long|null} [amount] SigningInput amount
                     * @property {number|null} [fee] SigningInput fee
                     * @property {Long|null} [sequence] SigningInput sequence
                     * @property {string|null} [account] SigningInput account
                     * @property {string|null} [destination] SigningInput destination
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {TW.Stellar.Proto.IMemoVoid|null} [memoVoid] SigningInput memoVoid
                     * @property {TW.Stellar.Proto.IMemoText|null} [memoText] SigningInput memoText
                     * @property {TW.Stellar.Proto.IMemoId|null} [memoId] SigningInput memoId
                     * @property {TW.Stellar.Proto.IMemoHash|null} [memoHash] SigningInput memoHash
                     * @property {TW.Stellar.Proto.IMemoHash|null} [memoReturnHash] SigningInput memoReturnHash
                     * @property {TW.Stellar.Proto.SigningInput.OperationType|null} [operationType] SigningInput operationType
                     * @property {string|null} [passphrase] SigningInput passphrase
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Stellar.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput amount.
                     * @member {Long} amount
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput fee.
                     * @member {number} fee
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = 0;
    
                    /**
                     * SigningInput sequence.
                     * @member {Long} sequence
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput account.
                     * @member {string} account
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.account = "";
    
                    /**
                     * SigningInput destination.
                     * @member {string} destination
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.destination = "";
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput memoVoid.
                     * @member {TW.Stellar.Proto.IMemoVoid|null|undefined} memoVoid
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memoVoid = null;
    
                    /**
                     * SigningInput memoText.
                     * @member {TW.Stellar.Proto.IMemoText|null|undefined} memoText
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memoText = null;
    
                    /**
                     * SigningInput memoId.
                     * @member {TW.Stellar.Proto.IMemoId|null|undefined} memoId
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memoId = null;
    
                    /**
                     * SigningInput memoHash.
                     * @member {TW.Stellar.Proto.IMemoHash|null|undefined} memoHash
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memoHash = null;
    
                    /**
                     * SigningInput memoReturnHash.
                     * @member {TW.Stellar.Proto.IMemoHash|null|undefined} memoReturnHash
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.memoReturnHash = null;
    
                    /**
                     * SigningInput operationType.
                     * @member {TW.Stellar.Proto.SigningInput.OperationType} operationType
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.operationType = 0;
    
                    /**
                     * SigningInput passphrase.
                     * @member {string} passphrase
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.passphrase = "";
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * SigningInput memoTypeOneof.
                     * @member {"memoVoid"|"memoText"|"memoId"|"memoHash"|"memoReturnHash"|undefined} memoTypeOneof
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     */
                    Object.defineProperty(SigningInput.prototype, "memoTypeOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["memoVoid", "memoText", "memoId", "memoHash", "memoReturnHash"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {TW.Stellar.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Stellar.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {TW.Stellar.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.amount);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fee);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.sequence);
                        if (message.account != null && message.hasOwnProperty("account"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.account);
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.destination);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.privateKey);
                        if (message.memoVoid != null && message.hasOwnProperty("memoVoid"))
                            $root.TW.Stellar.Proto.MemoVoid.encode(message.memoVoid, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.memoText != null && message.hasOwnProperty("memoText"))
                            $root.TW.Stellar.Proto.MemoText.encode(message.memoText, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.memoId != null && message.hasOwnProperty("memoId"))
                            $root.TW.Stellar.Proto.MemoId.encode(message.memoId, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.memoHash != null && message.hasOwnProperty("memoHash"))
                            $root.TW.Stellar.Proto.MemoHash.encode(message.memoHash, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.memoReturnHash != null && message.hasOwnProperty("memoReturnHash"))
                            $root.TW.Stellar.Proto.MemoHash.encode(message.memoReturnHash, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        if (message.operationType != null && message.hasOwnProperty("operationType"))
                            writer.uint32(/* id 12, wireType 0 =*/96).int32(message.operationType);
                        if (message.passphrase != null && message.hasOwnProperty("passphrase"))
                            writer.uint32(/* id 13, wireType 2 =*/106).string(message.passphrase);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Stellar.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {TW.Stellar.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.int64();
                                break;
                            case 2:
                                message.fee = reader.int32();
                                break;
                            case 3:
                                message.sequence = reader.int64();
                                break;
                            case 4:
                                message.account = reader.string();
                                break;
                            case 5:
                                message.destination = reader.string();
                                break;
                            case 6:
                                message.privateKey = reader.bytes();
                                break;
                            case 7:
                                message.memoVoid = $root.TW.Stellar.Proto.MemoVoid.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.memoText = $root.TW.Stellar.Proto.MemoText.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.memoId = $root.TW.Stellar.Proto.MemoId.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.memoHash = $root.TW.Stellar.Proto.MemoHash.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.memoReturnHash = $root.TW.Stellar.Proto.MemoHash.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.operationType = reader.int32();
                                break;
                            case 13:
                                message.passphrase = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Stellar.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee))
                                return "fee: integer expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                                return "sequence: integer|Long expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            if (!$util.isString(message.destination))
                                return "destination: string expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.memoVoid != null && message.hasOwnProperty("memoVoid")) {
                            properties.memoTypeOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.MemoVoid.verify(message.memoVoid);
                                if (error)
                                    return "memoVoid." + error;
                            }
                        }
                        if (message.memoText != null && message.hasOwnProperty("memoText")) {
                            if (properties.memoTypeOneof === 1)
                                return "memoTypeOneof: multiple values";
                            properties.memoTypeOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.MemoText.verify(message.memoText);
                                if (error)
                                    return "memoText." + error;
                            }
                        }
                        if (message.memoId != null && message.hasOwnProperty("memoId")) {
                            if (properties.memoTypeOneof === 1)
                                return "memoTypeOneof: multiple values";
                            properties.memoTypeOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.MemoId.verify(message.memoId);
                                if (error)
                                    return "memoId." + error;
                            }
                        }
                        if (message.memoHash != null && message.hasOwnProperty("memoHash")) {
                            if (properties.memoTypeOneof === 1)
                                return "memoTypeOneof: multiple values";
                            properties.memoTypeOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.MemoHash.verify(message.memoHash);
                                if (error)
                                    return "memoHash." + error;
                            }
                        }
                        if (message.memoReturnHash != null && message.hasOwnProperty("memoReturnHash")) {
                            if (properties.memoTypeOneof === 1)
                                return "memoTypeOneof: multiple values";
                            properties.memoTypeOneof = 1;
                            {
                                var error = $root.TW.Stellar.Proto.MemoHash.verify(message.memoReturnHash);
                                if (error)
                                    return "memoReturnHash." + error;
                            }
                        }
                        if (message.operationType != null && message.hasOwnProperty("operationType"))
                            switch (message.operationType) {
                            default:
                                return "operationType: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        if (message.passphrase != null && message.hasOwnProperty("passphrase"))
                            if (!$util.isString(message.passphrase))
                                return "passphrase: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Stellar.Proto.SigningInput();
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.fee != null)
                            message.fee = object.fee | 0;
                        if (object.sequence != null)
                            if ($util.Long)
                                (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                            else if (typeof object.sequence === "string")
                                message.sequence = parseInt(object.sequence, 10);
                            else if (typeof object.sequence === "number")
                                message.sequence = object.sequence;
                            else if (typeof object.sequence === "object")
                                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                        if (object.account != null)
                            message.account = String(object.account);
                        if (object.destination != null)
                            message.destination = String(object.destination);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.memoVoid != null) {
                            if (typeof object.memoVoid !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.memoVoid: object expected");
                            message.memoVoid = $root.TW.Stellar.Proto.MemoVoid.fromObject(object.memoVoid);
                        }
                        if (object.memoText != null) {
                            if (typeof object.memoText !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.memoText: object expected");
                            message.memoText = $root.TW.Stellar.Proto.MemoText.fromObject(object.memoText);
                        }
                        if (object.memoId != null) {
                            if (typeof object.memoId !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.memoId: object expected");
                            message.memoId = $root.TW.Stellar.Proto.MemoId.fromObject(object.memoId);
                        }
                        if (object.memoHash != null) {
                            if (typeof object.memoHash !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.memoHash: object expected");
                            message.memoHash = $root.TW.Stellar.Proto.MemoHash.fromObject(object.memoHash);
                        }
                        if (object.memoReturnHash != null) {
                            if (typeof object.memoReturnHash !== "object")
                                throw TypeError(".TW.Stellar.Proto.SigningInput.memoReturnHash: object expected");
                            message.memoReturnHash = $root.TW.Stellar.Proto.MemoHash.fromObject(object.memoReturnHash);
                        }
                        switch (object.operationType) {
                        case "CREATE_ACCOUNT":
                        case 0:
                            message.operationType = 0;
                            break;
                        case "PAYMENT":
                        case 1:
                            message.operationType = 1;
                            break;
                        }
                        if (object.passphrase != null)
                            message.passphrase = String(object.passphrase);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @static
                     * @param {TW.Stellar.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.fee = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sequence = options.longs === String ? "0" : 0;
                            object.account = "";
                            object.destination = "";
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            object.operationType = options.enums === String ? "CREATE_ACCOUNT" : 0;
                            object.passphrase = "";
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            object.fee = message.fee;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (typeof message.sequence === "number")
                                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                            else
                                object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            object.destination = message.destination;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.memoVoid != null && message.hasOwnProperty("memoVoid")) {
                            object.memoVoid = $root.TW.Stellar.Proto.MemoVoid.toObject(message.memoVoid, options);
                            if (options.oneofs)
                                object.memoTypeOneof = "memoVoid";
                        }
                        if (message.memoText != null && message.hasOwnProperty("memoText")) {
                            object.memoText = $root.TW.Stellar.Proto.MemoText.toObject(message.memoText, options);
                            if (options.oneofs)
                                object.memoTypeOneof = "memoText";
                        }
                        if (message.memoId != null && message.hasOwnProperty("memoId")) {
                            object.memoId = $root.TW.Stellar.Proto.MemoId.toObject(message.memoId, options);
                            if (options.oneofs)
                                object.memoTypeOneof = "memoId";
                        }
                        if (message.memoHash != null && message.hasOwnProperty("memoHash")) {
                            object.memoHash = $root.TW.Stellar.Proto.MemoHash.toObject(message.memoHash, options);
                            if (options.oneofs)
                                object.memoTypeOneof = "memoHash";
                        }
                        if (message.memoReturnHash != null && message.hasOwnProperty("memoReturnHash")) {
                            object.memoReturnHash = $root.TW.Stellar.Proto.MemoHash.toObject(message.memoReturnHash, options);
                            if (options.oneofs)
                                object.memoTypeOneof = "memoReturnHash";
                        }
                        if (message.operationType != null && message.hasOwnProperty("operationType"))
                            object.operationType = options.enums === String ? $root.TW.Stellar.Proto.SigningInput.OperationType[message.operationType] : message.operationType;
                        if (message.passphrase != null && message.hasOwnProperty("passphrase"))
                            object.passphrase = message.passphrase;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * OperationType enum.
                     * @name TW.Stellar.Proto.SigningInput.OperationType
                     * @enum {string}
                     * @property {number} CREATE_ACCOUNT=0 CREATE_ACCOUNT value
                     * @property {number} PAYMENT=1 PAYMENT value
                     */
                    SigningInput.OperationType = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "CREATE_ACCOUNT"] = 0;
                        values[valuesById[1] = "PAYMENT"] = 1;
                        return values;
                    })();
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Stellar.Proto
                     * @interface ISigningOutput
                     * @property {string|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Stellar.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Stellar.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signature.
                     * @member {string} signature
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {TW.Stellar.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Stellar.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Stellar.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {TW.Stellar.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Stellar.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {TW.Stellar.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Stellar.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Stellar.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signature = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Stellar.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!$util.isString(message.signature))
                                return "signature: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Stellar.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Stellar.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Stellar.Proto.SigningOutput();
                        if (object.signature != null)
                            message.signature = String(object.signature);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @static
                     * @param {TW.Stellar.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.signature = "";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Stellar.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Stellar;
        })();
    
        TW.Tezos = (function() {
    
            /**
             * Namespace Tezos.
             * @memberof TW
             * @namespace
             */
            var Tezos = {};
    
            Tezos.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Tezos
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Tezos.Proto
                     * @interface ISigningInput
                     * @property {TW.Tezos.Proto.IOperationList|null} [operationList] SigningInput operationList
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Tezos.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput operationList.
                     * @member {TW.Tezos.Proto.IOperationList|null|undefined} operationList
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.operationList = null;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {TW.Tezos.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Tezos.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {TW.Tezos.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.operationList != null && message.hasOwnProperty("operationList"))
                            $root.TW.Tezos.Proto.OperationList.encode(message.operationList, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Tezos.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {TW.Tezos.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.operationList = $root.TW.Tezos.Proto.OperationList.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tezos.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.operationList != null && message.hasOwnProperty("operationList")) {
                            var error = $root.TW.Tezos.Proto.OperationList.verify(message.operationList);
                            if (error)
                                return "operationList." + error;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Tezos.Proto.SigningInput();
                        if (object.operationList != null) {
                            if (typeof object.operationList !== "object")
                                throw TypeError(".TW.Tezos.Proto.SigningInput.operationList: object expected");
                            message.operationList = $root.TW.Tezos.Proto.OperationList.fromObject(object.operationList);
                        }
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @static
                     * @param {TW.Tezos.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.operationList = null;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.operationList != null && message.hasOwnProperty("operationList"))
                            object.operationList = $root.TW.Tezos.Proto.OperationList.toObject(message.operationList, options);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Tezos.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [signedBytes] SigningOutput signedBytes
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Tezos.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signedBytes.
                     * @member {Uint8Array} signedBytes
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signedBytes = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {TW.Tezos.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Tezos.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {TW.Tezos.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signedBytes != null && message.hasOwnProperty("signedBytes"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signedBytes);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Tezos.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {TW.Tezos.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signedBytes = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tezos.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signedBytes != null && message.hasOwnProperty("signedBytes"))
                            if (!(message.signedBytes && typeof message.signedBytes.length === "number" || $util.isString(message.signedBytes)))
                                return "signedBytes: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Tezos.Proto.SigningOutput();
                        if (object.signedBytes != null)
                            if (typeof object.signedBytes === "string")
                                $util.base64.decode(object.signedBytes, message.signedBytes = $util.newBuffer($util.base64.length(object.signedBytes)), 0);
                            else if (object.signedBytes.length)
                                message.signedBytes = object.signedBytes;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @static
                     * @param {TW.Tezos.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.signedBytes = "";
                            else {
                                object.signedBytes = [];
                                if (options.bytes !== Array)
                                    object.signedBytes = $util.newBuffer(object.signedBytes);
                            }
                        if (message.signedBytes != null && message.hasOwnProperty("signedBytes"))
                            object.signedBytes = options.bytes === String ? $util.base64.encode(message.signedBytes, 0, message.signedBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.signedBytes) : message.signedBytes;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                Proto.OperationList = (function() {
    
                    /**
                     * Properties of an OperationList.
                     * @memberof TW.Tezos.Proto
                     * @interface IOperationList
                     * @property {string|null} [branch] OperationList branch
                     * @property {Array.<TW.Tezos.Proto.IOperation>|null} [operations] OperationList operations
                     */
    
                    /**
                     * Constructs a new OperationList.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents an OperationList.
                     * @implements IOperationList
                     * @constructor
                     * @param {TW.Tezos.Proto.IOperationList=} [properties] Properties to set
                     */
                    function OperationList(properties) {
                        this.operations = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * OperationList branch.
                     * @member {string} branch
                     * @memberof TW.Tezos.Proto.OperationList
                     * @instance
                     */
                    OperationList.prototype.branch = "";
    
                    /**
                     * OperationList operations.
                     * @member {Array.<TW.Tezos.Proto.IOperation>} operations
                     * @memberof TW.Tezos.Proto.OperationList
                     * @instance
                     */
                    OperationList.prototype.operations = $util.emptyArray;
    
                    /**
                     * Creates a new OperationList instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {TW.Tezos.Proto.IOperationList=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.OperationList} OperationList instance
                     */
                    OperationList.create = function create(properties) {
                        return new OperationList(properties);
                    };
    
                    /**
                     * Encodes the specified OperationList message. Does not implicitly {@link TW.Tezos.Proto.OperationList.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {TW.Tezos.Proto.IOperationList} message OperationList message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OperationList.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.branch != null && message.hasOwnProperty("branch"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.branch);
                        if (message.operations != null && message.operations.length)
                            for (var i = 0; i < message.operations.length; ++i)
                                $root.TW.Tezos.Proto.Operation.encode(message.operations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified OperationList message, length delimited. Does not implicitly {@link TW.Tezos.Proto.OperationList.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {TW.Tezos.Proto.IOperationList} message OperationList message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OperationList.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an OperationList message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.OperationList} OperationList
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OperationList.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.OperationList();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.branch = reader.string();
                                break;
                            case 2:
                                if (!(message.operations && message.operations.length))
                                    message.operations = [];
                                message.operations.push($root.TW.Tezos.Proto.Operation.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an OperationList message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tezos.Proto.OperationList} OperationList
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OperationList.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an OperationList message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    OperationList.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.branch != null && message.hasOwnProperty("branch"))
                            if (!$util.isString(message.branch))
                                return "branch: string expected";
                        if (message.operations != null && message.hasOwnProperty("operations")) {
                            if (!Array.isArray(message.operations))
                                return "operations: array expected";
                            for (var i = 0; i < message.operations.length; ++i) {
                                var error = $root.TW.Tezos.Proto.Operation.verify(message.operations[i]);
                                if (error)
                                    return "operations." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates an OperationList message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.OperationList} OperationList
                     */
                    OperationList.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.OperationList)
                            return object;
                        var message = new $root.TW.Tezos.Proto.OperationList();
                        if (object.branch != null)
                            message.branch = String(object.branch);
                        if (object.operations) {
                            if (!Array.isArray(object.operations))
                                throw TypeError(".TW.Tezos.Proto.OperationList.operations: array expected");
                            message.operations = [];
                            for (var i = 0; i < object.operations.length; ++i) {
                                if (typeof object.operations[i] !== "object")
                                    throw TypeError(".TW.Tezos.Proto.OperationList.operations: object expected");
                                message.operations[i] = $root.TW.Tezos.Proto.Operation.fromObject(object.operations[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an OperationList message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.OperationList
                     * @static
                     * @param {TW.Tezos.Proto.OperationList} message OperationList
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    OperationList.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.operations = [];
                        if (options.defaults)
                            object.branch = "";
                        if (message.branch != null && message.hasOwnProperty("branch"))
                            object.branch = message.branch;
                        if (message.operations && message.operations.length) {
                            object.operations = [];
                            for (var j = 0; j < message.operations.length; ++j)
                                object.operations[j] = $root.TW.Tezos.Proto.Operation.toObject(message.operations[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this OperationList to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.OperationList
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    OperationList.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return OperationList;
                })();
    
                Proto.Operation = (function() {
    
                    /**
                     * Properties of an Operation.
                     * @memberof TW.Tezos.Proto
                     * @interface IOperation
                     * @property {Long|null} [counter] Operation counter
                     * @property {string|null} [source] Operation source
                     * @property {Long|null} [fee] Operation fee
                     * @property {Long|null} [gasLimit] Operation gasLimit
                     * @property {Long|null} [storageLimit] Operation storageLimit
                     * @property {TW.Tezos.Proto.Operation.OperationKind|null} [kind] Operation kind
                     * @property {TW.Tezos.Proto.IRevealOperationData|null} [revealOperationData] Operation revealOperationData
                     * @property {TW.Tezos.Proto.ITransactionOperationData|null} [transactionOperationData] Operation transactionOperationData
                     * @property {TW.Tezos.Proto.IOriginationOperationData|null} [originationOperationData] Operation originationOperationData
                     * @property {TW.Tezos.Proto.IDelegationOperationData|null} [delegationOperationData] Operation delegationOperationData
                     */
    
                    /**
                     * Constructs a new Operation.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents an Operation.
                     * @implements IOperation
                     * @constructor
                     * @param {TW.Tezos.Proto.IOperation=} [properties] Properties to set
                     */
                    function Operation(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Operation counter.
                     * @member {Long} counter
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.counter = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Operation source.
                     * @member {string} source
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.source = "";
    
                    /**
                     * Operation fee.
                     * @member {Long} fee
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Operation gasLimit.
                     * @member {Long} gasLimit
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.gasLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Operation storageLimit.
                     * @member {Long} storageLimit
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.storageLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Operation kind.
                     * @member {TW.Tezos.Proto.Operation.OperationKind} kind
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.kind = 0;
    
                    /**
                     * Operation revealOperationData.
                     * @member {TW.Tezos.Proto.IRevealOperationData|null|undefined} revealOperationData
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.revealOperationData = null;
    
                    /**
                     * Operation transactionOperationData.
                     * @member {TW.Tezos.Proto.ITransactionOperationData|null|undefined} transactionOperationData
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.transactionOperationData = null;
    
                    /**
                     * Operation originationOperationData.
                     * @member {TW.Tezos.Proto.IOriginationOperationData|null|undefined} originationOperationData
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.originationOperationData = null;
    
                    /**
                     * Operation delegationOperationData.
                     * @member {TW.Tezos.Proto.IDelegationOperationData|null|undefined} delegationOperationData
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Operation.prototype.delegationOperationData = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Operation operationData.
                     * @member {"revealOperationData"|"transactionOperationData"|"originationOperationData"|"delegationOperationData"|undefined} operationData
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     */
                    Object.defineProperty(Operation.prototype, "operationData", {
                        get: $util.oneOfGetter($oneOfFields = ["revealOperationData", "transactionOperationData", "originationOperationData", "delegationOperationData"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Operation instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {TW.Tezos.Proto.IOperation=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.Operation} Operation instance
                     */
                    Operation.create = function create(properties) {
                        return new Operation(properties);
                    };
    
                    /**
                     * Encodes the specified Operation message. Does not implicitly {@link TW.Tezos.Proto.Operation.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {TW.Tezos.Proto.IOperation} message Operation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Operation.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.counter != null && message.hasOwnProperty("counter"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.counter);
                        if (message.source != null && message.hasOwnProperty("source"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.source);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fee);
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.gasLimit);
                        if (message.storageLimit != null && message.hasOwnProperty("storageLimit"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.storageLimit);
                        if (message.kind != null && message.hasOwnProperty("kind"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.kind);
                        if (message.revealOperationData != null && message.hasOwnProperty("revealOperationData"))
                            $root.TW.Tezos.Proto.RevealOperationData.encode(message.revealOperationData, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.transactionOperationData != null && message.hasOwnProperty("transactionOperationData"))
                            $root.TW.Tezos.Proto.TransactionOperationData.encode(message.transactionOperationData, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.originationOperationData != null && message.hasOwnProperty("originationOperationData"))
                            $root.TW.Tezos.Proto.OriginationOperationData.encode(message.originationOperationData, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.delegationOperationData != null && message.hasOwnProperty("delegationOperationData"))
                            $root.TW.Tezos.Proto.DelegationOperationData.encode(message.delegationOperationData, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Operation message, length delimited. Does not implicitly {@link TW.Tezos.Proto.Operation.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {TW.Tezos.Proto.IOperation} message Operation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Operation.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an Operation message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.Operation} Operation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Operation.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.Operation();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.counter = reader.int64();
                                break;
                            case 2:
                                message.source = reader.string();
                                break;
                            case 3:
                                message.fee = reader.int64();
                                break;
                            case 4:
                                message.gasLimit = reader.int64();
                                break;
                            case 5:
                                message.storageLimit = reader.int64();
                                break;
                            case 7:
                                message.kind = reader.int32();
                                break;
                            case 8:
                                message.revealOperationData = $root.TW.Tezos.Proto.RevealOperationData.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.transactionOperationData = $root.TW.Tezos.Proto.TransactionOperationData.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.originationOperationData = $root.TW.Tezos.Proto.OriginationOperationData.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.delegationOperationData = $root.TW.Tezos.Proto.DelegationOperationData.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an Operation message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tezos.Proto.Operation} Operation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Operation.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an Operation message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Operation.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.counter != null && message.hasOwnProperty("counter"))
                            if (!$util.isInteger(message.counter) && !(message.counter && $util.isInteger(message.counter.low) && $util.isInteger(message.counter.high)))
                                return "counter: integer|Long expected";
                        if (message.source != null && message.hasOwnProperty("source"))
                            if (!$util.isString(message.source))
                                return "source: string expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!$util.isInteger(message.gasLimit) && !(message.gasLimit && $util.isInteger(message.gasLimit.low) && $util.isInteger(message.gasLimit.high)))
                                return "gasLimit: integer|Long expected";
                        if (message.storageLimit != null && message.hasOwnProperty("storageLimit"))
                            if (!$util.isInteger(message.storageLimit) && !(message.storageLimit && $util.isInteger(message.storageLimit.low) && $util.isInteger(message.storageLimit.high)))
                                return "storageLimit: integer|Long expected";
                        if (message.kind != null && message.hasOwnProperty("kind"))
                            switch (message.kind) {
                            default:
                                return "kind: enum value expected";
                            case 0:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                                break;
                            }
                        if (message.revealOperationData != null && message.hasOwnProperty("revealOperationData")) {
                            properties.operationData = 1;
                            {
                                var error = $root.TW.Tezos.Proto.RevealOperationData.verify(message.revealOperationData);
                                if (error)
                                    return "revealOperationData." + error;
                            }
                        }
                        if (message.transactionOperationData != null && message.hasOwnProperty("transactionOperationData")) {
                            if (properties.operationData === 1)
                                return "operationData: multiple values";
                            properties.operationData = 1;
                            {
                                var error = $root.TW.Tezos.Proto.TransactionOperationData.verify(message.transactionOperationData);
                                if (error)
                                    return "transactionOperationData." + error;
                            }
                        }
                        if (message.originationOperationData != null && message.hasOwnProperty("originationOperationData")) {
                            if (properties.operationData === 1)
                                return "operationData: multiple values";
                            properties.operationData = 1;
                            {
                                var error = $root.TW.Tezos.Proto.OriginationOperationData.verify(message.originationOperationData);
                                if (error)
                                    return "originationOperationData." + error;
                            }
                        }
                        if (message.delegationOperationData != null && message.hasOwnProperty("delegationOperationData")) {
                            if (properties.operationData === 1)
                                return "operationData: multiple values";
                            properties.operationData = 1;
                            {
                                var error = $root.TW.Tezos.Proto.DelegationOperationData.verify(message.delegationOperationData);
                                if (error)
                                    return "delegationOperationData." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates an Operation message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.Operation} Operation
                     */
                    Operation.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.Operation)
                            return object;
                        var message = new $root.TW.Tezos.Proto.Operation();
                        if (object.counter != null)
                            if ($util.Long)
                                (message.counter = $util.Long.fromValue(object.counter)).unsigned = false;
                            else if (typeof object.counter === "string")
                                message.counter = parseInt(object.counter, 10);
                            else if (typeof object.counter === "number")
                                message.counter = object.counter;
                            else if (typeof object.counter === "object")
                                message.counter = new $util.LongBits(object.counter.low >>> 0, object.counter.high >>> 0).toNumber();
                        if (object.source != null)
                            message.source = String(object.source);
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        if (object.gasLimit != null)
                            if ($util.Long)
                                (message.gasLimit = $util.Long.fromValue(object.gasLimit)).unsigned = false;
                            else if (typeof object.gasLimit === "string")
                                message.gasLimit = parseInt(object.gasLimit, 10);
                            else if (typeof object.gasLimit === "number")
                                message.gasLimit = object.gasLimit;
                            else if (typeof object.gasLimit === "object")
                                message.gasLimit = new $util.LongBits(object.gasLimit.low >>> 0, object.gasLimit.high >>> 0).toNumber();
                        if (object.storageLimit != null)
                            if ($util.Long)
                                (message.storageLimit = $util.Long.fromValue(object.storageLimit)).unsigned = false;
                            else if (typeof object.storageLimit === "string")
                                message.storageLimit = parseInt(object.storageLimit, 10);
                            else if (typeof object.storageLimit === "number")
                                message.storageLimit = object.storageLimit;
                            else if (typeof object.storageLimit === "object")
                                message.storageLimit = new $util.LongBits(object.storageLimit.low >>> 0, object.storageLimit.high >>> 0).toNumber();
                        switch (object.kind) {
                        case "ENDORSEMENT":
                        case 0:
                            message.kind = 0;
                            break;
                        case "REVEAL":
                        case 7:
                            message.kind = 7;
                            break;
                        case "TRANSACTION":
                        case 8:
                            message.kind = 8;
                            break;
                        case "ORIGINATION":
                        case 9:
                            message.kind = 9;
                            break;
                        case "DELEGATION":
                        case 10:
                            message.kind = 10;
                            break;
                        }
                        if (object.revealOperationData != null) {
                            if (typeof object.revealOperationData !== "object")
                                throw TypeError(".TW.Tezos.Proto.Operation.revealOperationData: object expected");
                            message.revealOperationData = $root.TW.Tezos.Proto.RevealOperationData.fromObject(object.revealOperationData);
                        }
                        if (object.transactionOperationData != null) {
                            if (typeof object.transactionOperationData !== "object")
                                throw TypeError(".TW.Tezos.Proto.Operation.transactionOperationData: object expected");
                            message.transactionOperationData = $root.TW.Tezos.Proto.TransactionOperationData.fromObject(object.transactionOperationData);
                        }
                        if (object.originationOperationData != null) {
                            if (typeof object.originationOperationData !== "object")
                                throw TypeError(".TW.Tezos.Proto.Operation.originationOperationData: object expected");
                            message.originationOperationData = $root.TW.Tezos.Proto.OriginationOperationData.fromObject(object.originationOperationData);
                        }
                        if (object.delegationOperationData != null) {
                            if (typeof object.delegationOperationData !== "object")
                                throw TypeError(".TW.Tezos.Proto.Operation.delegationOperationData: object expected");
                            message.delegationOperationData = $root.TW.Tezos.Proto.DelegationOperationData.fromObject(object.delegationOperationData);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Operation message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.Operation
                     * @static
                     * @param {TW.Tezos.Proto.Operation} message Operation
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Operation.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.counter = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.counter = options.longs === String ? "0" : 0;
                            object.source = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.gasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasLimit = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.storageLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.storageLimit = options.longs === String ? "0" : 0;
                            object.kind = options.enums === String ? "ENDORSEMENT" : 0;
                        }
                        if (message.counter != null && message.hasOwnProperty("counter"))
                            if (typeof message.counter === "number")
                                object.counter = options.longs === String ? String(message.counter) : message.counter;
                            else
                                object.counter = options.longs === String ? $util.Long.prototype.toString.call(message.counter) : options.longs === Number ? new $util.LongBits(message.counter.low >>> 0, message.counter.high >>> 0).toNumber() : message.counter;
                        if (message.source != null && message.hasOwnProperty("source"))
                            object.source = message.source;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit === "number")
                                object.gasLimit = options.longs === String ? String(message.gasLimit) : message.gasLimit;
                            else
                                object.gasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.gasLimit) : options.longs === Number ? new $util.LongBits(message.gasLimit.low >>> 0, message.gasLimit.high >>> 0).toNumber() : message.gasLimit;
                        if (message.storageLimit != null && message.hasOwnProperty("storageLimit"))
                            if (typeof message.storageLimit === "number")
                                object.storageLimit = options.longs === String ? String(message.storageLimit) : message.storageLimit;
                            else
                                object.storageLimit = options.longs === String ? $util.Long.prototype.toString.call(message.storageLimit) : options.longs === Number ? new $util.LongBits(message.storageLimit.low >>> 0, message.storageLimit.high >>> 0).toNumber() : message.storageLimit;
                        if (message.kind != null && message.hasOwnProperty("kind"))
                            object.kind = options.enums === String ? $root.TW.Tezos.Proto.Operation.OperationKind[message.kind] : message.kind;
                        if (message.revealOperationData != null && message.hasOwnProperty("revealOperationData")) {
                            object.revealOperationData = $root.TW.Tezos.Proto.RevealOperationData.toObject(message.revealOperationData, options);
                            if (options.oneofs)
                                object.operationData = "revealOperationData";
                        }
                        if (message.transactionOperationData != null && message.hasOwnProperty("transactionOperationData")) {
                            object.transactionOperationData = $root.TW.Tezos.Proto.TransactionOperationData.toObject(message.transactionOperationData, options);
                            if (options.oneofs)
                                object.operationData = "transactionOperationData";
                        }
                        if (message.originationOperationData != null && message.hasOwnProperty("originationOperationData")) {
                            object.originationOperationData = $root.TW.Tezos.Proto.OriginationOperationData.toObject(message.originationOperationData, options);
                            if (options.oneofs)
                                object.operationData = "originationOperationData";
                        }
                        if (message.delegationOperationData != null && message.hasOwnProperty("delegationOperationData")) {
                            object.delegationOperationData = $root.TW.Tezos.Proto.DelegationOperationData.toObject(message.delegationOperationData, options);
                            if (options.oneofs)
                                object.operationData = "delegationOperationData";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Operation to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.Operation
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Operation.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * OperationKind enum.
                     * @name TW.Tezos.Proto.Operation.OperationKind
                     * @enum {string}
                     * @property {number} ENDORSEMENT=0 ENDORSEMENT value
                     * @property {number} REVEAL=7 REVEAL value
                     * @property {number} TRANSACTION=8 TRANSACTION value
                     * @property {number} ORIGINATION=9 ORIGINATION value
                     * @property {number} DELEGATION=10 DELEGATION value
                     */
                    Operation.OperationKind = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "ENDORSEMENT"] = 0;
                        values[valuesById[7] = "REVEAL"] = 7;
                        values[valuesById[8] = "TRANSACTION"] = 8;
                        values[valuesById[9] = "ORIGINATION"] = 9;
                        values[valuesById[10] = "DELEGATION"] = 10;
                        return values;
                    })();
    
                    return Operation;
                })();
    
                Proto.TransactionOperationData = (function() {
    
                    /**
                     * Properties of a TransactionOperationData.
                     * @memberof TW.Tezos.Proto
                     * @interface ITransactionOperationData
                     * @property {string|null} [destination] TransactionOperationData destination
                     * @property {Long|null} [amount] TransactionOperationData amount
                     */
    
                    /**
                     * Constructs a new TransactionOperationData.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents a TransactionOperationData.
                     * @implements ITransactionOperationData
                     * @constructor
                     * @param {TW.Tezos.Proto.ITransactionOperationData=} [properties] Properties to set
                     */
                    function TransactionOperationData(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransactionOperationData destination.
                     * @member {string} destination
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @instance
                     */
                    TransactionOperationData.prototype.destination = "";
    
                    /**
                     * TransactionOperationData amount.
                     * @member {Long} amount
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @instance
                     */
                    TransactionOperationData.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TransactionOperationData instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {TW.Tezos.Proto.ITransactionOperationData=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.TransactionOperationData} TransactionOperationData instance
                     */
                    TransactionOperationData.create = function create(properties) {
                        return new TransactionOperationData(properties);
                    };
    
                    /**
                     * Encodes the specified TransactionOperationData message. Does not implicitly {@link TW.Tezos.Proto.TransactionOperationData.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {TW.Tezos.Proto.ITransactionOperationData} message TransactionOperationData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOperationData.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TransactionOperationData message, length delimited. Does not implicitly {@link TW.Tezos.Proto.TransactionOperationData.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {TW.Tezos.Proto.ITransactionOperationData} message TransactionOperationData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransactionOperationData.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TransactionOperationData message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.TransactionOperationData} TransactionOperationData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOperationData.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.TransactionOperationData();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.destination = reader.string();
                                break;
                            case 2:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TransactionOperationData message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tezos.Proto.TransactionOperationData} TransactionOperationData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransactionOperationData.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TransactionOperationData message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransactionOperationData.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            if (!$util.isString(message.destination))
                                return "destination: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransactionOperationData message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.TransactionOperationData} TransactionOperationData
                     */
                    TransactionOperationData.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.TransactionOperationData)
                            return object;
                        var message = new $root.TW.Tezos.Proto.TransactionOperationData();
                        if (object.destination != null)
                            message.destination = String(object.destination);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransactionOperationData message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @static
                     * @param {TW.Tezos.Proto.TransactionOperationData} message TransactionOperationData
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransactionOperationData.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.destination = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.destination != null && message.hasOwnProperty("destination"))
                            object.destination = message.destination;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TransactionOperationData to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.TransactionOperationData
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransactionOperationData.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransactionOperationData;
                })();
    
                Proto.RevealOperationData = (function() {
    
                    /**
                     * Properties of a RevealOperationData.
                     * @memberof TW.Tezos.Proto
                     * @interface IRevealOperationData
                     * @property {Uint8Array|null} [publicKey] RevealOperationData publicKey
                     */
    
                    /**
                     * Constructs a new RevealOperationData.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents a RevealOperationData.
                     * @implements IRevealOperationData
                     * @constructor
                     * @param {TW.Tezos.Proto.IRevealOperationData=} [properties] Properties to set
                     */
                    function RevealOperationData(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * RevealOperationData publicKey.
                     * @member {Uint8Array} publicKey
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @instance
                     */
                    RevealOperationData.prototype.publicKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new RevealOperationData instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IRevealOperationData=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.RevealOperationData} RevealOperationData instance
                     */
                    RevealOperationData.create = function create(properties) {
                        return new RevealOperationData(properties);
                    };
    
                    /**
                     * Encodes the specified RevealOperationData message. Does not implicitly {@link TW.Tezos.Proto.RevealOperationData.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IRevealOperationData} message RevealOperationData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RevealOperationData.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified RevealOperationData message, length delimited. Does not implicitly {@link TW.Tezos.Proto.RevealOperationData.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IRevealOperationData} message RevealOperationData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RevealOperationData.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a RevealOperationData message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.RevealOperationData} RevealOperationData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RevealOperationData.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.RevealOperationData();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.publicKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a RevealOperationData message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tezos.Proto.RevealOperationData} RevealOperationData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RevealOperationData.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a RevealOperationData message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RevealOperationData.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                                return "publicKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a RevealOperationData message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.RevealOperationData} RevealOperationData
                     */
                    RevealOperationData.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.RevealOperationData)
                            return object;
                        var message = new $root.TW.Tezos.Proto.RevealOperationData();
                        if (object.publicKey != null)
                            if (typeof object.publicKey === "string")
                                $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                            else if (object.publicKey.length)
                                message.publicKey = object.publicKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a RevealOperationData message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @static
                     * @param {TW.Tezos.Proto.RevealOperationData} message RevealOperationData
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RevealOperationData.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.publicKey = "";
                            else {
                                object.publicKey = [];
                                if (options.bytes !== Array)
                                    object.publicKey = $util.newBuffer(object.publicKey);
                            }
                        if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                            object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                        return object;
                    };
    
                    /**
                     * Converts this RevealOperationData to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.RevealOperationData
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RevealOperationData.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return RevealOperationData;
                })();
    
                Proto.OriginationOperationData = (function() {
    
                    /**
                     * Properties of an OriginationOperationData.
                     * @memberof TW.Tezos.Proto
                     * @interface IOriginationOperationData
                     * @property {string|null} [managerPubkey] OriginationOperationData managerPubkey
                     * @property {Long|null} [balance] OriginationOperationData balance
                     */
    
                    /**
                     * Constructs a new OriginationOperationData.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents an OriginationOperationData.
                     * @implements IOriginationOperationData
                     * @constructor
                     * @param {TW.Tezos.Proto.IOriginationOperationData=} [properties] Properties to set
                     */
                    function OriginationOperationData(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * OriginationOperationData managerPubkey.
                     * @member {string} managerPubkey
                     * @memberof TW.Tezos.Proto.OriginationOperationData
                     * @instance
                     */
                    OriginationOperationData.prototype.managerPubkey = "";
    
                    /**
                     * OriginationOperationData balance.
                     * @member {Long} balance
                     * @memberof TW.Tezos.Proto.OriginationOperationData
                     * @instance
                     */
                    OriginationOperationData.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new OriginationOperationData instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.OriginationOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IOriginationOperationData=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.OriginationOperationData} OriginationOperationData instance
                     */
                    OriginationOperationData.create = function create(properties) {
                        return new OriginationOperationData(properties);
                    };
    
                    /**
                     * Encodes the specified OriginationOperationData message. Does not implicitly {@link TW.Tezos.Proto.OriginationOperationData.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.OriginationOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IOriginationOperationData} message OriginationOperationData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OriginationOperationData.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.managerPubkey != null && message.hasOwnProperty("managerPubkey"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.managerPubkey);
                        if (message.balance != null && message.hasOwnProperty("balance"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.balance);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified OriginationOperationData message, length delimited. Does not implicitly {@link TW.Tezos.Proto.OriginationOperationData.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tezos.Proto.OriginationOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IOriginationOperationData} message OriginationOperationData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    OriginationOperationData.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an OriginationOperationData message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.OriginationOperationData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.OriginationOperationData} OriginationOperationData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OriginationOperationData.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.OriginationOperationData();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.managerPubkey = reader.string();
                                break;
                            case 2:
                                message.balance = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an OriginationOperationData message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tezos.Proto.OriginationOperationData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tezos.Proto.OriginationOperationData} OriginationOperationData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    OriginationOperationData.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an OriginationOperationData message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.OriginationOperationData
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    OriginationOperationData.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.managerPubkey != null && message.hasOwnProperty("managerPubkey"))
                            if (!$util.isString(message.managerPubkey))
                                return "managerPubkey: string expected";
                        if (message.balance != null && message.hasOwnProperty("balance"))
                            if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
                                return "balance: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an OriginationOperationData message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.OriginationOperationData
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.OriginationOperationData} OriginationOperationData
                     */
                    OriginationOperationData.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.OriginationOperationData)
                            return object;
                        var message = new $root.TW.Tezos.Proto.OriginationOperationData();
                        if (object.managerPubkey != null)
                            message.managerPubkey = String(object.managerPubkey);
                        if (object.balance != null)
                            if ($util.Long)
                                (message.balance = $util.Long.fromValue(object.balance)).unsigned = false;
                            else if (typeof object.balance === "string")
                                message.balance = parseInt(object.balance, 10);
                            else if (typeof object.balance === "number")
                                message.balance = object.balance;
                            else if (typeof object.balance === "object")
                                message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an OriginationOperationData message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.OriginationOperationData
                     * @static
                     * @param {TW.Tezos.Proto.OriginationOperationData} message OriginationOperationData
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    OriginationOperationData.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.managerPubkey = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.balance = options.longs === String ? "0" : 0;
                        }
                        if (message.managerPubkey != null && message.hasOwnProperty("managerPubkey"))
                            object.managerPubkey = message.managerPubkey;
                        if (message.balance != null && message.hasOwnProperty("balance"))
                            if (typeof message.balance === "number")
                                object.balance = options.longs === String ? String(message.balance) : message.balance;
                            else
                                object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber() : message.balance;
                        return object;
                    };
    
                    /**
                     * Converts this OriginationOperationData to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.OriginationOperationData
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    OriginationOperationData.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return OriginationOperationData;
                })();
    
                Proto.DelegationOperationData = (function() {
    
                    /**
                     * Properties of a DelegationOperationData.
                     * @memberof TW.Tezos.Proto
                     * @interface IDelegationOperationData
                     * @property {string|null} [delegate] DelegationOperationData delegate
                     */
    
                    /**
                     * Constructs a new DelegationOperationData.
                     * @memberof TW.Tezos.Proto
                     * @classdesc Represents a DelegationOperationData.
                     * @implements IDelegationOperationData
                     * @constructor
                     * @param {TW.Tezos.Proto.IDelegationOperationData=} [properties] Properties to set
                     */
                    function DelegationOperationData(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DelegationOperationData delegate.
                     * @member {string} delegate
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @instance
                     */
                    DelegationOperationData.prototype.delegate = "";
    
                    /**
                     * Creates a new DelegationOperationData instance using the specified properties.
                     * @function create
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IDelegationOperationData=} [properties] Properties to set
                     * @returns {TW.Tezos.Proto.DelegationOperationData} DelegationOperationData instance
                     */
                    DelegationOperationData.create = function create(properties) {
                        return new DelegationOperationData(properties);
                    };
    
                    /**
                     * Encodes the specified DelegationOperationData message. Does not implicitly {@link TW.Tezos.Proto.DelegationOperationData.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IDelegationOperationData} message DelegationOperationData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DelegationOperationData.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.delegate != null && message.hasOwnProperty("delegate"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.delegate);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified DelegationOperationData message, length delimited. Does not implicitly {@link TW.Tezos.Proto.DelegationOperationData.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {TW.Tezos.Proto.IDelegationOperationData} message DelegationOperationData message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DelegationOperationData.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a DelegationOperationData message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tezos.Proto.DelegationOperationData} DelegationOperationData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DelegationOperationData.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tezos.Proto.DelegationOperationData();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.delegate = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a DelegationOperationData message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tezos.Proto.DelegationOperationData} DelegationOperationData
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DelegationOperationData.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a DelegationOperationData message.
                     * @function verify
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DelegationOperationData.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.delegate != null && message.hasOwnProperty("delegate"))
                            if (!$util.isString(message.delegate))
                                return "delegate: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a DelegationOperationData message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tezos.Proto.DelegationOperationData} DelegationOperationData
                     */
                    DelegationOperationData.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tezos.Proto.DelegationOperationData)
                            return object;
                        var message = new $root.TW.Tezos.Proto.DelegationOperationData();
                        if (object.delegate != null)
                            message.delegate = String(object.delegate);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DelegationOperationData message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @static
                     * @param {TW.Tezos.Proto.DelegationOperationData} message DelegationOperationData
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DelegationOperationData.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.delegate = "";
                        if (message.delegate != null && message.hasOwnProperty("delegate"))
                            object.delegate = message.delegate;
                        return object;
                    };
    
                    /**
                     * Converts this DelegationOperationData to JSON.
                     * @function toJSON
                     * @memberof TW.Tezos.Proto.DelegationOperationData
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DelegationOperationData.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DelegationOperationData;
                })();
    
                return Proto;
            })();
    
            return Tezos;
        })();
    
        TW.Theta = (function() {
    
            /**
             * Namespace Theta.
             * @memberof TW
             * @namespace
             */
            var Theta = {};
    
            Theta.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Theta
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Theta.Proto
                     * @interface ISigningInput
                     * @property {string|null} [chainId] Chain ID string, mainnet, testnet and privatenet
                     * @property {string|null} [toAddress] Recipient address
                     * @property {Uint8Array|null} [thetaAmount] Theta token amount to send in wei (256-bit number)
                     * @property {Uint8Array|null} [tfuelAmount] TFuel token amount to send in wei (256-bit number)
                     * @property {Long|null} [sequence] Sequence number of the transaction for the sender address
                     * @property {Uint8Array|null} [fee] Fee amount in TFuel wei for the transaction (256-bit number)
                     * @property {Uint8Array|null} [privateKey] Private key
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Theta.Proto
                     * @classdesc Input data necessary to create a signed transaction
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Theta.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Chain ID string, mainnet, testnet and privatenet
                     * @member {string} chainId
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainId = "";
    
                    /**
                     * Recipient address
                     * @member {string} toAddress
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * Theta token amount to send in wei (256-bit number)
                     * @member {Uint8Array} thetaAmount
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.thetaAmount = $util.newBuffer([]);
    
                    /**
                     * TFuel token amount to send in wei (256-bit number)
                     * @member {Uint8Array} tfuelAmount
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.tfuelAmount = $util.newBuffer([]);
    
                    /**
                     * Sequence number of the transaction for the sender address
                     * @member {Long} sequence
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Fee amount in TFuel wei for the transaction (256-bit number)
                     * @member {Uint8Array} fee
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.newBuffer([]);
    
                    /**
                     * Private key
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {TW.Theta.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Theta.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Theta.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {TW.Theta.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.chainId);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.toAddress);
                        if (message.thetaAmount != null && message.hasOwnProperty("thetaAmount"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.thetaAmount);
                        if (message.tfuelAmount != null && message.hasOwnProperty("tfuelAmount"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.tfuelAmount);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.sequence);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.fee);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Theta.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {TW.Theta.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Theta.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Theta.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainId = reader.string();
                                break;
                            case 2:
                                message.toAddress = reader.string();
                                break;
                            case 3:
                                message.thetaAmount = reader.bytes();
                                break;
                            case 4:
                                message.tfuelAmount = reader.bytes();
                                break;
                            case 5:
                                message.sequence = reader.uint64();
                                break;
                            case 6:
                                message.fee = reader.bytes();
                                break;
                            case 7:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Theta.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            if (!$util.isString(message.chainId))
                                return "chainId: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.thetaAmount != null && message.hasOwnProperty("thetaAmount"))
                            if (!(message.thetaAmount && typeof message.thetaAmount.length === "number" || $util.isString(message.thetaAmount)))
                                return "thetaAmount: buffer expected";
                        if (message.tfuelAmount != null && message.hasOwnProperty("tfuelAmount"))
                            if (!(message.tfuelAmount && typeof message.tfuelAmount.length === "number" || $util.isString(message.tfuelAmount)))
                                return "tfuelAmount: buffer expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                                return "sequence: integer|Long expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!(message.fee && typeof message.fee.length === "number" || $util.isString(message.fee)))
                                return "fee: buffer expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Theta.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Theta.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Theta.Proto.SigningInput();
                        if (object.chainId != null)
                            message.chainId = String(object.chainId);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.thetaAmount != null)
                            if (typeof object.thetaAmount === "string")
                                $util.base64.decode(object.thetaAmount, message.thetaAmount = $util.newBuffer($util.base64.length(object.thetaAmount)), 0);
                            else if (object.thetaAmount.length)
                                message.thetaAmount = object.thetaAmount;
                        if (object.tfuelAmount != null)
                            if (typeof object.tfuelAmount === "string")
                                $util.base64.decode(object.tfuelAmount, message.tfuelAmount = $util.newBuffer($util.base64.length(object.tfuelAmount)), 0);
                            else if (object.tfuelAmount.length)
                                message.tfuelAmount = object.tfuelAmount;
                        if (object.sequence != null)
                            if ($util.Long)
                                (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
                            else if (typeof object.sequence === "string")
                                message.sequence = parseInt(object.sequence, 10);
                            else if (typeof object.sequence === "number")
                                message.sequence = object.sequence;
                            else if (typeof object.sequence === "object")
                                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
                        if (object.fee != null)
                            if (typeof object.fee === "string")
                                $util.base64.decode(object.fee, message.fee = $util.newBuffer($util.base64.length(object.fee)), 0);
                            else if (object.fee.length)
                                message.fee = object.fee;
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Theta.Proto.SigningInput
                     * @static
                     * @param {TW.Theta.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.chainId = "";
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.thetaAmount = "";
                            else {
                                object.thetaAmount = [];
                                if (options.bytes !== Array)
                                    object.thetaAmount = $util.newBuffer(object.thetaAmount);
                            }
                            if (options.bytes === String)
                                object.tfuelAmount = "";
                            else {
                                object.tfuelAmount = [];
                                if (options.bytes !== Array)
                                    object.tfuelAmount = $util.newBuffer(object.tfuelAmount);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sequence = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.fee = "";
                            else {
                                object.fee = [];
                                if (options.bytes !== Array)
                                    object.fee = $util.newBuffer(object.fee);
                            }
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.chainId != null && message.hasOwnProperty("chainId"))
                            object.chainId = message.chainId;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.thetaAmount != null && message.hasOwnProperty("thetaAmount"))
                            object.thetaAmount = options.bytes === String ? $util.base64.encode(message.thetaAmount, 0, message.thetaAmount.length) : options.bytes === Array ? Array.prototype.slice.call(message.thetaAmount) : message.thetaAmount;
                        if (message.tfuelAmount != null && message.hasOwnProperty("tfuelAmount"))
                            object.tfuelAmount = options.bytes === String ? $util.base64.encode(message.tfuelAmount, 0, message.tfuelAmount.length) : options.bytes === Array ? Array.prototype.slice.call(message.tfuelAmount) : message.tfuelAmount;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (typeof message.sequence === "number")
                                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                            else
                                object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true) : message.sequence;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            object.fee = options.bytes === String ? $util.base64.encode(message.fee, 0, message.fee.length) : options.bytes === Array ? Array.prototype.slice.call(message.fee) : message.fee;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Theta.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Theta.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] Signed and encoded transaction bytes
                     * @property {Uint8Array|null} [signature] Signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Theta.Proto
                     * @classdesc Transaction signing output
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Theta.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Signed and encoded transaction bytes
                     * @member {Uint8Array} encoded
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * Signature
                     * @member {Uint8Array} signature
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {TW.Theta.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Theta.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Theta.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {TW.Theta.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Theta.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {TW.Theta.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Theta.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Theta.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Theta.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Theta.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Theta.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Theta.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @static
                     * @param {TW.Theta.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Theta.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Theta;
        })();
    
        TW.Tron = (function() {
    
            /**
             * Namespace Tron.
             * @memberof TW
             * @namespace
             */
            var Tron = {};
    
            Tron.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Tron
                 * @namespace
                 */
                var Proto = {};
    
                Proto.TransferContract = (function() {
    
                    /**
                     * Properties of a TransferContract.
                     * @memberof TW.Tron.Proto
                     * @interface ITransferContract
                     * @property {string|null} [ownerAddress] TransferContract ownerAddress
                     * @property {string|null} [toAddress] TransferContract toAddress
                     * @property {Long|null} [amount] TransferContract amount
                     */
    
                    /**
                     * Constructs a new TransferContract.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a TransferContract.
                     * @implements ITransferContract
                     * @constructor
                     * @param {TW.Tron.Proto.ITransferContract=} [properties] Properties to set
                     */
                    function TransferContract(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransferContract ownerAddress.
                     * @member {string} ownerAddress
                     * @memberof TW.Tron.Proto.TransferContract
                     * @instance
                     */
                    TransferContract.prototype.ownerAddress = "";
    
                    /**
                     * TransferContract toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Tron.Proto.TransferContract
                     * @instance
                     */
                    TransferContract.prototype.toAddress = "";
    
                    /**
                     * TransferContract amount.
                     * @member {Long} amount
                     * @memberof TW.Tron.Proto.TransferContract
                     * @instance
                     */
                    TransferContract.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TransferContract instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {TW.Tron.Proto.ITransferContract=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.TransferContract} TransferContract instance
                     */
                    TransferContract.create = function create(properties) {
                        return new TransferContract(properties);
                    };
    
                    /**
                     * Encodes the specified TransferContract message. Does not implicitly {@link TW.Tron.Proto.TransferContract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {TW.Tron.Proto.ITransferContract} message TransferContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransferContract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ownerAddress);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.toAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TransferContract message, length delimited. Does not implicitly {@link TW.Tron.Proto.TransferContract.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {TW.Tron.Proto.ITransferContract} message TransferContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransferContract.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TransferContract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.TransferContract} TransferContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransferContract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.TransferContract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.ownerAddress = reader.string();
                                break;
                            case 2:
                                message.toAddress = reader.string();
                                break;
                            case 3:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TransferContract message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tron.Proto.TransferContract} TransferContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransferContract.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TransferContract message.
                     * @function verify
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransferContract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            if (!$util.isString(message.ownerAddress))
                                return "ownerAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransferContract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.TransferContract} TransferContract
                     */
                    TransferContract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.TransferContract)
                            return object;
                        var message = new $root.TW.Tron.Proto.TransferContract();
                        if (object.ownerAddress != null)
                            message.ownerAddress = String(object.ownerAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransferContract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.TransferContract
                     * @static
                     * @param {TW.Tron.Proto.TransferContract} message TransferContract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransferContract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.ownerAddress = "";
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            object.ownerAddress = message.ownerAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TransferContract to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.TransferContract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransferContract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransferContract;
                })();
    
                Proto.TransferAssetContract = (function() {
    
                    /**
                     * Properties of a TransferAssetContract.
                     * @memberof TW.Tron.Proto
                     * @interface ITransferAssetContract
                     * @property {string|null} [assetName] TransferAssetContract assetName
                     * @property {string|null} [ownerAddress] TransferAssetContract ownerAddress
                     * @property {string|null} [toAddress] TransferAssetContract toAddress
                     * @property {Long|null} [amount] TransferAssetContract amount
                     */
    
                    /**
                     * Constructs a new TransferAssetContract.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a TransferAssetContract.
                     * @implements ITransferAssetContract
                     * @constructor
                     * @param {TW.Tron.Proto.ITransferAssetContract=} [properties] Properties to set
                     */
                    function TransferAssetContract(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TransferAssetContract assetName.
                     * @member {string} assetName
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @instance
                     */
                    TransferAssetContract.prototype.assetName = "";
    
                    /**
                     * TransferAssetContract ownerAddress.
                     * @member {string} ownerAddress
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @instance
                     */
                    TransferAssetContract.prototype.ownerAddress = "";
    
                    /**
                     * TransferAssetContract toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @instance
                     */
                    TransferAssetContract.prototype.toAddress = "";
    
                    /**
                     * TransferAssetContract amount.
                     * @member {Long} amount
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @instance
                     */
                    TransferAssetContract.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Creates a new TransferAssetContract instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {TW.Tron.Proto.ITransferAssetContract=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.TransferAssetContract} TransferAssetContract instance
                     */
                    TransferAssetContract.create = function create(properties) {
                        return new TransferAssetContract(properties);
                    };
    
                    /**
                     * Encodes the specified TransferAssetContract message. Does not implicitly {@link TW.Tron.Proto.TransferAssetContract.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {TW.Tron.Proto.ITransferAssetContract} message TransferAssetContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransferAssetContract.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.assetName != null && message.hasOwnProperty("assetName"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.assetName);
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.ownerAddress);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.toAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.amount);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TransferAssetContract message, length delimited. Does not implicitly {@link TW.Tron.Proto.TransferAssetContract.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {TW.Tron.Proto.ITransferAssetContract} message TransferAssetContract message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TransferAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TransferAssetContract message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.TransferAssetContract} TransferAssetContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransferAssetContract.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.TransferAssetContract();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.assetName = reader.string();
                                break;
                            case 2:
                                message.ownerAddress = reader.string();
                                break;
                            case 3:
                                message.toAddress = reader.string();
                                break;
                            case 4:
                                message.amount = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TransferAssetContract message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tron.Proto.TransferAssetContract} TransferAssetContract
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TransferAssetContract.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TransferAssetContract message.
                     * @function verify
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TransferAssetContract.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.assetName != null && message.hasOwnProperty("assetName"))
                            if (!$util.isString(message.assetName))
                                return "assetName: string expected";
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            if (!$util.isString(message.ownerAddress))
                                return "ownerAddress: string expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a TransferAssetContract message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.TransferAssetContract} TransferAssetContract
                     */
                    TransferAssetContract.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.TransferAssetContract)
                            return object;
                        var message = new $root.TW.Tron.Proto.TransferAssetContract();
                        if (object.assetName != null)
                            message.assetName = String(object.assetName);
                        if (object.ownerAddress != null)
                            message.ownerAddress = String(object.ownerAddress);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TransferAssetContract message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @static
                     * @param {TW.Tron.Proto.TransferAssetContract} message TransferAssetContract
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TransferAssetContract.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.assetName = "";
                            object.ownerAddress = "";
                            object.toAddress = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                        }
                        if (message.assetName != null && message.hasOwnProperty("assetName"))
                            object.assetName = message.assetName;
                        if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                            object.ownerAddress = message.ownerAddress;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        return object;
                    };
    
                    /**
                     * Converts this TransferAssetContract to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.TransferAssetContract
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TransferAssetContract.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TransferAssetContract;
                })();
    
                Proto.BlockHeader = (function() {
    
                    /**
                     * Properties of a BlockHeader.
                     * @memberof TW.Tron.Proto
                     * @interface IBlockHeader
                     * @property {Long|null} [timestamp] BlockHeader timestamp
                     * @property {Uint8Array|null} [txTrieRoot] BlockHeader txTrieRoot
                     * @property {Uint8Array|null} [parentHash] BlockHeader parentHash
                     * @property {Long|null} [number] BlockHeader number
                     * @property {Uint8Array|null} [witnessAddress] BlockHeader witnessAddress
                     * @property {number|null} [version] BlockHeader version
                     */
    
                    /**
                     * Constructs a new BlockHeader.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a BlockHeader.
                     * @implements IBlockHeader
                     * @constructor
                     * @param {TW.Tron.Proto.IBlockHeader=} [properties] Properties to set
                     */
                    function BlockHeader(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * BlockHeader timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     */
                    BlockHeader.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * BlockHeader txTrieRoot.
                     * @member {Uint8Array} txTrieRoot
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     */
                    BlockHeader.prototype.txTrieRoot = $util.newBuffer([]);
    
                    /**
                     * BlockHeader parentHash.
                     * @member {Uint8Array} parentHash
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     */
                    BlockHeader.prototype.parentHash = $util.newBuffer([]);
    
                    /**
                     * BlockHeader number.
                     * @member {Long} number
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     */
                    BlockHeader.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * BlockHeader witnessAddress.
                     * @member {Uint8Array} witnessAddress
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     */
                    BlockHeader.prototype.witnessAddress = $util.newBuffer([]);
    
                    /**
                     * BlockHeader version.
                     * @member {number} version
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     */
                    BlockHeader.prototype.version = 0;
    
                    /**
                     * Creates a new BlockHeader instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {TW.Tron.Proto.IBlockHeader=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.BlockHeader} BlockHeader instance
                     */
                    BlockHeader.create = function create(properties) {
                        return new BlockHeader(properties);
                    };
    
                    /**
                     * Encodes the specified BlockHeader message. Does not implicitly {@link TW.Tron.Proto.BlockHeader.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {TW.Tron.Proto.IBlockHeader} message BlockHeader message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BlockHeader.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
                        if (message.txTrieRoot != null && message.hasOwnProperty("txTrieRoot"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.txTrieRoot);
                        if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.parentHash);
                        if (message.number != null && message.hasOwnProperty("number"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.number);
                        if (message.witnessAddress != null && message.hasOwnProperty("witnessAddress"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.witnessAddress);
                        if (message.version != null && message.hasOwnProperty("version"))
                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.version);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified BlockHeader message, length delimited. Does not implicitly {@link TW.Tron.Proto.BlockHeader.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {TW.Tron.Proto.IBlockHeader} message BlockHeader message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    BlockHeader.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a BlockHeader message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.BlockHeader} BlockHeader
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BlockHeader.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.BlockHeader();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.timestamp = reader.int64();
                                break;
                            case 2:
                                message.txTrieRoot = reader.bytes();
                                break;
                            case 3:
                                message.parentHash = reader.bytes();
                                break;
                            case 7:
                                message.number = reader.int64();
                                break;
                            case 9:
                                message.witnessAddress = reader.bytes();
                                break;
                            case 10:
                                message.version = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a BlockHeader message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tron.Proto.BlockHeader} BlockHeader
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    BlockHeader.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a BlockHeader message.
                     * @function verify
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    BlockHeader.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.txTrieRoot != null && message.hasOwnProperty("txTrieRoot"))
                            if (!(message.txTrieRoot && typeof message.txTrieRoot.length === "number" || $util.isString(message.txTrieRoot)))
                                return "txTrieRoot: buffer expected";
                        if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                            if (!(message.parentHash && typeof message.parentHash.length === "number" || $util.isString(message.parentHash)))
                                return "parentHash: buffer expected";
                        if (message.number != null && message.hasOwnProperty("number"))
                            if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                                return "number: integer|Long expected";
                        if (message.witnessAddress != null && message.hasOwnProperty("witnessAddress"))
                            if (!(message.witnessAddress && typeof message.witnessAddress.length === "number" || $util.isString(message.witnessAddress)))
                                return "witnessAddress: buffer expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a BlockHeader message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.BlockHeader} BlockHeader
                     */
                    BlockHeader.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.BlockHeader)
                            return object;
                        var message = new $root.TW.Tron.Proto.BlockHeader();
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.txTrieRoot != null)
                            if (typeof object.txTrieRoot === "string")
                                $util.base64.decode(object.txTrieRoot, message.txTrieRoot = $util.newBuffer($util.base64.length(object.txTrieRoot)), 0);
                            else if (object.txTrieRoot.length)
                                message.txTrieRoot = object.txTrieRoot;
                        if (object.parentHash != null)
                            if (typeof object.parentHash === "string")
                                $util.base64.decode(object.parentHash, message.parentHash = $util.newBuffer($util.base64.length(object.parentHash)), 0);
                            else if (object.parentHash.length)
                                message.parentHash = object.parentHash;
                        if (object.number != null)
                            if ($util.Long)
                                (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                            else if (typeof object.number === "string")
                                message.number = parseInt(object.number, 10);
                            else if (typeof object.number === "number")
                                message.number = object.number;
                            else if (typeof object.number === "object")
                                message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                        if (object.witnessAddress != null)
                            if (typeof object.witnessAddress === "string")
                                $util.base64.decode(object.witnessAddress, message.witnessAddress = $util.newBuffer($util.base64.length(object.witnessAddress)), 0);
                            else if (object.witnessAddress.length)
                                message.witnessAddress = object.witnessAddress;
                        if (object.version != null)
                            message.version = object.version | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a BlockHeader message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @static
                     * @param {TW.Tron.Proto.BlockHeader} message BlockHeader
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    BlockHeader.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.txTrieRoot = "";
                            else {
                                object.txTrieRoot = [];
                                if (options.bytes !== Array)
                                    object.txTrieRoot = $util.newBuffer(object.txTrieRoot);
                            }
                            if (options.bytes === String)
                                object.parentHash = "";
                            else {
                                object.parentHash = [];
                                if (options.bytes !== Array)
                                    object.parentHash = $util.newBuffer(object.parentHash);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.number = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.witnessAddress = "";
                            else {
                                object.witnessAddress = [];
                                if (options.bytes !== Array)
                                    object.witnessAddress = $util.newBuffer(object.witnessAddress);
                            }
                            object.version = 0;
                        }
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.txTrieRoot != null && message.hasOwnProperty("txTrieRoot"))
                            object.txTrieRoot = options.bytes === String ? $util.base64.encode(message.txTrieRoot, 0, message.txTrieRoot.length) : options.bytes === Array ? Array.prototype.slice.call(message.txTrieRoot) : message.txTrieRoot;
                        if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                            object.parentHash = options.bytes === String ? $util.base64.encode(message.parentHash, 0, message.parentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentHash) : message.parentHash;
                        if (message.number != null && message.hasOwnProperty("number"))
                            if (typeof message.number === "number")
                                object.number = options.longs === String ? String(message.number) : message.number;
                            else
                                object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                        if (message.witnessAddress != null && message.hasOwnProperty("witnessAddress"))
                            object.witnessAddress = options.bytes === String ? $util.base64.encode(message.witnessAddress, 0, message.witnessAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.witnessAddress) : message.witnessAddress;
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        return object;
                    };
    
                    /**
                     * Converts this BlockHeader to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.BlockHeader
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    BlockHeader.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return BlockHeader;
                })();
    
                Proto.Transaction = (function() {
    
                    /**
                     * Properties of a Transaction.
                     * @memberof TW.Tron.Proto
                     * @interface ITransaction
                     * @property {Long|null} [timestamp] Transaction timestamp
                     * @property {Long|null} [expiration] Transaction expiration
                     * @property {TW.Tron.Proto.IBlockHeader|null} [blockHeader] Transaction blockHeader
                     * @property {TW.Tron.Proto.ITransferContract|null} [transfer] Transaction transfer
                     * @property {TW.Tron.Proto.ITransferAssetContract|null} [transferAsset] Transaction transferAsset
                     */
    
                    /**
                     * Constructs a new Transaction.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a Transaction.
                     * @implements ITransaction
                     * @constructor
                     * @param {TW.Tron.Proto.ITransaction=} [properties] Properties to set
                     */
                    function Transaction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Transaction timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Transaction expiration.
                     * @member {Long} expiration
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * Transaction blockHeader.
                     * @member {TW.Tron.Proto.IBlockHeader|null|undefined} blockHeader
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.blockHeader = null;
    
                    /**
                     * Transaction transfer.
                     * @member {TW.Tron.Proto.ITransferContract|null|undefined} transfer
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.transfer = null;
    
                    /**
                     * Transaction transferAsset.
                     * @member {TW.Tron.Proto.ITransferAssetContract|null|undefined} transferAsset
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Transaction.prototype.transferAsset = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * Transaction contractOneof.
                     * @member {"transfer"|"transferAsset"|undefined} contractOneof
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     */
                    Object.defineProperty(Transaction.prototype, "contractOneof", {
                        get: $util.oneOfGetter($oneOfFields = ["transfer", "transferAsset"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new Transaction instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {TW.Tron.Proto.ITransaction=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.Transaction} Transaction instance
                     */
                    Transaction.create = function create(properties) {
                        return new Transaction(properties);
                    };
    
                    /**
                     * Encodes the specified Transaction message. Does not implicitly {@link TW.Tron.Proto.Transaction.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {TW.Tron.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
                        if (message.blockHeader != null && message.hasOwnProperty("blockHeader"))
                            $root.TW.Tron.Proto.BlockHeader.encode(message.blockHeader, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.transfer != null && message.hasOwnProperty("transfer"))
                            $root.TW.Tron.Proto.TransferContract.encode(message.transfer, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.transferAsset != null && message.hasOwnProperty("transferAsset"))
                            $root.TW.Tron.Proto.TransferAssetContract.encode(message.transferAsset, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Transaction message, length delimited. Does not implicitly {@link TW.Tron.Proto.Transaction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {TW.Tron.Proto.ITransaction} message Transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.Transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.timestamp = reader.int64();
                                break;
                            case 2:
                                message.expiration = reader.int64();
                                break;
                            case 3:
                                message.blockHeader = $root.TW.Tron.Proto.BlockHeader.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.transfer = $root.TW.Tron.Proto.TransferContract.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.transferAsset = $root.TW.Tron.Proto.TransferAssetContract.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Transaction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tron.Proto.Transaction} Transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Transaction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Transaction message.
                     * @function verify
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                                return "expiration: integer|Long expected";
                        if (message.blockHeader != null && message.hasOwnProperty("blockHeader")) {
                            var error = $root.TW.Tron.Proto.BlockHeader.verify(message.blockHeader);
                            if (error)
                                return "blockHeader." + error;
                        }
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            properties.contractOneof = 1;
                            {
                                var error = $root.TW.Tron.Proto.TransferContract.verify(message.transfer);
                                if (error)
                                    return "transfer." + error;
                            }
                        }
                        if (message.transferAsset != null && message.hasOwnProperty("transferAsset")) {
                            if (properties.contractOneof === 1)
                                return "contractOneof: multiple values";
                            properties.contractOneof = 1;
                            {
                                var error = $root.TW.Tron.Proto.TransferAssetContract.verify(message.transferAsset);
                                if (error)
                                    return "transferAsset." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.Transaction} Transaction
                     */
                    Transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.Transaction)
                            return object;
                        var message = new $root.TW.Tron.Proto.Transaction();
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.expiration != null)
                            if ($util.Long)
                                (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                            else if (typeof object.expiration === "string")
                                message.expiration = parseInt(object.expiration, 10);
                            else if (typeof object.expiration === "number")
                                message.expiration = object.expiration;
                            else if (typeof object.expiration === "object")
                                message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
                        if (object.blockHeader != null) {
                            if (typeof object.blockHeader !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.blockHeader: object expected");
                            message.blockHeader = $root.TW.Tron.Proto.BlockHeader.fromObject(object.blockHeader);
                        }
                        if (object.transfer != null) {
                            if (typeof object.transfer !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.transfer: object expected");
                            message.transfer = $root.TW.Tron.Proto.TransferContract.fromObject(object.transfer);
                        }
                        if (object.transferAsset != null) {
                            if (typeof object.transferAsset !== "object")
                                throw TypeError(".TW.Tron.Proto.Transaction.transferAsset: object expected");
                            message.transferAsset = $root.TW.Tron.Proto.TransferAssetContract.fromObject(object.transferAsset);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.Transaction
                     * @static
                     * @param {TW.Tron.Proto.Transaction} message Transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.expiration = options.longs === String ? "0" : 0;
                            object.blockHeader = null;
                        }
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            if (typeof message.expiration === "number")
                                object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                            else
                                object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
                        if (message.blockHeader != null && message.hasOwnProperty("blockHeader"))
                            object.blockHeader = $root.TW.Tron.Proto.BlockHeader.toObject(message.blockHeader, options);
                        if (message.transfer != null && message.hasOwnProperty("transfer")) {
                            object.transfer = $root.TW.Tron.Proto.TransferContract.toObject(message.transfer, options);
                            if (options.oneofs)
                                object.contractOneof = "transfer";
                        }
                        if (message.transferAsset != null && message.hasOwnProperty("transferAsset")) {
                            object.transferAsset = $root.TW.Tron.Proto.TransferAssetContract.toObject(message.transferAsset, options);
                            if (options.oneofs)
                                object.contractOneof = "transferAsset";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Transaction to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.Transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Transaction;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Tron.Proto
                     * @interface ISigningInput
                     * @property {TW.Tron.Proto.ITransaction|null} [transaction] SigningInput transaction
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Tron.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput transaction.
                     * @member {TW.Tron.Proto.ITransaction|null|undefined} transaction
                     * @memberof TW.Tron.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.transaction = null;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Tron.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {TW.Tron.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Tron.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {TW.Tron.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            $root.TW.Tron.Proto.Transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Tron.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {TW.Tron.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transaction = $root.TW.Tron.Proto.Transaction.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tron.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.transaction != null && message.hasOwnProperty("transaction")) {
                            var error = $root.TW.Tron.Proto.Transaction.verify(message.transaction);
                            if (error)
                                return "transaction." + error;
                        }
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Tron.Proto.SigningInput();
                        if (object.transaction != null) {
                            if (typeof object.transaction !== "object")
                                throw TypeError(".TW.Tron.Proto.SigningInput.transaction: object expected");
                            message.transaction = $root.TW.Tron.Proto.Transaction.fromObject(object.transaction);
                        }
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.SigningInput
                     * @static
                     * @param {TW.Tron.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.transaction = null;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            object.transaction = $root.TW.Tron.Proto.Transaction.toObject(message.transaction, options);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Tron.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [id] SigningOutput id
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     * @property {Uint8Array|null} [refBlockBytes] SigningOutput refBlockBytes
                     * @property {Uint8Array|null} [refBlockHash] SigningOutput refBlockHash
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Tron.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Tron.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput id.
                     * @member {Uint8Array} id
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.id = $util.newBuffer([]);
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * SigningOutput refBlockBytes.
                     * @member {Uint8Array} refBlockBytes
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.refBlockBytes = $util.newBuffer([]);
    
                    /**
                     * SigningOutput refBlockHash.
                     * @member {Uint8Array} refBlockHash
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.refBlockHash = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {TW.Tron.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Tron.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Tron.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {TW.Tron.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        if (message.refBlockBytes != null && message.hasOwnProperty("refBlockBytes"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.refBlockBytes);
                        if (message.refBlockHash != null && message.hasOwnProperty("refBlockHash"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.refBlockHash);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Tron.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {TW.Tron.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Tron.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Tron.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.bytes();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            case 3:
                                message.refBlockBytes = reader.bytes();
                                break;
                            case 4:
                                message.refBlockHash = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Tron.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                                return "id: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.refBlockBytes != null && message.hasOwnProperty("refBlockBytes"))
                            if (!(message.refBlockBytes && typeof message.refBlockBytes.length === "number" || $util.isString(message.refBlockBytes)))
                                return "refBlockBytes: buffer expected";
                        if (message.refBlockHash != null && message.hasOwnProperty("refBlockHash"))
                            if (!(message.refBlockHash && typeof message.refBlockHash.length === "number" || $util.isString(message.refBlockHash)))
                                return "refBlockHash: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Tron.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Tron.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Tron.Proto.SigningOutput();
                        if (object.id != null)
                            if (typeof object.id === "string")
                                $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                            else if (object.id.length)
                                message.id = object.id;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.refBlockBytes != null)
                            if (typeof object.refBlockBytes === "string")
                                $util.base64.decode(object.refBlockBytes, message.refBlockBytes = $util.newBuffer($util.base64.length(object.refBlockBytes)), 0);
                            else if (object.refBlockBytes.length)
                                message.refBlockBytes = object.refBlockBytes;
                        if (object.refBlockHash != null)
                            if (typeof object.refBlockHash === "string")
                                $util.base64.decode(object.refBlockHash, message.refBlockHash = $util.newBuffer($util.base64.length(object.refBlockHash)), 0);
                            else if (object.refBlockHash.length)
                                message.refBlockHash = object.refBlockHash;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @static
                     * @param {TW.Tron.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.id = "";
                            else {
                                object.id = [];
                                if (options.bytes !== Array)
                                    object.id = $util.newBuffer(object.id);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            if (options.bytes === String)
                                object.refBlockBytes = "";
                            else {
                                object.refBlockBytes = [];
                                if (options.bytes !== Array)
                                    object.refBlockBytes = $util.newBuffer(object.refBlockBytes);
                            }
                            if (options.bytes === String)
                                object.refBlockHash = "";
                            else {
                                object.refBlockHash = [];
                                if (options.bytes !== Array)
                                    object.refBlockHash = $util.newBuffer(object.refBlockHash);
                            }
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.refBlockBytes != null && message.hasOwnProperty("refBlockBytes"))
                            object.refBlockBytes = options.bytes === String ? $util.base64.encode(message.refBlockBytes, 0, message.refBlockBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.refBlockBytes) : message.refBlockBytes;
                        if (message.refBlockHash != null && message.hasOwnProperty("refBlockHash"))
                            object.refBlockHash = options.bytes === String ? $util.base64.encode(message.refBlockHash, 0, message.refBlockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.refBlockHash) : message.refBlockHash;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Tron.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Tron;
        })();
    
        TW.VeChain = (function() {
    
            /**
             * Namespace VeChain.
             * @memberof TW
             * @namespace
             */
            var VeChain = {};
    
            VeChain.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.VeChain
                 * @namespace
                 */
                var Proto = {};
    
                Proto.Clause = (function() {
    
                    /**
                     * Properties of a Clause.
                     * @memberof TW.VeChain.Proto
                     * @interface IClause
                     * @property {string|null} [to] Recipient address.
                     * @property {Uint8Array|null} [value] Transaction amount.
                     * @property {Uint8Array|null} [data] Payload data.
                     */
    
                    /**
                     * Constructs a new Clause.
                     * @memberof TW.VeChain.Proto
                     * @classdesc Represents a Clause.
                     * @implements IClause
                     * @constructor
                     * @param {TW.VeChain.Proto.IClause=} [properties] Properties to set
                     */
                    function Clause(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Recipient address.
                     * @member {string} to
                     * @memberof TW.VeChain.Proto.Clause
                     * @instance
                     */
                    Clause.prototype.to = "";
    
                    /**
                     * Transaction amount.
                     * @member {Uint8Array} value
                     * @memberof TW.VeChain.Proto.Clause
                     * @instance
                     */
                    Clause.prototype.value = $util.newBuffer([]);
    
                    /**
                     * Payload data.
                     * @member {Uint8Array} data
                     * @memberof TW.VeChain.Proto.Clause
                     * @instance
                     */
                    Clause.prototype.data = $util.newBuffer([]);
    
                    /**
                     * Creates a new Clause instance using the specified properties.
                     * @function create
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {TW.VeChain.Proto.IClause=} [properties] Properties to set
                     * @returns {TW.VeChain.Proto.Clause} Clause instance
                     */
                    Clause.create = function create(properties) {
                        return new Clause(properties);
                    };
    
                    /**
                     * Encodes the specified Clause message. Does not implicitly {@link TW.VeChain.Proto.Clause.verify|verify} messages.
                     * @function encode
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {TW.VeChain.Proto.IClause} message Clause message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Clause.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.to != null && message.hasOwnProperty("to"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.to);
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                        if (message.data != null && message.hasOwnProperty("data"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Clause message, length delimited. Does not implicitly {@link TW.VeChain.Proto.Clause.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {TW.VeChain.Proto.IClause} message Clause message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Clause.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Clause message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.VeChain.Proto.Clause} Clause
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Clause.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.VeChain.Proto.Clause();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.to = reader.string();
                                break;
                            case 2:
                                message.value = reader.bytes();
                                break;
                            case 3:
                                message.data = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Clause message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.VeChain.Proto.Clause} Clause
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Clause.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Clause message.
                     * @function verify
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Clause.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!$util.isString(message.to))
                                return "to: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                return "value: buffer expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                return "data: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a Clause message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.VeChain.Proto.Clause} Clause
                     */
                    Clause.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.VeChain.Proto.Clause)
                            return object;
                        var message = new $root.TW.VeChain.Proto.Clause();
                        if (object.to != null)
                            message.to = String(object.to);
                        if (object.value != null)
                            if (typeof object.value === "string")
                                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                            else if (object.value.length)
                                message.value = object.value;
                        if (object.data != null)
                            if (typeof object.data === "string")
                                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                            else if (object.data.length)
                                message.data = object.data;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Clause message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.VeChain.Proto.Clause
                     * @static
                     * @param {TW.VeChain.Proto.Clause} message Clause
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Clause.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.to = "";
                            if (options.bytes === String)
                                object.value = "";
                            else {
                                object.value = [];
                                if (options.bytes !== Array)
                                    object.value = $util.newBuffer(object.value);
                            }
                            if (options.bytes === String)
                                object.data = "";
                            else {
                                object.data = [];
                                if (options.bytes !== Array)
                                    object.data = $util.newBuffer(object.data);
                            }
                        }
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = message.to;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                        return object;
                    };
    
                    /**
                     * Converts this Clause to JSON.
                     * @function toJSON
                     * @memberof TW.VeChain.Proto.Clause
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Clause.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Clause;
                })();
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.VeChain.Proto
                     * @interface ISigningInput
                     * @property {number|null} [chainTag] Last byte of the genesis block ID which is used to identify a blockchain to prevent the cross-chain replay attack.
                     * @property {Long|null} [blockRef] Reference to a specific block.
                     * @property {number|null} [expiration] How long, in terms of the number of blocks, the transaction will be allowed to be mined in VeChainThor.
                     * @property {Array.<TW.VeChain.Proto.IClause>|null} [clauses] by the transaction sender.
                     * @property {number|null} [gasPriceCoef] Coefficient used to calculate the gas price for the transaction.
                     * @property {Long|null} [gas] Maximum amount of gas allowed to pay for the transaction.
                     * @property {Uint8Array|null} [dependsOn] ID of the transaction on which the current transaction depends.
                     * @property {Long|null} [nonce] Number set by user.
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.VeChain.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.VeChain.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        this.clauses = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Last byte of the genesis block ID which is used to identify a blockchain to prevent the cross-chain replay attack.
                     * @member {number} chainTag
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.chainTag = 0;
    
                    /**
                     * Reference to a specific block.
                     * @member {Long} blockRef
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.blockRef = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * How long, in terms of the number of blocks, the transaction will be allowed to be mined in VeChainThor.
                     * @member {number} expiration
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.expiration = 0;
    
                    /**
                     * by the transaction sender.
                     * @member {Array.<TW.VeChain.Proto.IClause>} clauses
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.clauses = $util.emptyArray;
    
                    /**
                     * Coefficient used to calculate the gas price for the transaction.
                     * @member {number} gasPriceCoef
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPriceCoef = 0;
    
                    /**
                     * Maximum amount of gas allowed to pay for the transaction.
                     * @member {Long} gas
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * ID of the transaction on which the current transaction depends.
                     * @member {Uint8Array} dependsOn
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.dependsOn = $util.newBuffer([]);
    
                    /**
                     * Number set by user.
                     * @member {Long} nonce
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {TW.VeChain.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.VeChain.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.VeChain.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {TW.VeChain.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chainTag != null && message.hasOwnProperty("chainTag"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.chainTag);
                        if (message.blockRef != null && message.hasOwnProperty("blockRef"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.blockRef);
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.expiration);
                        if (message.clauses != null && message.clauses.length)
                            for (var i = 0; i < message.clauses.length; ++i)
                                $root.TW.VeChain.Proto.Clause.encode(message.clauses[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.gasPriceCoef != null && message.hasOwnProperty("gasPriceCoef"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.gasPriceCoef);
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.gas);
                        if (message.dependsOn != null && message.hasOwnProperty("dependsOn"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.dependsOn);
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.nonce);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.VeChain.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {TW.VeChain.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.VeChain.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.VeChain.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chainTag = reader.uint32();
                                break;
                            case 2:
                                message.blockRef = reader.uint64();
                                break;
                            case 3:
                                message.expiration = reader.uint32();
                                break;
                            case 4:
                                if (!(message.clauses && message.clauses.length))
                                    message.clauses = [];
                                message.clauses.push($root.TW.VeChain.Proto.Clause.decode(reader, reader.uint32()));
                                break;
                            case 5:
                                message.gasPriceCoef = reader.uint32();
                                break;
                            case 6:
                                message.gas = reader.uint64();
                                break;
                            case 7:
                                message.dependsOn = reader.bytes();
                                break;
                            case 8:
                                message.nonce = reader.uint64();
                                break;
                            case 9:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.VeChain.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chainTag != null && message.hasOwnProperty("chainTag"))
                            if (!$util.isInteger(message.chainTag))
                                return "chainTag: integer expected";
                        if (message.blockRef != null && message.hasOwnProperty("blockRef"))
                            if (!$util.isInteger(message.blockRef) && !(message.blockRef && $util.isInteger(message.blockRef.low) && $util.isInteger(message.blockRef.high)))
                                return "blockRef: integer|Long expected";
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            if (!$util.isInteger(message.expiration))
                                return "expiration: integer expected";
                        if (message.clauses != null && message.hasOwnProperty("clauses")) {
                            if (!Array.isArray(message.clauses))
                                return "clauses: array expected";
                            for (var i = 0; i < message.clauses.length; ++i) {
                                var error = $root.TW.VeChain.Proto.Clause.verify(message.clauses[i]);
                                if (error)
                                    return "clauses." + error;
                            }
                        }
                        if (message.gasPriceCoef != null && message.hasOwnProperty("gasPriceCoef"))
                            if (!$util.isInteger(message.gasPriceCoef))
                                return "gasPriceCoef: integer expected";
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            if (!$util.isInteger(message.gas) && !(message.gas && $util.isInteger(message.gas.low) && $util.isInteger(message.gas.high)))
                                return "gas: integer|Long expected";
                        if (message.dependsOn != null && message.hasOwnProperty("dependsOn"))
                            if (!(message.dependsOn && typeof message.dependsOn.length === "number" || $util.isString(message.dependsOn)))
                                return "dependsOn: buffer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.VeChain.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.VeChain.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.VeChain.Proto.SigningInput();
                        if (object.chainTag != null)
                            message.chainTag = object.chainTag >>> 0;
                        if (object.blockRef != null)
                            if ($util.Long)
                                (message.blockRef = $util.Long.fromValue(object.blockRef)).unsigned = true;
                            else if (typeof object.blockRef === "string")
                                message.blockRef = parseInt(object.blockRef, 10);
                            else if (typeof object.blockRef === "number")
                                message.blockRef = object.blockRef;
                            else if (typeof object.blockRef === "object")
                                message.blockRef = new $util.LongBits(object.blockRef.low >>> 0, object.blockRef.high >>> 0).toNumber(true);
                        if (object.expiration != null)
                            message.expiration = object.expiration >>> 0;
                        if (object.clauses) {
                            if (!Array.isArray(object.clauses))
                                throw TypeError(".TW.VeChain.Proto.SigningInput.clauses: array expected");
                            message.clauses = [];
                            for (var i = 0; i < object.clauses.length; ++i) {
                                if (typeof object.clauses[i] !== "object")
                                    throw TypeError(".TW.VeChain.Proto.SigningInput.clauses: object expected");
                                message.clauses[i] = $root.TW.VeChain.Proto.Clause.fromObject(object.clauses[i]);
                            }
                        }
                        if (object.gasPriceCoef != null)
                            message.gasPriceCoef = object.gasPriceCoef >>> 0;
                        if (object.gas != null)
                            if ($util.Long)
                                (message.gas = $util.Long.fromValue(object.gas)).unsigned = true;
                            else if (typeof object.gas === "string")
                                message.gas = parseInt(object.gas, 10);
                            else if (typeof object.gas === "number")
                                message.gas = object.gas;
                            else if (typeof object.gas === "object")
                                message.gas = new $util.LongBits(object.gas.low >>> 0, object.gas.high >>> 0).toNumber(true);
                        if (object.dependsOn != null)
                            if (typeof object.dependsOn === "string")
                                $util.base64.decode(object.dependsOn, message.dependsOn = $util.newBuffer($util.base64.length(object.dependsOn)), 0);
                            else if (object.dependsOn.length)
                                message.dependsOn = object.dependsOn;
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @static
                     * @param {TW.VeChain.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.clauses = [];
                        if (options.defaults) {
                            object.chainTag = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.blockRef = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.blockRef = options.longs === String ? "0" : 0;
                            object.expiration = 0;
                            object.gasPriceCoef = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gas = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gas = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.dependsOn = "";
                            else {
                                object.dependsOn = [];
                                if (options.bytes !== Array)
                                    object.dependsOn = $util.newBuffer(object.dependsOn);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.chainTag != null && message.hasOwnProperty("chainTag"))
                            object.chainTag = message.chainTag;
                        if (message.blockRef != null && message.hasOwnProperty("blockRef"))
                            if (typeof message.blockRef === "number")
                                object.blockRef = options.longs === String ? String(message.blockRef) : message.blockRef;
                            else
                                object.blockRef = options.longs === String ? $util.Long.prototype.toString.call(message.blockRef) : options.longs === Number ? new $util.LongBits(message.blockRef.low >>> 0, message.blockRef.high >>> 0).toNumber(true) : message.blockRef;
                        if (message.expiration != null && message.hasOwnProperty("expiration"))
                            object.expiration = message.expiration;
                        if (message.clauses && message.clauses.length) {
                            object.clauses = [];
                            for (var j = 0; j < message.clauses.length; ++j)
                                object.clauses[j] = $root.TW.VeChain.Proto.Clause.toObject(message.clauses[j], options);
                        }
                        if (message.gasPriceCoef != null && message.hasOwnProperty("gasPriceCoef"))
                            object.gasPriceCoef = message.gasPriceCoef;
                        if (message.gas != null && message.hasOwnProperty("gas"))
                            if (typeof message.gas === "number")
                                object.gas = options.longs === String ? String(message.gas) : message.gas;
                            else
                                object.gas = options.longs === String ? $util.Long.prototype.toString.call(message.gas) : options.longs === Number ? new $util.LongBits(message.gas.low >>> 0, message.gas.high >>> 0).toNumber(true) : message.gas;
                        if (message.dependsOn != null && message.hasOwnProperty("dependsOn"))
                            object.dependsOn = options.bytes === String ? $util.base64.encode(message.dependsOn, 0, message.dependsOn.length) : options.bytes === Array ? Array.prototype.slice.call(message.dependsOn) : message.dependsOn;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.VeChain.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.VeChain.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [encoded] SigningOutput encoded
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.VeChain.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.VeChain.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput encoded.
                     * @member {Uint8Array} encoded
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.encoded = $util.newBuffer([]);
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {TW.VeChain.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.VeChain.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.VeChain.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {TW.VeChain.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encoded);
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.VeChain.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {TW.VeChain.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.VeChain.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.VeChain.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.encoded = reader.bytes();
                                break;
                            case 2:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.VeChain.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            if (!(message.encoded && typeof message.encoded.length === "number" || $util.isString(message.encoded)))
                                return "encoded: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.VeChain.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.VeChain.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.VeChain.Proto.SigningOutput();
                        if (object.encoded != null)
                            if (typeof object.encoded === "string")
                                $util.base64.decode(object.encoded, message.encoded = $util.newBuffer($util.base64.length(object.encoded)), 0);
                            else if (object.encoded.length)
                                message.encoded = object.encoded;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @static
                     * @param {TW.VeChain.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.encoded = "";
                            else {
                                object.encoded = [];
                                if (options.bytes !== Array)
                                    object.encoded = $util.newBuffer(object.encoded);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.encoded != null && message.hasOwnProperty("encoded"))
                            object.encoded = options.bytes === String ? $util.base64.encode(message.encoded, 0, message.encoded.length) : options.bytes === Array ? Array.prototype.slice.call(message.encoded) : message.encoded;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.VeChain.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return VeChain;
        })();
    
        TW.Waves = (function() {
    
            /**
             * Namespace Waves.
             * @memberof TW
             * @namespace
             */
            var Waves = {};
    
            Waves.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Waves
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Waves.Proto
                     * @interface ISigningInput
                     * @property {Long|null} [amount] SigningInput amount
                     * @property {string|null} [asset] SigningInput asset
                     * @property {Long|null} [fee] SigningInput fee
                     * @property {string|null} [feeAsset] SigningInput feeAsset
                     * @property {string|null} [to] SigningInput to
                     * @property {Uint8Array|null} [attachment] SigningInput attachment
                     * @property {Long|null} [timestamp] SigningInput timestamp
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Waves.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Waves.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput amount.
                     * @member {Long} amount
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput asset.
                     * @member {string} asset
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.asset = "";
    
                    /**
                     * SigningInput fee.
                     * @member {Long} fee
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput feeAsset.
                     * @member {string} feeAsset
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.feeAsset = "";
    
                    /**
                     * SigningInput to.
                     * @member {string} to
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.to = "";
    
                    /**
                     * SigningInput attachment.
                     * @member {Uint8Array} attachment
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.attachment = $util.newBuffer([]);
    
                    /**
                     * SigningInput timestamp.
                     * @member {Long} timestamp
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {TW.Waves.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Waves.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Waves.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {TW.Waves.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.amount);
                        if (message.asset != null && message.hasOwnProperty("asset"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.asset);
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.fee);
                        if (message.feeAsset != null && message.hasOwnProperty("feeAsset"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.feeAsset);
                        if (message.to != null && message.hasOwnProperty("to"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.to);
                        if (message.attachment != null && message.hasOwnProperty("attachment"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.attachment);
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int64(message.timestamp);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.privateKey);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Waves.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {TW.Waves.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Waves.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Waves.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = reader.int64();
                                break;
                            case 2:
                                message.asset = reader.string();
                                break;
                            case 3:
                                message.fee = reader.int64();
                                break;
                            case 4:
                                message.feeAsset = reader.string();
                                break;
                            case 5:
                                message.to = reader.string();
                                break;
                            case 6:
                                message.attachment = reader.bytes();
                                break;
                            case 7:
                                message.timestamp = reader.int64();
                                break;
                            case 8:
                                message.privateKey = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Waves.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                                return "amount: integer|Long expected";
                        if (message.asset != null && message.hasOwnProperty("asset"))
                            if (!$util.isString(message.asset))
                                return "asset: string expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        if (message.feeAsset != null && message.hasOwnProperty("feeAsset"))
                            if (!$util.isString(message.feeAsset))
                                return "feeAsset: string expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!$util.isString(message.to))
                                return "to: string expected";
                        if (message.attachment != null && message.hasOwnProperty("attachment"))
                            if (!(message.attachment && typeof message.attachment.length === "number" || $util.isString(message.attachment)))
                                return "attachment: buffer expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Waves.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Waves.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Waves.Proto.SigningInput();
                        if (object.amount != null)
                            if ($util.Long)
                                (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                            else if (typeof object.amount === "string")
                                message.amount = parseInt(object.amount, 10);
                            else if (typeof object.amount === "number")
                                message.amount = object.amount;
                            else if (typeof object.amount === "object")
                                message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
                        if (object.asset != null)
                            message.asset = String(object.asset);
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                        if (object.feeAsset != null)
                            message.feeAsset = String(object.feeAsset);
                        if (object.to != null)
                            message.to = String(object.to);
                        if (object.attachment != null)
                            if (typeof object.attachment === "string")
                                $util.base64.decode(object.attachment, message.attachment = $util.newBuffer($util.base64.length(object.attachment)), 0);
                            else if (object.attachment.length)
                                message.attachment = object.attachment;
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Waves.Proto.SigningInput
                     * @static
                     * @param {TW.Waves.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amount = options.longs === String ? "0" : 0;
                            object.asset = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                            object.feeAsset = "";
                            object.to = "";
                            if (options.bytes === String)
                                object.attachment = "";
                            else {
                                object.attachment = [];
                                if (options.bytes !== Array)
                                    object.attachment = $util.newBuffer(object.attachment);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (typeof message.amount === "number")
                                object.amount = options.longs === String ? String(message.amount) : message.amount;
                            else
                                object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
                        if (message.asset != null && message.hasOwnProperty("asset"))
                            object.asset = message.asset;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                        if (message.feeAsset != null && message.hasOwnProperty("feeAsset"))
                            object.feeAsset = message.feeAsset;
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = message.to;
                        if (message.attachment != null && message.hasOwnProperty("attachment"))
                            object.attachment = options.bytes === String ? $util.base64.encode(message.attachment, 0, message.attachment.length) : options.bytes === Array ? Array.prototype.slice.call(message.attachment) : message.attachment;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Waves.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Waves.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     * @property {string|null} [json] SigningOutput json
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Waves.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Waves.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * SigningOutput json.
                     * @member {string} json
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.json = "";
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {TW.Waves.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Waves.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Waves.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {TW.Waves.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
                        if (message.json != null && message.hasOwnProperty("json"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.json);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Waves.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {TW.Waves.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Waves.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Waves.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signature = reader.bytes();
                                break;
                            case 2:
                                message.json = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Waves.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        if (message.json != null && message.hasOwnProperty("json"))
                            if (!$util.isString(message.json))
                                return "json: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Waves.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Waves.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Waves.Proto.SigningOutput();
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        if (object.json != null)
                            message.json = String(object.json);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @static
                     * @param {TW.Waves.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                            object.json = "";
                        }
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        if (message.json != null && message.hasOwnProperty("json"))
                            object.json = message.json;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Waves.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Waves;
        })();
    
        TW.Zilliqa = (function() {
    
            /**
             * Namespace Zilliqa.
             * @memberof TW
             * @namespace
             */
            var Zilliqa = {};
    
            Zilliqa.Proto = (function() {
    
                /**
                 * Namespace Proto.
                 * @memberof TW.Zilliqa
                 * @namespace
                 */
                var Proto = {};
    
                Proto.SigningInput = (function() {
    
                    /**
                     * Properties of a SigningInput.
                     * @memberof TW.Zilliqa.Proto
                     * @interface ISigningInput
                     * @property {number|null} [version] SigningInput version
                     * @property {Long|null} [nonce] SigningInput nonce
                     * @property {string|null} [toAddress] SigningInput toAddress
                     * @property {Uint8Array|null} [amount] SigningInput amount
                     * @property {Uint8Array|null} [gasPrice] SigningInput gasPrice
                     * @property {Long|null} [gasLimit] SigningInput gasLimit
                     * @property {Uint8Array|null} [privateKey] SigningInput privateKey
                     * @property {Uint8Array|null} [code] SigningInput code
                     * @property {Uint8Array|null} [data] SigningInput data
                     */
    
                    /**
                     * Constructs a new SigningInput.
                     * @memberof TW.Zilliqa.Proto
                     * @classdesc Represents a SigningInput.
                     * @implements ISigningInput
                     * @constructor
                     * @param {TW.Zilliqa.Proto.ISigningInput=} [properties] Properties to set
                     */
                    function SigningInput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningInput version.
                     * @member {number} version
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.version = 0;
    
                    /**
                     * SigningInput nonce.
                     * @member {Long} nonce
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput toAddress.
                     * @member {string} toAddress
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.toAddress = "";
    
                    /**
                     * SigningInput amount.
                     * @member {Uint8Array} amount
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.amount = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasPrice.
                     * @member {Uint8Array} gasPrice
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasPrice = $util.newBuffer([]);
    
                    /**
                     * SigningInput gasLimit.
                     * @member {Long} gasLimit
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.gasLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * SigningInput privateKey.
                     * @member {Uint8Array} privateKey
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.privateKey = $util.newBuffer([]);
    
                    /**
                     * SigningInput code.
                     * @member {Uint8Array} code
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.code = $util.newBuffer([]);
    
                    /**
                     * SigningInput data.
                     * @member {Uint8Array} data
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     */
                    SigningInput.prototype.data = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningInput instance using the specified properties.
                     * @function create
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {TW.Zilliqa.Proto.ISigningInput=} [properties] Properties to set
                     * @returns {TW.Zilliqa.Proto.SigningInput} SigningInput instance
                     */
                    SigningInput.create = function create(properties) {
                        return new SigningInput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningInput message. Does not implicitly {@link TW.Zilliqa.Proto.SigningInput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {TW.Zilliqa.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.version != null && message.hasOwnProperty("version"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nonce);
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.toAddress);
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.amount);
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.gasPrice);
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.gasLimit);
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.privateKey);
                        if (message.code != null && message.hasOwnProperty("code"))
                            writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.code);
                        if (message.data != null && message.hasOwnProperty("data"))
                            writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.data);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningInput message, length delimited. Does not implicitly {@link TW.Zilliqa.Proto.SigningInput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {TW.Zilliqa.Proto.ISigningInput} message SigningInput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningInput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Zilliqa.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Zilliqa.Proto.SigningInput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.version = reader.uint32();
                                break;
                            case 2:
                                message.nonce = reader.uint64();
                                break;
                            case 3:
                                message.toAddress = reader.string();
                                break;
                            case 4:
                                message.amount = reader.bytes();
                                break;
                            case 5:
                                message.gasPrice = reader.bytes();
                                break;
                            case 6:
                                message.gasLimit = reader.uint64();
                                break;
                            case 7:
                                message.privateKey = reader.bytes();
                                break;
                            case 10:
                                message.code = reader.bytes();
                                break;
                            case 11:
                                message.data = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningInput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Zilliqa.Proto.SigningInput} SigningInput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningInput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningInput message.
                     * @function verify
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningInput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isInteger(message.version))
                                return "version: integer expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            if (!$util.isString(message.toAddress))
                                return "toAddress: string expected";
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            if (!(message.amount && typeof message.amount.length === "number" || $util.isString(message.amount)))
                                return "amount: buffer expected";
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            if (!(message.gasPrice && typeof message.gasPrice.length === "number" || $util.isString(message.gasPrice)))
                                return "gasPrice: buffer expected";
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (!$util.isInteger(message.gasLimit) && !(message.gasLimit && $util.isInteger(message.gasLimit.low) && $util.isInteger(message.gasLimit.high)))
                                return "gasLimit: integer|Long expected";
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                                return "privateKey: buffer expected";
                        if (message.code != null && message.hasOwnProperty("code"))
                            if (!(message.code && typeof message.code.length === "number" || $util.isString(message.code)))
                                return "code: buffer expected";
                        if (message.data != null && message.hasOwnProperty("data"))
                            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                return "data: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningInput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Zilliqa.Proto.SigningInput} SigningInput
                     */
                    SigningInput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Zilliqa.Proto.SigningInput)
                            return object;
                        var message = new $root.TW.Zilliqa.Proto.SigningInput();
                        if (object.version != null)
                            message.version = object.version >>> 0;
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        if (object.toAddress != null)
                            message.toAddress = String(object.toAddress);
                        if (object.amount != null)
                            if (typeof object.amount === "string")
                                $util.base64.decode(object.amount, message.amount = $util.newBuffer($util.base64.length(object.amount)), 0);
                            else if (object.amount.length)
                                message.amount = object.amount;
                        if (object.gasPrice != null)
                            if (typeof object.gasPrice === "string")
                                $util.base64.decode(object.gasPrice, message.gasPrice = $util.newBuffer($util.base64.length(object.gasPrice)), 0);
                            else if (object.gasPrice.length)
                                message.gasPrice = object.gasPrice;
                        if (object.gasLimit != null)
                            if ($util.Long)
                                (message.gasLimit = $util.Long.fromValue(object.gasLimit)).unsigned = true;
                            else if (typeof object.gasLimit === "string")
                                message.gasLimit = parseInt(object.gasLimit, 10);
                            else if (typeof object.gasLimit === "number")
                                message.gasLimit = object.gasLimit;
                            else if (typeof object.gasLimit === "object")
                                message.gasLimit = new $util.LongBits(object.gasLimit.low >>> 0, object.gasLimit.high >>> 0).toNumber(true);
                        if (object.privateKey != null)
                            if (typeof object.privateKey === "string")
                                $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                            else if (object.privateKey.length)
                                message.privateKey = object.privateKey;
                        if (object.code != null)
                            if (typeof object.code === "string")
                                $util.base64.decode(object.code, message.code = $util.newBuffer($util.base64.length(object.code)), 0);
                            else if (object.code.length)
                                message.code = object.code;
                        if (object.data != null)
                            if (typeof object.data === "string")
                                $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                            else if (object.data.length)
                                message.data = object.data;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningInput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @static
                     * @param {TW.Zilliqa.Proto.SigningInput} message SigningInput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningInput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.version = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                            object.toAddress = "";
                            if (options.bytes === String)
                                object.amount = "";
                            else {
                                object.amount = [];
                                if (options.bytes !== Array)
                                    object.amount = $util.newBuffer(object.amount);
                            }
                            if (options.bytes === String)
                                object.gasPrice = "";
                            else {
                                object.gasPrice = [];
                                if (options.bytes !== Array)
                                    object.gasPrice = $util.newBuffer(object.gasPrice);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.gasLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gasLimit = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.privateKey = "";
                            else {
                                object.privateKey = [];
                                if (options.bytes !== Array)
                                    object.privateKey = $util.newBuffer(object.privateKey);
                            }
                            if (options.bytes === String)
                                object.code = "";
                            else {
                                object.code = [];
                                if (options.bytes !== Array)
                                    object.code = $util.newBuffer(object.code);
                            }
                            if (options.bytes === String)
                                object.data = "";
                            else {
                                object.data = [];
                                if (options.bytes !== Array)
                                    object.data = $util.newBuffer(object.data);
                            }
                        }
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                            object.toAddress = message.toAddress;
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = options.bytes === String ? $util.base64.encode(message.amount, 0, message.amount.length) : options.bytes === Array ? Array.prototype.slice.call(message.amount) : message.amount;
                        if (message.gasPrice != null && message.hasOwnProperty("gasPrice"))
                            object.gasPrice = options.bytes === String ? $util.base64.encode(message.gasPrice, 0, message.gasPrice.length) : options.bytes === Array ? Array.prototype.slice.call(message.gasPrice) : message.gasPrice;
                        if (message.gasLimit != null && message.hasOwnProperty("gasLimit"))
                            if (typeof message.gasLimit === "number")
                                object.gasLimit = options.longs === String ? String(message.gasLimit) : message.gasLimit;
                            else
                                object.gasLimit = options.longs === String ? $util.Long.prototype.toString.call(message.gasLimit) : options.longs === Number ? new $util.LongBits(message.gasLimit.low >>> 0, message.gasLimit.high >>> 0).toNumber(true) : message.gasLimit;
                        if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                            object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                        if (message.code != null && message.hasOwnProperty("code"))
                            object.code = options.bytes === String ? $util.base64.encode(message.code, 0, message.code.length) : options.bytes === Array ? Array.prototype.slice.call(message.code) : message.code;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                        return object;
                    };
    
                    /**
                     * Converts this SigningInput to JSON.
                     * @function toJSON
                     * @memberof TW.Zilliqa.Proto.SigningInput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningInput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningInput;
                })();
    
                Proto.SigningOutput = (function() {
    
                    /**
                     * Properties of a SigningOutput.
                     * @memberof TW.Zilliqa.Proto
                     * @interface ISigningOutput
                     * @property {Uint8Array|null} [signature] SigningOutput signature
                     */
    
                    /**
                     * Constructs a new SigningOutput.
                     * @memberof TW.Zilliqa.Proto
                     * @classdesc Represents a SigningOutput.
                     * @implements ISigningOutput
                     * @constructor
                     * @param {TW.Zilliqa.Proto.ISigningOutput=} [properties] Properties to set
                     */
                    function SigningOutput(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * SigningOutput signature.
                     * @member {Uint8Array} signature
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @instance
                     */
                    SigningOutput.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new SigningOutput instance using the specified properties.
                     * @function create
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {TW.Zilliqa.Proto.ISigningOutput=} [properties] Properties to set
                     * @returns {TW.Zilliqa.Proto.SigningOutput} SigningOutput instance
                     */
                    SigningOutput.create = function create(properties) {
                        return new SigningOutput(properties);
                    };
    
                    /**
                     * Encodes the specified SigningOutput message. Does not implicitly {@link TW.Zilliqa.Proto.SigningOutput.verify|verify} messages.
                     * @function encode
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {TW.Zilliqa.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified SigningOutput message, length delimited. Does not implicitly {@link TW.Zilliqa.Proto.SigningOutput.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {TW.Zilliqa.Proto.ISigningOutput} message SigningOutput message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SigningOutput.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer.
                     * @function decode
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {TW.Zilliqa.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TW.Zilliqa.Proto.SigningOutput();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a SigningOutput message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {TW.Zilliqa.Proto.SigningOutput} SigningOutput
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SigningOutput.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a SigningOutput message.
                     * @function verify
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SigningOutput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a SigningOutput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {TW.Zilliqa.Proto.SigningOutput} SigningOutput
                     */
                    SigningOutput.fromObject = function fromObject(object) {
                        if (object instanceof $root.TW.Zilliqa.Proto.SigningOutput)
                            return object;
                        var message = new $root.TW.Zilliqa.Proto.SigningOutput();
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a SigningOutput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @static
                     * @param {TW.Zilliqa.Proto.SigningOutput} message SigningOutput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SigningOutput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this SigningOutput to JSON.
                     * @function toJSON
                     * @memberof TW.Zilliqa.Proto.SigningOutput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SigningOutput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return SigningOutput;
                })();
    
                return Proto;
            })();
    
            return Zilliqa;
        })();
    
        return TW;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.Any = (function() {
    
                /**
                 * Properties of an Any.
                 * @memberof google.protobuf
                 * @interface IAny
                 * @property {string|null} [type_url] Any type_url
                 * @property {Uint8Array|null} [value] Any value
                 */
    
                /**
                 * Constructs a new Any.
                 * @memberof google.protobuf
                 * @classdesc Represents an Any.
                 * @implements IAny
                 * @constructor
                 * @param {google.protobuf.IAny=} [properties] Properties to set
                 */
                function Any(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Any type_url.
                 * @member {string} type_url
                 * @memberof google.protobuf.Any
                 * @instance
                 */
                Any.prototype.type_url = "";
    
                /**
                 * Any value.
                 * @member {Uint8Array} value
                 * @memberof google.protobuf.Any
                 * @instance
                 */
                Any.prototype.value = $util.newBuffer([]);
    
                /**
                 * Creates a new Any instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {google.protobuf.IAny=} [properties] Properties to set
                 * @returns {google.protobuf.Any} Any instance
                 */
                Any.create = function create(properties) {
                    return new Any(properties);
                };
    
                /**
                 * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {google.protobuf.IAny} message Any message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Any.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type_url != null && message.hasOwnProperty("type_url"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {google.protobuf.IAny} message Any message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Any.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Any message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Any} Any
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Any.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type_url = reader.string();
                            break;
                        case 2:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Any message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.Any} Any
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Any.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Any message.
                 * @function verify
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Any.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type_url != null && message.hasOwnProperty("type_url"))
                        if (!$util.isString(message.type_url))
                            return "type_url: string expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };
    
                /**
                 * Creates an Any message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.Any} Any
                 */
                Any.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.Any)
                        return object;
                    var message = new $root.google.protobuf.Any();
                    if (object.type_url != null)
                        message.type_url = String(object.type_url);
                    if (object.value != null)
                        if (typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if (object.value.length)
                            message.value = object.value;
                    return message;
                };
    
                /**
                 * Creates a plain object from an Any message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {google.protobuf.Any} message Any
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Any.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type_url = "";
                        if (options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if (options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                    }
                    if (message.type_url != null && message.hasOwnProperty("type_url"))
                        object.type_url = message.type_url;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    return object;
                };
    
                /**
                 * Converts this Any to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.Any
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Any.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Any;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();

    return $root;
});
